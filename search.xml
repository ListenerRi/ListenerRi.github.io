<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[perl-学习小记]]></title>
    <url>%2F2020%2F03%2F30%2Fperl-%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[因工作需要，学习了原本十分抗拒的 perl 语言，不过整体看下来后发现 perl 也有其自身的特点与优势，看来每个语言都不可小觑。 由于时间比较急，所以在网上找了一篇速读文章学习，教程很棒，读完后对各种奇葩语法有了一定的认识，链接如下： https://qntm.org/perl_cn 下面是一些小笔记： 获取数组长度，前面的 scalar 表示在 scalar 上下文中求 @array 的值，此时即为求数组长度1scalar @array 获取数组最大有效索引1$#array 引用（可以理解为指针）12@array = (1,2,3,4)$array_ref = \@array 匿名结构（也是引用）12$array_ref = [1,2,3,4] # 与上一个 array_ref 一样，都是一个包含四个 scalar 的 array 的引用，但引用的对象不同$hash_ref = &#123;1 =&gt; 2, 3 =&gt; 4&#125; # hash_ref 是一个包含两个键值对的 hash 的引用 引用取值12$array_ref -&gt; [0] # 获取第一个 scalar 1$hash_ref -&gt; &#123;1&#125; # 获取 1 对应的值 2 解引用12@&#123; $array_ref &#125; # 等价于 @$array_ref%&#123; $hash_ref &#125; # 等价于 %$hash_ref 解引用后取值就是正常取值操作12@$array_ref[0] # 获取第一个 scalar 1%$hash_ref&#123;1&#125; # 获取 1 对应的值 2 原地修改 array12pop, push, shift, unshift # 移除或新增 array 的开头或结尾splice # 修改 array 任意位置]]></content>
  </entry>
  <entry>
    <title><![CDATA[macvim 图形界面无法显示中文]]></title>
    <url>%2F2020%2F02%2F17%2Fmacvim-%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%2F</url>
    <content type="text"><![CDATA[使用 brew cask 安装的 macvim，版本为：8.1.2234,161 macvim 图形界面中文显示成问号，但在终端下面却可以正常显示，网上搜了很久都在说编码问题，其实不是，正解如下： 打开 macvim GUI 点击菜单栏-Preferences 点击 Advanced 取消选中 Use Core Text renderer 选项 重启 macvim GUI]]></content>
      <categories>
        <category>osx</category>
      </categories>
      <tags>
        <tag>osx</tag>
        <tag>macvim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clickhouse materialized view 踩坑记录]]></title>
    <url>%2F2019%2F12%2F23%2Fclickhouse-materialized-view-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最近在使用 clickhouse（下面简称 CH） 的 materialized view（下面简称为 MV）功能，类似其他数据库的物化视图，触发器之类的功能，不过遇到了几点坑，有的通过升级 CH 版本解决了，有的可以在写 sql 的时候小心避免。 先列一下我个人总结出来的使用要点，不想继续看的可以尝试依据这些要点看能否解决自己的问题： 在创建 MV 表时，一定要使用 TO 关键字为 MV 表指定存储位置 在创建 MV 表时如果用到了多表联查，不能为连接表指定别名，如果多个连接表中存在同名字段，在连接表的查询语句中使用 AS 将字段名区分开 在创建 MV 表时如果用到了多表联查，只有当第一个查询的表有数据插入时，这个 MV 才会被触发 在创建 MV 表时如果用到了子查询，且子查询会回查 SRC 表，那么这个子查询会回查整个 SRC 表，并不是只有新插入的那部分数据 在创建 MV 表时不要使用 POPULATE 关键字，而是在 MV 表建好之后将数据手动导入 MV 表 先看看官方的创建 MV 的语句： 1CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [TO[db.]name] [ENGINE = engine] [POPULATE] AS SELECT ... 具体的介绍可以阅读官方文档：https://clickhouse.yandex/docs/en/query_language/create/#create-view 值得一提的虽然官方提供了中文文档，但中文文档内容更新不及时，较英文文档有缺失的部分，还是建议阅读英文的。 我使用 MV 的场景是： 1SRC -&gt; MV1 -&gt; MV2 MV1 基于 SRC 表，MV2 基于 MV1 表，且 MV2 中包含多表联查，即 MV2 中的查询语句使用了多个 JOIN 语句，来连接从 MV1 中查询出来的多个子表。 遇到的的第一个坑是： MV2 中的多表联查语句（建表语句中 SELECT 之后的语句）可以手动执行，并使用 INSERT INTO MV2 SELECT ... 语句将结果插入 MV2，但是当通过 MV 功能自动执行这一过程时会报部分列名找不到的错误，自动执行这一过程是指往 SRC 表插入数据，数据会送往 MV1，进而送往 MV2。 起初我使用的 CH 版本是 19.6.2.11，这个版本的 CH 不支持上述问题中的 MV 复杂查询，升级到目前的最新版：19.16.9.37 可以解决，确切的说 MV 的复杂查询是从 19.11.12.69 版本开始支持的，新版本虽然支持了 MV 复杂查询，但是 sql 语法上需要小心：不能为连接表指定别名，如果多个子查询（连接表）中包含同名字段，可以在子查询（连接表）的 SELECT 中使用 AS 为字段名起个别名，然后在 最终选择字段 中使用子表字段的别名。总之就是不能使用表的别名，但可以使用字段的别名。 说起来糊涂，举个例子，假设下面的 SELECT 是 MV2 的建表语句中的 SELECT 部分： 123456789101112131415161718SELECT A.user_id, A.user_name, B.user_age, C.user_genderFROM( SELECT user_id, user_name FROM MV1) AS AALL LEFT JOIN( SELECT user_id, user_age FROM MV1) AS BON A.user_id = B.user_idALL LEFT JOIN( SELECT user_id, user_gender FROM MV1) AS CON A.user_id = c.user_id 由于 MV2 是基于 MV1 的，上述 sql 在手动往 MV1 插入数据时，就会发生报错，但是数据依旧可以插入 MV1，正确的 sql 写法如下： 123456789101112131415161718SELECT user_id, user_name, user_age, user_genderFROM( SELECT user_id, user_name FROM MV1)ALL LEFT JOIN( SELECT user_id AS user_id_a, user_age FROM MV1)ON user_id = user_id_aALL LEFT JOIN( SELECT user_id AS user_id_b, user_gender FROM MV1)ON user_id = user_id_b 新版本虽然支持了 MV 复杂查询，但是引入了一个新的问题：第二层 MV 获取不到数据，在本例中即当数据插入 SRC 时，数据也可以插入到 MV1，但却无法插入到 MV2，也没有任何提示，看起来像是 MV2 完全不知道 MV1 通过 SRC 插入了新数据。这个功能在我使用的旧版 CH 时是支持的，只是那时候不支持 MV 复杂查询，这个问题相关的 issue 是：https://github.com/ClickHouse/ClickHouse/issues/7195，解决方案我已经在这个 issue 中回复了，在这里再说一下。 说到解决方案就得提一下创建 MV 的两种不同的语法： 12// 方法一CREATE MATERIALIZED VIEW IF NOT EXISTS test_view ENGINE = Memory AS SELECT ... 123// 方法二CREATE TABLE test (定义列) ENGINE Memory;CREATE MATERIALIZED VIEW IF NOT EXISTS test_view TO test AS SELECT ... 方法一会自动生成一个 CH 内部表，表名以 .inner. 开头，用来存储 MV 的数据。方法二是先创建一个用来存储 MV 数据的表，这个表跟普通的表一样，然后再创建 MV，但使用 TO 关键字为其指定数据存储的位置。 在目前最新版的 CH 19.16.9.37 中，方法一在只有一层 MV 时可以正常工作，当有两层乃至多层 MV 时，只有第一层 MV 会收到插入 SRC 中的数据，后面的 MV 不知道有新数据插入，方法二可以避免这个问题。 所以在开头我提到的我的使用场景下，可以正常工作的 MV 建表 sql 大致如下： 1234CREATE TABLE src (定义列) ENGINE Memory;CREATE TABLE foo (定义列) ENGINE Memory;CREATE MATERIALIZED VIEW IF NOT EXISTS MV1 TO foo AS SELECT ... FROM src WHERE ...CREATE MATERIALIZED VIEW IF NOT EXISTS MV2 AS SELECT ... FROM foo WHERE ... 但考虑到后期可能会基于 MV2 创建 MV3，所以最好为 MV2 也指定数据存储位置： 12345CREATE TABLE src (定义列) ENGINE Memory;CREATE TABLE foo (定义列) ENGINE Memory;CREATE MATERIALIZED VIEW IF NOT EXISTS MV1 TO foo AS SELECT ... FROM src WHERE ...CREATE TABLE bar (定义列) ENGINE Memory;CREATE MATERIALIZED VIEW IF NOT EXISTS MV2 TO bar AS SELECT ... FROM foo WHERE ...]]></content>
      <categories>
        <category>clickhouse</category>
      </categories>
      <tags>
        <tag>clickhouse</tag>
        <tag>materialized-view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper 小记]]></title>
    <url>%2F2019%2F12%2F04%2Fzookeeper-%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[zookeeper 崩溃恢复过程中两个关键性问题Q1：leader 提交事务 A 后崩溃，follower 没有收到提交事务 A 的消息，再次选举 leader 时如何确保事务 A 被应用？ A1：既然 leader 已经在本地提交了事务 A，那么说明事务 A 肯定已经经过了多数 follower 的确认，即多数 follower 上都有事务 A 的记录，leader 崩溃后，重新选举出的新 leader 肯定包含未提交的事务 A，因为事务 A 的事务 ID 最大，新 leader 会继续提交事务 A。 Q2：leader 在还未将事务 B 广播到集群中时崩溃，在重新选举 leader 并在旧 leader 恢复正常后如何处理事务 B？ A2：事务 B 将会被删除，不会被提交。leader 在接收到一个请求，并将其转化为事务 B 后崩溃，此时还没有将事务 B 广播到集群中，即此事务只存在于 leader 机器上，经过新一轮的 leader 选举后，旧 leader 恢复正常并加入集群，此时会发现事务 B 的事务 ID 所使用的 epoch 号与新 leader 的对不上，那么事务 B 就会被删除。 应用场景把握好 zookeeper 的主要特性就可以将其应用在多种多样的场景下。主要特性如下： 节点 树结构 持久节点 持久顺序节点 临时节点 临时顺序节点 节点只能被注册一次 watcher 在《从 Paxos 到 Zookeeper》一书中提到的应用场景以及我认为场景所应用到的主要特性如下： 数据发布/订阅（配置中心） watcher DNS 服务负载均衡 树结构 watcher 命名服务 持久顺序节点 分布式协调/通知 临时节点 临时顺序节点 watcher 集群管理 临时节点 watcher Master 选举 节点只能被注册一次 watcher 分布式锁 节点只能被注册一次（排他锁/写锁/独占锁） 临时顺序节点（共享锁/读锁） watcher 分布式队列 临时顺序节点 watcher]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[caida tools]]></title>
    <url>%2F2019%2F11%2F27%2Fcaida-tools%2F</url>
    <content type="text"><![CDATA[翻译自：http://www.caida.org/tools/ 主要翻译了工具列表中的“介绍”部分。 支持中的工具 名称 主要作者 英文描述 中文描述 发布日期 最近更新 分类 输入 输出 许可证 arkutil Young Hyun RubyGem containing utility classes used by the Archipelago measurement infrastructure and the MIDAR alias-resolution system. 一个被 Archipelago 测量基础框架和 MIDAR 别名分析系统使用的 RubyGem 工具 2012 2013 库:拓扑 无 无 GNU GPL v2+ ARTEMIS Vasileios Kotronis Defense approach versus BGP prefix hijacking attacks BGP前缀劫持攻击与防御方法 2018 2018 安全 包含 AS 通告的 BGP 前缀的配置文件 警报和 web 接口 BSD 3-Clause AStraceroute (正在开发中) Chiara Orsini A Python tool that translates traceroutes into AS paths 一个将 traceroute 结果转换到 aspath 的 python 工具 2016 2016 拓扑 JSON 编码的 traceroute 数据 JSON(aspath) GNU GPL v3 Autofocus Cristian Estan Internet traffic reports and time-series graphs 网络流量报告和时序图 2003 2003 工作量:可视化 NetFlow data, pcap 文字报告和时序图 Research-use License Beluga Ryan Koga Interactive frontend to traceroute data traceroute 数据的交互式前端 2002 2006 性能:可视化 IP 地址 交互式 traceroute Research-use License BGPstream Alistair King Open-source software framework for live and historical BGP data analysis, supporting scientific research, operational monitoring, and post-event analysis. 用于实时和历史 BGP 数据分析的开源软件框架 支持科学研究 运营监控和事件后分析 2015 2018 拓扑:数据分析 BGP 数据(如 MRT) ASCII, C API, Python API GNU GPL v2 Chart:Graph David Moore Perl front-end to GNU plot and Xmgrace GNU plot 和 Xmgrace 的 perl 前端 2006 2013 库:绘图 无 2D 图 GNU GPL v2 CoralReef Ken Keys Measures and analyzes passive Internet traffic monitor data 测量和分析被动网络流量监控器数据 2000 2014 工作量:测量与分析 网络接口; DAG 采集卡; DAG, libpcap, 和 CoralReef 数据包 文字报告, 流量报告, CoralReef 数据文件 Research-use License Corsaro Alistair King Extensible framework for large-scale analysis of passive trace data 大规模分析被动跟踪数据的可扩展框架 2012 2014 工作量:测量与分析 被动追踪数据(pcap, 接口, 等) 机器可解析文本, Corsaro 二进制数据文件 GNU GPL v3+ Cuttlefish Bradley Huffaker Produces animated graphs showing diurnal and geographical patterns 生成显示日间和地理模式的动画图形 2006 2006 地理:可视化 Cuttlefish 输入文件时序图 (GIF) GNU GPL v2 DBATS Ken Keys High performance time series database engine optimized for inserting/updating values for many series simultaneously 高性能时间序列数据库引擎针对同时插入/更新多个序列的值进行了优化 2016 2016 库:数据库 时序数据 时序数据 GNU GPL v2+ dnsstat Ken Keys DNS traffic measurement utility DNS 流量测量工具 1999 2006 工作量:DNS 分析 pcap, 监控在 UDP 端口 53 上的 DNS 查询数据 文字报告 Research-use License Henya Young Hyun Large-scale Internet topology query system which provides remote search of traceroute data without requiring data downloads 大规模互联网拓扑查询系统，无需下载数据即可远程搜索 traceroute 数据 2016 2016 拓扑 IP web 界面, JSON 数据 GNU GPL v3 Hyperbolic Graph Generator Chiara Orsini A set of tools to generate synthetic graphs embedded into a hyperbolic space and to test the greedy routing 一组工具，用于生成嵌入双曲线空间的合成图并测试贪婪路由 2014 2014 拓扑和性能测量 双曲图参数 hyperbolic in a text file GNU GPL v3 iatmon Nevil Brownlee Ruby+C+libtrace analysis module that separates one-way traffic into clearly-defined subsets Ruby + C + libtrace分析模块，可将单向流量分为明确定义的子集 2012 2014 工作量:测量与分析 Network trace files, or a live network interface text report (matrices, distributions and vectors as statistics of the one-way traffic) GNU GPL v3 iffinder Ken Keys Discovers IPv4 addresses belonging to the same router (aliases) using the common source technique 使用通用源技术发现属于同一路由器（别名）的IPv4地址 2001 2012 拓扑:别名分析 IP 文本文件 Research-use License kapar Ken Keys Graph-based IP alias resolution 基于图的 IP 别名解析 2011 2018 拓扑:别名分析 scamper “warts” traces, iPlane traces, text files alias and link text files GNU GPL v2+ LibSea Young Hyun Scalable graph file format and graph library 可扩展的图形文件格式和图形库 2000 2002 库:拓扑 LibSea graph format files N/A GNU Lesser GPL libtimeseries Alistair King C library that provides a high-performance abstraction layer for efficiently writing to time series databases 提供高性能抽象层的C库，可有效地写入时间序列数据库 2016 2019 库:数据库 time series data time series data BSD 2-Clause Marinda Young Hyun A distributed tuple space implementation 分布式元组空间实现 2015 2015 Library: Middleware N/A N/A GNU GPL v3 MIDAR Ken Keys and Young Hyun Identifies IPv4 addresses belonging to the same router (aliases) using shared monotonic IP ID counters 使用共享的单调 IP ID 计数器标识属于同一路由器（别名）的 IPv4 地址 2011 2018 Topology: Alias Resolution traceroute data or list of addresses alias sets (router addresses) GNU GPL v2+ Motu Alistair King Dealiases pairs of IPv4 addresses Dealiases pairs of IPv4 addresses 2011 2011 Topology: Alias Resolution text input (candidate alias pairs) text report and machine-parseable results GNU GPL v2+ mper Young Hyun Probing engine for conducting network measurements with ICMP, UDP, and TCP probes 使用 ICMP，UDP 和 TCP 探针进行网络测量的探测引擎 2011 2012 Topology and Performance Measurement N/A N/A GNU GPL v2+ Otter Bradley Huffaker Visualizes arbitrary network data 可视化任意网络数据 1998 2003 Topology: Visualization Otter data file interactive 2D graph, PDF GNU GPL v2 Periscope Looking Glass API Vasileios Giotsas API to unify Looking Glass server queries and standardize output 统一 Looking Glass 服务器查询并标准化输出的 API 2015 2016 库:中间件 JSON-encoded API request JSON, iplane format, raw text format Research-use License plot-latlong Young Hyun Plots points on geographic maps 在地理地图上绘制点 2003 2005 Geographic text input (latitude/longitude pair) geographical plot Research-use License PlotPaths Bradley Huffaker Displays forward traceroute path data 显示正向跟踪路由路径数据 2001 2002 Topology: Visualization text input files (paths file, nodes file) Otter data file Research-use License rb-mperio Young Hyun RubyGem for writing network measurement scripts in Ruby that use the mper probing engine 用Ruby编写使用mper探测引擎的网络测量脚本 2011 2013 Library: Topology Measurement N/A N/A GNU GPL v2+ RouterToAsAssignment Ken Keys Assigns each router from a router-level graph of the Internet to its Autonomous System (AS) 将每个路由器从 Internet 的路由器级别图分配给其自治系统（AS） 2010 2010 Topology output from ITDK text report (router to AS report) Research-use License scamper Matthew Luckie IPv6 and IPv4 active traceroute probing and ping IPv6 和 IPv4 主动 traceroute 探测 和 ping 2004 2018 Topology and Performance Measurement IP destinations text reports, “warts” binary file GNU GPL v2 Spoofer Ken Keys, Ryan Koga, and Robert Beverly Source address validation measurement program that measures susceptibility to spoofed source address IP packets 源地址验证测量程序，用于测量对欺骗性源地址 IP 数据包的敏感性 2005 2018 Security N/A text report, HTML report GNU GPL v3+ straightenRV Patrick Verkaik Parses and processes Route Views tables for ease of analysis 解析并处理 Route Views 表以简化分析 2002 2009 Topology: Data Analysis statistics text report (e.g., prefix to AS maps, AS paths, etc), machine-parseable data file Research-use License topostats Young Hyun Computes various statistics on network topologies 计算有关网络拓扑的各种统计信息 2010 2010 Topology text input (e.g., AS link pairs) text report, no graphs GNU GPL v3 Vela Young Hyun On-demand topology measurement service of CAIDA’s Archipelago Measurement Infrastructure CAIDA Archipelago Measurement Infrastructure 的拓扑测量服务 2012 2017 Topology web interface HTML and graph reports GNU GPL v3+ Walrus Young Hyun Visualizes large graphs in three-dimensional space 在三维空间中可视化大型图形 2001 2005 Topology: Visualization LibSea graph format files interactive 3D graph GNU GPL v2 不受支持的工具 名称 主要作者 英文描述 中文描述 状态 发布日期 最近更新 分类 输入 输出 许可证 skitter Daniel McRobb Reads in destinations and outputs traceroute paths 读入目的地并输出traceroute路径 Deprecated by Archipelago 1998 2008 Topology: Measurement skitter data files geographical plot, graph Research-use License RTG Robert Beverly SNMP statistics monitoring system SNMP统计监控系统 In use but not supported by CAIDA 2005 2009 Workload: Visualization SNMP data time series graphs, text traffic reports GNU GPL v2 RRDtool Tobi Oetiker Stores and displays time-series data, configurable graphs 存储和显示时间序列数据，可配置图形 In use but not supported by CAIDA 1999 2006 Plotting and Data Curation time series data time series graphs GNU GPL v2 Plankton Bradley Huffaker Historical visualization of international cache topology 国际缓存拓扑的历史可视化 Deprecated 1998 1998 Topology: Visualization text input graph GNU GPL v2 NeTraMet Nevil Brownlee Realtime traffic flow measurement. 实时流量监测 Deprecated 2003 2007 Workload: Measurement Analysis pcap time series graphs GNU GPL v2 NetGeo Bradley Huffaker Maps IPs and AS numbers to geographical locations 将IP和AS号映射到地理位置 Deprecated 1999 1999 Geographic: Data IP address / URL text report Research-use License MapNet Bradley Huffaker Historical visualization of international backbone providers 国际骨干提供商的历史可视化 Deprecated 1997 2002 Topology: Visualization N/A geographical plot GNU GPL v2 GTrace Ram Periakaruppan Geographical front-end to traceroute 地理前端到 Traceroute Deprecated 1999 1999 Topology: Visualization URL to trace geographical plot Research-use License GeoPlot Ram Periakaruppan Geographically plots nodes and links 地理绘制节点和链接 Deprecated 1999 1999 Topology: Visualization text input (latitude/longitude pair) geographical plot Research-use License FlowScan Dave Plonka Graphs IP flow data for a view of network border traffic 绘制 IP 流数据以查看网络边界流量 In use but not supported by CAIDA 2001 2004 Workload: Analysis Visualization NetFlow data graph (example available) GNU GPL v2 dsc Duane Wessels Collects and displays statistics from DNS servers 从 DNS 服务器收集并显示统计信息 In use but not supported by CAIDA 2007 2010 Workload: DNS Statistics pcap, monitors DNS queries on UDP Port 53 XML intermediate file, graph report (example available) New BSD License dnstop Duane Wessels Measures and displays tables of DNS network traffic 测量并显示 DNS 网络流量表 In use but not supported by CAIDA 2002 2002 Workload: DNS Statistics pcap, monitors DNS queries on UDP Port 53 text report (example available) New BSD License cflowd Daniel McRobb Former NetFlow analysis tool 前 NetFlow 分析工具 Deprecated 1998 2000 Topology and Performance Measurement Netflow data in arts format text reports GNU GPL v2]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>caida</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下为两个网卡调整路由规则]]></title>
    <url>%2F2019%2F11%2F26%2Flinux%E4%B8%8B%E4%B8%BA%E4%B8%A4%E4%B8%AA%E7%BD%91%E5%8D%A1%E8%B0%83%E6%95%B4%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[公司有线网是电信的，访问境外的服务器会间歇性得无法访问，但有一个无线网是移动的，用手机测试发现一直没什么问题，所以搞了个无线网卡连无线网。 但电脑的数据默认只走有线网，只有关了有线网才能用无线网，但是公司内部的服务只能通过有线网访问，所以就尝试了以下方案： 192.168.1.0/24 网段走有线网，其他走无线网 只在访问境外服务器的时候走无线网 经过测试确定这两个方案都能满足我的需求，但是由于无线不如有限稳定，所以最后确定使用第二种方案。 调整路由的工具使用 ip 命令的子命令 route，除了路由子命令还有很多其他网络相关的功能，具体可以查看 ip 命令的 man 手册。 linux 下当连接无线网和有线网之后使用 ip route，可以简写为 ip r 可以列出当前所有的路由规则：123456default via 192.168.1.1 dev enp2s0 proto static metric 100default via 192.168.1.1 dev wlx200db012a6be proto dhcp metric 600172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown192.168.1.0/24 dev enp2s0 proto kernel scope link src 192.168.1.208 metric 100192.168.1.0/24 dev wlx200db012a6be proto kernel scope link src 192.168.1.74 metric 600192.168.252.0/24 dev xdroid0 proto kernel scope link src 192.168.252.1 其中 enp2s0 是有线网相关的路由，wlx200db012a6be 是无线网相关的路由，此外还有 docker 和 xdroid 相关的，后面这两个不用管，没有安装这两个程序的机器也不会有这两种路由。 从上面的路由规则可以看到 enp2s0 相关的 metric 值为 100 而 wlx200db012a6be 相关的 metric 值为 600，这就表示 enp2s0 相关的路由规则比 wlx200db012a6be 相关的路由规则优先级高。在相同的条件下，如相同的 prefix（IP 地址段）时系统将优先使用 enp2s0。 例如以下这两条规则，就表示访问 192.168.1.* 就会走 enp2s0：12192.168.1.0/24 dev enp2s0 proto kernel scope link src 192.168.1.208 metric 100192.168.1.0/24 dev wlx200db012a6be proto kernel scope link src 192.168.1.74 metric 600 此外要注意调整路由规则需要 root 权限。 方案一删除有线网的 default 规则即可实现：1ip r del default via 192.168.1.1 dev enp2s0 proto static metric 100 如此一来，除了 192.168.1.0/24 网段即内网网段内的 ip 访问会走有线网，其他的都会走无线网。 方案二假设我要访问的境外服务器地址为 123.456.789.111，那么只需要添加一条走无线网的路由规则，其仅匹配这个 ip 地址而不是一个网段就行了，经过一番测试，最后确定以下命令可行，测试过程中的无效、错误命令就不贴了：1ip r add 123.456.789.111 via 192.168.1.1 dev wlx200db012a6be 注意 via 后面需要写无线网的网关，不写或者写错都会导致这个 ip 无法访问。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>网卡</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[klib-khash 使用记录]]></title>
    <url>%2F2019%2F11%2F20%2Fklib-khash-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[klib 的项目地址：https://github.com/attractivechaos/klib/ klib 官方文档：http://attractivechaos.github.io/klib/ 总的来说整个 klib 库小巧且功能强大，各种实现之间没有依赖，大多只需要 include 头文件即可使用，目前已经使用过的有 khash 和 klist，这里先说我个人在使用 khash 的过程中遇到的问题和使用过程中需要注意的点。 上面的 klib 官方文档链接中有不少入门的小例子，但也只是简单的使用方法，很多接口并没有提及，不过也有可能作者没有及时更新文档中的例子。 在使用过程中要时刻谨记 khash 中给出的接口都是宏，这也意味着在调试的时候很不方便，如果搞不懂一个接口的意思或者想知道这个接口都做了什么，最好还是看一下 khash.h 中的实现。 就我个人来说，最想提出要注意的一点是 内存释放，在过去一段时间内，我手上依赖 klib 的程序一直都有内存泄漏，不过我始终没有找到原因，直到昨天我才终于定位到是 khash 相关的数据没有被彻底释放。导致这一问题出现的重要原因也在于我接手这个项目时，khash 相关的释放代码已经大量存在了，以至于先入为主，令我以为正确的释放操作就应该就那样，昨天定位到这个问题后我仔细分析了一下 khash 的源码，发现一直以来程序里关于销毁释放内存的操作，一直都是错误的。下面只会使用正确的方法（至少目前我认为是正确的:))，以免误导了其他人。 khash 里面提供了两种数据结构：hashmap 和 hashset，两种结构的使用方法大致是一样的，可以把 hashset 结构看作是没有值的 hashmap。 demo112345678910111213141516171819202122232425262728293031323334353637// 声明 hashmap 名字和键值的类型// 这个宏还定义了大量的函数，不过一般都不直接使用那些函数，而是使用通用的接口宏// 这里声明了一个键值对是 int:int 的 map 类型，注意这里只是声明了一个 类型// 这个 map 类型的名字是 MAP_int2int，map 的名字后面会经常用到// 此外，这个宏是对宏 KHASH_INIT 的一个简单封装// 如果有复杂需求要使用 KHASH_INIT，则需要提供两个 hash 函数，我没有用到就不举例了// hash 函数的实现可以参考 khash 里已有的来实现KHASH_MAP_INIT_INT(MAP_int2int, int);khash_t(MAP_int2int) *map_int2int = kh_init(MAP_int2int); // 使用上面声明的 map 类型声明并初始化一个变量khiter_t iter = 0; // 访问键、值都需要使用 iteriter = kh_get(MAP_int2int, map_int2int, 100); // 查看 100 这个键是否在 map 中存在if (iter == kh_end(map_int2int)) &#123; // 不存在 int ret = 0; // 将 100 这个键放入 map，ret 是一个额外的返回值，用来表示放入操作的结果 iter = kh_put(MAP_int2int, map_int2int, 100, &amp;ret); // 放入成功后返回值 iter 即表示为 100 这个键在 map 中的位置&#125;kh_value(map_int2int, iter) = 200; // 使用 iter 来存值，值为 200/* 至此 map 中就有了 100:200 这一个数据 */// 遍历 mapfor (iter = kh_begin(map_int2int); iter != kh_end(map_int2int); iter++) &#123; if (!kh_exist(map_int2int, iter)) &#123; // 这里的判断一定要有 continue; &#125; do_something_foo(kh_key(map_int2int, iter)); do_something_bar(kh_val(map_int2int, iter));&#125;/* khash 里还提供了更便利的遍历宏：kh_foreach 和 kh_foreach_value */kh_del(MAP_int2int, map_int2int, iter); // 当确定一个 iter 之后，可以移除一个键值对kh_clear(MAP_int2int, map_int2int); // 清空这个 map 的所有数据do_something_zzz(map_int2int); // 清空后的 map 还可以继续使用，比如继续往里面存值kh_destroy(MAP_int2int, map_int2int); // 销毁 map，销毁之后就不能再使用了 demo21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 与 demo1 基本相同，但多了释放内存的操作，不再使用过多注释了struct &#123; // 一些结构体变量&#125; struct_a_tstruct_a_t *create_struct_a() &#123; // 一个创建示例结构体的函数&#125;void free_struct_a(struct_a_t *) &#123; // 一个销毁示例结构体的函数&#125;void free_str(const char *c_str) &#123; // 一个销毁示例字符串的函数 free(c_str);&#125;// 创建测试数据char *test_key = "test_key_data";struct_a_t *test_value = create_struct_a();KHASH_MAP_INIT_STR(MAP_str2struct_p, struct_a_t *);khash_t(MAP_str2struct_p) *map_str2struct_p = kh_init(MAP_str2struct_p);khiter_t iter = 0;iter = kh_get(MAP_str2struct_p, map_str2struct_p, test_key);if (iter == kh_end(map_str2struct_p)) &#123; int ret = 0; iter = kh_put(MAP_str2struct_p, map_str2struct_p, test_key, &amp;ret);&#125;kh_value(map_str2struct_p, iter) = test_value;for (iter = kh_begin(map_str2struct_p); iter != kh_end(map_str2struct_p); iter++) &#123; if (!kh_exist(map_str2struct_p, iter)) &#123; continue; &#125; do_something_foo(kh_key(map_str2struct_p, iter)); do_something_bar(kh_val(map_str2struct_p, iter));&#125;kh_del(MAP_str2struct_p, map_str2struct_p, iter);kh_clear(MAP_str2struct_p, map_str2struct_p);// 需要注意的是，map 或 set 中不论键还是值，只要类型是指针，那么指针指向的内存就需要使用者自行释放kh_free_vals(MAP_str2struct_p, map_str2struct_p, free_struct_a); // 销毁值的宏kh_free(MAP_str2struct_p, map_str2struct_p, free_str); // 销毁键的宏kh_destroy(MAP_str2struct_p, map_str2struct_p); demo312345678910// 还可以嵌套使用KHASH_MAP_INIT_INT(MAP_int2int, int);KHASH_MAP_INIT_STR(MAP_str2map_p, khash_t(MAP_int2int) *);khash_t(MAP_str2map_p) *map_str2map_p = kh_init(MAP_str2map_p);// ...// ...// ...]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>klib</tag>
        <tag>khash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[osx bash completion 补全]]></title>
    <url>%2F2019%2F10%2F31%2Fosx-bash-completion-%E8%A1%A5%E5%85%A8%2F</url>
    <content type="text"><![CDATA[在 linux 下补全的配置一般发行版都给默认配了，原本以为在 OSX 下用 brew 装个 bash-completion 包，再在 bashrc 下贴两行配置也就搞定了，没想到不行，OSX 下 bash-completion 包有两个，另一个是 bash-completion@2，这两个包分别对应 bash 的两个版本，具体可以用 brew info bash-completion@2 来看。 而且 bash-completion@2 跟 bash-completion 相比还要多一行配置，总之就是需要下面两行配置才行，原因是大多软件包都只提供了旧版本的 completion 文件，新版的没有提供支持，所以下面的第一行就是声明要兼容下旧的补全文件：12export BASH_COMPLETION_COMPAT_DIR=&quot;/usr/local/etc/bash_completion.d&quot;[[ -r &quot;/usr/local/etc/profile.d/bash_completion.sh&quot; ]] &amp;&amp; . &quot;/usr/local/etc/profile.d/bash_completion.sh&quot; 除此之外还有个问题，我自己设置了很多别名 alias，但是这些自定义的别名默认是不支持参数补全的，想要如丝般顺滑就要用另一个项目：https://github.com:cykerway/complete-alias，具体的使用方法就不赘述了，可以去项目里看看怎么配置。 经过实践发现这个项目也不支持旧版的 bash-completion 包，会提示 _completion_loader 找不到的错误，改装 bash-completion@2 就好了。]]></content>
      <categories>
        <category>osx</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>completion</tag>
        <tag>_completion_loader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为自己的网站启用 https]]></title>
    <url>%2F2019%2F10%2F28%2F%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99%E5%90%AF%E7%94%A8-https%2F</url>
    <content type="text"><![CDATA[使用 let’s encrypt 证书颁发机构的免费证书，如果想看官方的文档访问下面的链接，官方文档提供了各种方案来启用 https，我使用是推荐的 Certbot 方案。 https://letsencrypt.org/zh-cn/getting-started/ 本文摘自的 Certbot 官网的针对 Ubuntu+Nginx 方案的教程，原文链接如下。 https://certbot.eff.org/lets-encrypt/ubuntuxenial-nginx 如果你的系统不是 Ubuntu 16.04 或者使用的 web 服务不是 nginx 可以去下面的链接重新选择教程。 https://certbot.eff.org 正文开始： 使用 ssh 或任何方法登陆到运行 web 服务的服务器，注意账户需要有 root 权限。 使用下面的命令添加 Certbot PPA 到系统中：12345sudo apt-get updatesudo apt-get install software-properties-commonsudo add-apt-repository universesudo add-apt-repository ppa:certbot/certbotsudo apt-get update 使用如下命令安装 Certbot：1sudo apt-get install certbot python-certbot-nginx 执行如下命令开始一步步安装证书修改 nginx 配置文件，这些都是脚步化自动化的，只需要作出几个选择即可。 1sudo certbot --nginx 安装步骤很简单，虽说是英文但没什么阅读难度，而且会自动安装 crontab 定期任务，这样就不用考虑证书过期的问题了。 需要注意的是，如果你像我一样有个顶级域名，并且想要只使用这个顶级域名，即把所有对 www.listenerri.com 域名的访问全部重定向到 listenerri.com，那么 nginx 配置文件就需要包含这两个域名的 server 节配置，在两个 server 节配置中分别使用 server_name 指定两个域名，否则 certbot 脚本只显示一个域名供选择。]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>certbot</tag>
        <tag>lets-encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clickhouse 部署集群]]></title>
    <url>%2F2019%2F10%2F25%2Fclickhouse-%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[翻译自 clickhouse 官方入门教程第二节：https://clickhouse.yandex/tutorial.html 将 clickhouse 部署到集群ClickHouse 集群是一个 homogenous 集群. 设置步骤是: 在集群内所有机器上安装 ClickHouse 服务端 在配置文件中设置集群相关的配置 在集群内每台机器上创建本地表 创建分布式表（Distributed table） 在 ClickHouse 集群中分布式表事实上是一种关联到每台机器本地表的 view。对分布式表执行查询将使用集群中所有分片（译者注：一个分片即为集群中的一台机器）的资源。可以为多个集群指定配置，并创建多个分布式表以提供对不同集群的 view。 下面的配置是一个有三个分片的集群，每个分片将数据保存到一个副本中（译者注：数据只有一份，没有副本）：12345678910111213141516171819202122&lt;remote_servers&gt; &lt;perftest_3shards_1replicas&gt; &lt;shard&gt; &lt;replica&gt; &lt;host&gt;example-perftest01j.yandex.ru&lt;/host&gt; &lt;port&gt;9000&lt;/port&gt; &lt;/replica&gt; &lt;/shard&gt; &lt;shard&gt; &lt;replica&gt; &lt;host&gt;example-perftest02j.yandex.ru&lt;/host&gt; &lt;port&gt;9000&lt;/port&gt; &lt;/replica&gt; &lt;/shard&gt; &lt;shard&gt; &lt;replica&gt; &lt;host&gt;example-perftest03j.yandex.ru&lt;/host&gt; &lt;port&gt;9000&lt;/port&gt; &lt;/replica&gt; &lt;/shard&gt; &lt;/perftest_3shards_1replicas&gt;&lt;/remote_servers&gt; 创建本地表（译者注：待确定是否在所有分片上都创建本地表）：1CREATE TABLE ontime_local (...) ENGINE = MergeTree(FlightDate, (Year, FlightDate), 8192); 创建分布式表，提供集群中本地表的 view：12CREATE TABLE ontime_all AS ontime_local ENGINE = Distributed(perftest_3shards_1replicas, default, ontime_local, rand()); 可以在集群的每个机器上都创建间一个分布式表。这将允许在集群中的任何一个机器上都能执行分布式查询。除了分布式表还可以使用 remote 表函数。 接下来在分布式表上执行 INSERT SELECT，以将该表扩展到多个服务器。1INSERT INTO ontime_all SELECT * FROM ontime; 值得注意的是，上面给出的方法不适用于大型表的分片。 可以预期，在3台服务器（而不是1台）上启动繁重的查询，执行速度提高了N倍。 你可能已经注意到，分位数计算略有不同。发生这种情况是由于 t-digest 算法的实现是不确定的 – 它取决于数据处理的顺序。 在这个例子中，我们使用了一个包含 3 个分片的集群，每个分片包含一个副本。 为了在生产环境中提供弹性，我们建议每个分片应包含在多个数据中心之间分布的 2-3 个副本。请注意，ClickHouse 支持无限数量的副本。 配置一个包含三个副本的分片集群12345678910111213141516171819&lt;remote_servers&gt; ... &lt;perftest_1shards_3replicas&gt; &lt;shard&gt; &lt;replica&gt; &lt;host&gt;example-perftest01j.yandex.ru&lt;/host&gt; &lt;port&gt;9000&lt;/port&gt; &lt;/replica&gt; &lt;replica&gt; &lt;host&gt;example-perftest02j.yandex.ru&lt;/host&gt; &lt;port&gt;9000&lt;/port&gt; &lt;/replica&gt; &lt;replica&gt; &lt;host&gt;example-perftest03j.yandex.ru&lt;/host&gt; &lt;port&gt;9000&lt;/port&gt; &lt;/replica&gt; &lt;/shard&gt; &lt;/perftest_1shards_3replicas&gt;&lt;/remote_servers&gt; 要启用多副本功能，ZooKeeper 是必需的。 ClickHouse 将负责所有副本上的数据一致性，并在失败后自动运行还原过程。建议将 ZooKeeper 群集部署到单独的服务器。 在某些简单情况下 ZooKeeper 不是必需的，比如你可以通过在应用程序中编码，将数据写入所有副本中来复制数据。但不建议使用此方法，在这种情况下，应由应用程序负责保证所有副本上数据的一致性而不是 ClickHouse。 在配置文件中设置 ZooKeeper：1234567891011121314&lt;zookeeper-servers&gt; &lt;node&gt; &lt;host&gt;zoo01.yandex.ru&lt;/host&gt; &lt;port&gt;2181&lt;/port&gt; &lt;/node&gt; &lt;node&gt; &lt;host&gt;zoo02.yandex.ru&lt;/host&gt; &lt;port&gt;2181&lt;/port&gt; &lt;/node&gt; &lt;node&gt; &lt;host&gt;zoo03.yandex.ru&lt;/host&gt; &lt;port&gt;2181&lt;/port&gt; &lt;/node&gt;&lt;/zookeeper-servers&gt; 另外，我们需要设置宏以识别分片和副本，这将在创建表时使用：1234&lt;macros&gt; &lt;shard&gt;01&lt;/shard&gt; &lt;replica&gt;01&lt;/replica&gt;&lt;/macros&gt; 如果在创建新的副本时没有已存在的副本，则将实例化一个新的第一个副本。如果已经存在副本，则新副本将从现有副本中克隆数据。你可以选择先创建所有副本表，然后再向其中插入数据。也可以选择是在数据插入之后或期间创建一些副本并添加其他副本。1234567CREATE TABLE ontime_replica (...)ENGINE = ReplicatedMergeTree( &apos;/clickhouse_perftest/tables/&#123;shard&#125;/ontime&apos;, &apos;&#123;replica&#125;&apos;, FlightDate, (Year, FlightDate), 8192); 在这里，我们使用 ReplicatedMergeTree 表类型。 在参数中，我们指定包含分片和副本标识符的 ZooKeeper 路径。1INSERT INTO ontime_replica SELECT * FROM ontime; 复制以多主模式运行。数据可以加载到任何副本中，它将自动与其他副本同步。同步是异步的，因此在给定的时间点上，并非所有副本都包含最近插入的数据。为了允许数据插入，至少应有一个副本。其他副本在变为活动状态后，将同步数据并修复一致性。请注意，这种方案允许最近插入的数据丢失的可能性。]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>clickhouse</tag>
        <tag>cluster</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode vim 在 mac osx 和 linux 下输入法自动切换]]></title>
    <url>%2F2019%2F10%2F24%2Fvscode-vim-%E5%9C%A8-mac-osx-%E5%92%8C-linux-%E4%B8%8B%E8%BE%93%E5%85%A5%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[目前 vscode 的 vim 插件支持在不同输入模式下自动切换输入法，可是 vscode 的配置目前不支持判断操作系统， 所以关于输入法切换的相关配置不能在 mac osx 和 linux 下通用，但是又不想因为这个问题维护两份 vscode 的配置文件，所以就想办法在 linux 使用 shell 脚本模仿了一个 im-select 的命令。 关于 vscode vim 插件输入法相关的配置可以到下面的链接中查看： https://github.com/VSCodeVim/Vim#input-method 按照上面的链接在 mac osx 下安装 im-select 并在 vscode 中进行如下配置：1234&quot;vim.autoSwitchInputMethod.enable&quot;: true,&quot;vim.autoSwitchInputMethod.defaultIM&quot;: &quot;com.apple.keylayout.ABC&quot;,&quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;: &quot;/usr/local/bin/im-select&quot;,&quot;vim.autoSwitchInputMethod.switchIMCmd&quot;: &quot;/usr/local/bin/im-select &#123;im&#125;&quot; 关于 vim.autoSwitchInputMethod.defaultIM，我在 mac osx 下用的英文输入法是 com.apple.keylayout.ABC，也可能是其他选项如：com.apple.keylayout.US，这个要根据具体情况来设置。 需要注意的是这个选项的值关系到下面脚本的内容，需要保持一致。 上面的配置在 linux 下会报错，因为上面在 mac osx 下安装的 im-select 没有提供对 linux 的支持，im-select 项目里建议直接使用 fcitx-remote 命令，链接如下： https://github.com/daipeihust/im-select#fcitx 鉴于不想维护两份 vscode 配置文件的原因，分析了一下 vscode 调用 im-select 的情况，在 linux 使用 shell 实现了一个仿冒 mac osx 下 im-select 的脚本，脚本内容如下：1234567891011121314151617181920212223#!/usr/bin/env bash# this script in order to fake the im-select in mac osx for fcitx in linuxIM_EN=&quot;com.apple.keylayout.ABC&quot;IM_CN=&quot;2&quot;FCITX_CMD=/usr/bin/fcitx-remote# there is no arguments that means query the current imif [[ -z $@ ]]; then if [[ &quot;1&quot; == $($FCITX_CMD) ]]; then echo &quot;$IM_EN&quot; else echo &quot;$IM_CN&quot; fielse if [[ &quot;$@&quot; == &quot;$IM_EN&quot; ]]; then $FCITX_CMD -c elif [[ &quot;$@&quot; == &quot;$IM_CN&quot; ]]; then $FCITX_CMD -o fifi 注意根据实际情况修正脚本中 IM_EN 变量的值，将脚本内容复制并保存到 /usr/local/bin/im-select 文件中即可，记得给文件增加可执行权限。]]></content>
      <categories>
        <category>linux</category>
        <category>hackintosh</category>
      </categories>
      <tags>
        <tag>osx</tag>
        <tag>vim</tag>
        <tag>fctix</tag>
        <tag>vscode</tag>
        <tag>im-select</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typedef 函数别名]]></title>
    <url>%2F2019%2F10%2F22%2Ftypedef-%E5%87%BD%E6%95%B0%E5%88%AB%E5%90%8D%2F</url>
    <content type="text"><![CDATA[在 c/cpp 中可以使用 typedef 来给一个类型搞个别名：12345typedef int myint;// 下面 a 和 b 的类型都可以说是 intint a;myint b; 而函数别名的语法有些不同：12345678int max(int, int);typedef int (* max_func_t)(int, int);max_func_t max_alias;// 下面的两个调用是等价的max(1, 2);max_alias(1, 2); 将函数指针作为参数时，使用函数别名可以大大提高代码的可读性：123456789101112131415int max(int, int);// 不使用别名，接收一个函数指针并调用void test(int (* max_func)(int, int)) &#123; max_func(1, 2);&#125;test(max);typedef int (* max_func_t)(int, int);// 使用别名，接收一个函数指针并调用void test(max_func_t max_func) &#123; max_func(1, 2);&#125;test(max); 函数别名的语法一直让我很奇怪写着也很难受，今天又碰到要将函数作为参数传递的情况，于是谷歌了一下，其实可以这样理解：1234567// 正确语法typedef int (*max_func_t)(int, int);// ^ ^ ^// 返回类型 别名 参数// 错误语法，但有助于理解（强行理解）typedef int (*) (int, int) max_func_t;]]></content>
      <categories>
        <category>c</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>typedef</tag>
        <tag>function</tag>
        <tag>别名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于发现了素数的一种用途]]></title>
    <url>%2F2019%2F10%2F21%2F%E7%BB%88%E4%BA%8E%E5%8F%91%E7%8E%B0%E4%BA%86%E7%B4%A0%E6%95%B0%E7%9A%84%E4%B8%80%E7%A7%8D%E7%94%A8%E9%80%94%2F</url>
    <content type="text"><![CDATA[以前只知道素数的定义：质数又称素数。一个大于 1 的自然数，除了 1 和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。今天在学习《编程之法》(github) 时，第一章第二节 “字符串包含”，其提到的一种算法用到了素数，在此仅摘取原文部分内容作为记录。需要注意的是，这种算法并不是这个问题的最优解，具体请查看原文。 以下为原文摘录： 字符串包含 题目描述：给定两个分别由字母组成的字符串 A 和字符串 B，字符串 B 的长度比字符串 A 短。请问，如何最快地判断字符串 B 中所有字母是否都在字符串 A 里？ 为了简单起见，我们规定输入的字符串只包含大写英文字母，请实现函数 bool StringContains(string &amp;A, string &amp;B) 比如，如果是下面两个字符串： String 1：ABCD String 2：BAD 答案是 true，即 String2 里的字母在 String1 里也都有，或者说 String2 是 String1 的真子集。 如果是下面两个字符串： String 1：ABCD String 2：BCE 答案是 false，因为字符串 String2 里的 E 字母不在字符串 String1 里。 同时，如果 string1：ABCD，string 2：AA，同样返回 true。 ……此处省略部分内容…… 解法三 有没有比快速排序更好的方法呢？ 我们换一种角度思考本问题： 假设有一个仅由字母组成字串，让每个字母与一个素数对应，从 2 开始，往后类推，A 对应 2，B 对应 3，C 对应 5，……。遍历第一个字串，把每个字母对应素数相乘。最终会得到一个整数。 利用上面字母和素数的对应关系，对应第二个字符串中的字母，然后轮询，用每个字母对应的素数除前面得到的整数。如果结果有余数，说明结果为 false。如果整个过程中没有余数，则说明第二个字符串是第一个的子集了（判断是不是真子集，可以比较两个字符串对应的素数乘积，若相等则不是真子集）。 思路总结如下： 按照从小到大的顺序，用26个素数分别与字符’A’到’Z’一一对应。 遍历长字符串，求得每个字符对应素数的乘积。 遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除。 输出结果。 如前所述，算法的时间复杂度为 O(m+n) 的最好的情况为 O(n)（遍历短的字符串的第一个数，与长字符串素数的乘积相除，即出现余数，便可退出程序，返回 false），n 为长字串的长度，空间复杂度为O(1)。 1234567891011121314151617181920212223//此方法只有理论意义，因为整数乘积很大，有溢出风险bool StringContain(string &amp;a,string &amp;b)&#123; const int p[26] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,61, 67, 71, 73, 79, 83, 89, 97, 101&#125;; int f = 1; for (int i = 0; i &lt; a.length(); ++i) &#123; int x = p[a[i] - &apos;A&apos;]; if (f % x) &#123; f *= x; &#125; &#125; for (int i = 0; i &lt; b.length(); ++i) &#123; int x = p[b[i] - &apos;A&apos;]; if (f % x) &#123; return false; &#125; &#125; return true;&#125; 此种素数相乘的方法看似完美，但缺点是素数相乘的结果容易导致整数溢出。 ……此处省略部分内容……]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>素数</tag>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过打DSDT补丁让黑苹果显示电池状态信息]]></title>
    <url>%2F2019%2F10%2F11%2F%E9%80%9A%E8%BF%87%E6%89%93DSDT%E8%A1%A5%E4%B8%81%E8%AE%A9%E9%BB%91%E8%8B%B9%E6%9E%9C%E6%98%BE%E7%A4%BA%E7%94%B5%E6%B1%A0%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[翻译自：https://www.tonymacx86.com/threads/guide-how-to-patch-dsdt-for-working-battery-status.116102/ 转载请注明出处 背景因为电脑中的电池硬件与苹果的 SMbus 硬件不兼容，所以在笔记本电脑上运行 OS X 时，我们使用 ACPI 来访问电池状态。一般来说，我建议你使用 ACPIBatteryManager.kext，可在这里找到: https://github.com/RehabMan/OS-X-ACPI-Battery-Driver AppleACPIPlatform 的更高版本无法正确访问 EC（嵌入式控制器）中的字段。由于各种 ACPI 方法（_BIF，_STA，_BST等）失效，这会导致 ACPIBatteryManager 获取电池数据出现问题。尽管可以使用较旧版本的 AppleACPIPlatform（来自 Snow Leopard），但还是希望使用最新版本的AppleACPIPlatform，因为对于具有 Ivy Bridge CPU 的计算机，它可以为这些计算机启用本机电源管理。要使用最新版本，必须更改 DSDT 以符合 Apple 的 AppleACPIPlatform 的限制。 特别是，EC 中大于 8 位的任何字段都必须更改为 8 位。 这包括 16、32、64 甚至更大的字段。 你应该先熟悉 DSDT/SSDT 打补丁的基本知识： http://www.tonymacx86.com/yosemite-laptop-support/152573-guide-patching-laptop-dsdt-ssdts.html 已存在的补丁首先，你的笔记本电脑可能已经有补丁了。请看我的补丁仓库: https://github.com/RehabMan/Laptop-DSDT-Patch 为了使 DSDT 与补丁程序匹配，通常首先需要了解补丁程序的制作方式，以便你知道在 DSDT 中要查找的内容，并且可以将所看到的内容与现有补丁程序进行匹配。补丁集的更改比率很高，不会产生错误，并且似乎在补丁所有需要补丁的字段，这很可能是匹配的（本句原文：A patch set that has a high ratio of changes to patches, creates no errors, and appears to patch all fields that need to be patched is likely a match）。 更多信息: https://www.tonymacx86.com/threads/guide-how-to-patch-dsdt-for-working-battery-status.116102/page-333#post-1360697 注意不要使用除 MaciASL 以外的任何其他程序，包括 DSDT Editor，我只在 MaciASL 中测试了我的补丁 其他相关 DSDT 补丁除了多字节 EC 字段外，还有一些其他 DSDT 问题可能会影响电池状态。这些特定问题并非特定于电池状态，但通常在尝试实现电池状态时首次注意到。 电池代码可能取决于将 Windows 的公认版本用作主机 OS。 要解决此问题，请从 laptop DSDT patch repository 中应用 “OS Check Fix” 补丁。 这将导致 DSDT 采取与运行 “Windows 2006” 时相同的操作。你可以更改补丁以实现不同的选择（例如”Windows 2012”）。 另一个常见的问题是，OS X 的 ACPI 实现很难处理使用非零 SyncLevel 声明的 Mutex 对象（有关更多信息，请阅读ACPI规范）。要解决此问题，请从 laptop DSDT patch repository 中应用 “Fix Mutex with non-zero SyncLevel” 补丁。 技能要求DSDT 是一个“程序”。 因此，在进行修改时具有一些编程/计算机技能会很有帮助。同样，DSDT 补丁本身也具有自己的语言（在 MaciASL Wiki 中进行了简要说明，可在此处找到：http://sourceforge.net/projects/maciasl/ ）。最后，补丁本身基本上是正则表达式的搜索/替换，因此理解正则表达式（regex）会有帮助。熟悉编译器、编译器错误、有能力确定编译器报告的有关代码错误也很有用。 另外，熟悉 ACPI 也是一个好注意。可以在此处下载规范：https://www.acpica.org/ 本指南的目的不是教你基本的编程技巧，正则表达式或 ACPI 语言。 打补丁的步骤我使用了一种相当“机械”的过程来打 DSDT 补丁。我只是寻找那些 OS X 无法处理的部分并机械地转换它。我不会太努力地确定代码的哪些部分实际上将要执行，我只是转换了所有看到的内容。 要继续学习，请从本文中下载示例 DSDT。此特定的 DSDT 示例适用于 HP Envy14。最终的完整补丁可从我的补丁库中以获取 “HP Envy 14”。 首先确定 DSDT 中看起来需要修改的结构。加载 DSDT 文件到 MaciASL 并搜索 EmbeddedControl。单个 DSDT 中可以有多个 EmbeddedControl 部分，每个部分都附加了字段声明。 因此，我总是从寻找 embeddedcontrol 开始以找到这种声明。 在示例 DSDT 中，您将找到以下单个 EC 域：1OperationRegion (ECF2, EmbeddedControl, Zero, 0xFF) 上面的代码声明了一个 255 字节的 EC 域。 这个域被称为 ECF2，所以现在我们要搜索 &#39;Field (ECF2&#39;。正如在示例 DSDT 中可以看到的，只有一个结构定义（译者注：下面的代码块）引用了这个域，在其他的 DSDT 中可能有很多。 结构的定义描述了这个 255 字节 EC 域。它们是有关联的，因为这个结构体定义引用了 ECF2 这个名字（本句原文：You can tell it is related because the name ECF2 is referred to by the Field.）。可以将其视为 EC 中的一种结构（C程序员的结构）（译者注：可以将上面的代码块看作是声明，下面的代码块看作是定义，这样可能更容易理解一些）。 下一步是检查结构定义中的字段，找到大于 8 位的字段。例如，声明的第一个字段是 BDN0，大小为 56 位：1234Field (ECF2, ByteAcc, Lock, Preserve)&#123; Offset (0x10), BDN0, 56, 这是一个大于 8 位的（56 位）字段, 如果这个字段在 DSDT 中的其他位置被访问，则所有出现这个字段的代码都要修改，如果继续搜索 &quot;BDN0&quot; 会找到：1Store (BDN0, BDN) 这是在（从结构 ECF2 中）将 BDN0 中的值存储到 BDN 中。当访问大于 32 位的字段时，它们以 Buffer 类型访问。32 位或以下的字段作为整数访问。在更改代码时，这一点很重要。Buffer 还有一些其他工作要做。同样，需要注意到此代码是从 ECF2 中读取的。从 ECF2 中读取和写入这两种操作必须以不同的方式处理。 因此，针对这行代码，我们的目的是一次读 8 位读 7 次将这个 56 位的元素读取到缓冲区，以便将所得缓冲区存储到 BDN 中。我们一会儿再回来看如何修改，现在让我们探索 ECF2 结构定义中的其他字段。 回到 ECF2 的定义的位置，查看 ECF2 定义的其余部分，查找所有大于 8 位的字段，然后针对每个字段搜索 DSDT 的其余部分，以查看它们是否在其他地方被访问。通常对于那些没有被其他地方访问的字段，我们无需执行任何操作。 因此，我们看到的下一个字段是BMN0：1BMN0, 32, 如果我们在 DSDT 中搜索 BMN0，则只会找到此声明，因此它没有在其他地方被访问，我们可以忽略它。BMN4 也可以被忽略。而 BCT0 是128位并且在其他地方被访问，就像最初的 BDN0 一样：1Store (BCT0, CTN) 进一步的搜索将得到以下列表：1234567891011121314151617181920212223242526272829303132333435363738394041424344 BDN0, 56, BCT0, 128, BDN1, 56, BCT1, 128,... BDC0, 16, BDC1, 16, BFC0, 16, BFC1, 16,... BDV0, 16, BDV1, 16,... BPR0, 16, BPR1, 16, BRC0, 16, BRC1, 16, BCC0, 16, BCC1, 16, CV01, 16, CV02, 16, CV03, 16, CV04, 16, CV11, 16, CV12, 16, CV13, 16, CV14, 16,... BMD0, 16, BMD1, 16, BPV0, 16, BPV1, 16, BSN0, 16, BSN1, 16, BCV0, 16, BCV1, 16, CRG0, 16, CRG1, 16, BTY0, 32, BTY1, 32,... CBT0, 16, CBT1, 16, 正如你所看到的，此 DSDT 中有很多字段需要处理，并且大小各异，16位，32位，56位和128位。 大小为16位和32位的字段16位和32位的字段最容易处理，所以让我们从这里开始。让我们以上面列表中的第一个16位字段 BDC0 为例。我们要做的是更改此字段，以便将其分为两个部分（低字节，高字节）。为此，我们需要提供一个 4 个字符的名称，该名称不得与 DSDT 中的任何其他名称冲突，这通常很容易只需删除第一个字母并使用后三个字母。（译者注：把一个大小为 16 的变量，拆分两个大小为 8 的变量，并使用不同的变量名）123// 之前是: BDC0, 16DC00, 8,DC01, 8, 针对它的补丁可以这样写：1into device label H_EC code_regex BDC0,\s+16, replace_matched begin DC00,8,DC01,8, end; 这个补丁的意思是：在名为 H_EC 的 device 段中，查找 BDC0,\s+16（其中 \s+ 表示一个或多个空白符号），如果找到了则将其替换为 DC00,8,DC01,8,，这有效的将一个字段分成了两个。如果你应用这个补丁，并尝试编译修改后的 DSDT 文件，会发现一些错误，因为依然有代码在引用/访问 BDC0（译者注：BDC0 已经不存在了，因为被拆成了 DC00 和 DC01），这些错误实际上在帮助我们找到有哪地方需要修改：12Store (BDC0, Index (DerefOf (Index (Local0, 0x02)), Zero))Store (ShiftRight (BDC0, 0x08), Index (DerefOf (Index (Local0, 0x02)), One)) 正如你所看到的，这段代码依然在读取已经不存在的、被拆成两部分的 BDC0。为了使补丁更容易编写，我们使用了一个名叫 B1B2 的工具函数，使用如下补丁来定义这个函数：12345into method label B1B2 remove_entry;into definitionblock code_regex . insertbeginMethod (B1B2, 2, NotSerialized) &#123; Return(Or(Arg0, ShiftLeft(Arg1, 8))) &#125;\nend; 这个函数接收两个参数：低字节和高字节，并返回一个包含这两个参数的 16 位的值。（译者注：这个函数的作用是我们可以用这个函数来替换代码中所有对 BDC0 的引用） 针对上面的代码（译者注：注意是代码，不是补丁），我们想要将它转换成这样：12Store (B1B2(DC00,DC01), Index (DerefOf (Index (Local0, 0x02)), Zero))Store (ShiftRight (B1B2(DC00,DC01), 0x08), Index (DerefOf (Index (Local0, 0x02)), One)) 构建一个补丁来自动执行这个转换，并且其他 16 位字段的补丁也将被应用相同的模式：（译者注：注意这里使用的是 replaceall_matched，而上面使用的是 replace_matched，它们的区别从字面及原作者的语义来看前者将对 DSDT 文件中的所有匹配做替换操作，后者只替换一个）1into method label GBTI code_regex \(BDC0, replaceall_matched begin (B1B2(DC00,DC01), end; 敏锐的读者会注意到，可以对以下代码进行优化（译者注：这里没看懂，估计要结合示例 DSDT 文件内容来看才能理解）：12Store (DC00, Index (DerefOf (Index (Local0, 0x02)), Zero))Store (DC01, Index (DerefOf (Index (Local0, 0x02)), One)) 这种优化只能通过手动进行，通常这是不值得的。这里的目标是提出一种修复此代码的自动化方法，而不是试图过多地手动修改，因为如果我们进行过多的手动更改，我们可能会在代码中引入错误。另外，这种代码很少见（在我修改过的 20 多个 DSDT 中仅在两个 DSDT 中看到了它）。 既然你了解了如何处理 16 位的字段，那么将它们全部转换可能是最简单的。这是针对 16 位 EC 字段的综合补丁：1234567891011121314151617181920212223242526272829303132333435# 16-bit registersinto device label H_EC code_regex BDC0,\s+16 replace_matched begin DC00,8,DC01,8 end;into device label H_EC code_regex BDC1,\s+16 replace_matched begin DC10,8,DC11,8 end;into device label H_EC code_regex BFC0,\s+16 replace_matched begin FC00,8,FC01,8 end;into device label H_EC code_regex BFC1,\s+16 replace_matched begin FC10,8,FC11,8 end;into device label H_EC code_regex BDV0,\s+16 replace_matched begin DV00,8,DV01,8 end;into device label H_EC code_regex BDV1,\s+16 replace_matched begin DV10,8,DV11,8 end;into device label H_EC code_regex BPR0,\s+16 replace_matched begin PR00,8,PR01,8 end;into device label H_EC code_regex BPR1,\s+16 replace_matched begin PR10,8,PR11,8 end;into device label H_EC code_regex BRC0,\s+16 replace_matched begin RC00,8,RC01,8 end;into device label H_EC code_regex BRC1,\s+16 replace_matched begin RC10,8,RC11,8 end;into device label H_EC code_regex BCC0,\s+16 replace_matched begin CC00,8,CC01,8 end;into device label H_EC code_regex BCC1,\s+16 replace_matched begin CC10,8,CC11,8 end;into device label H_EC code_regex CV01,\s+16 replace_matched begin CV10,8,CV11,8 end;into device label H_EC code_regex CV02,\s+16 replace_matched begin CV20,8,CV21,8 end;into device label H_EC code_regex CV03,\s+16 replace_matched begin CV30,8,CV31,8 end;into device label H_EC code_regex CV04,\s+16 replace_matched begin CV40,8,CV41,8 end;into device label H_EC code_regex CV11,\s+16 replace_matched begin CV50,8,CV51,8 end;into device label H_EC code_regex CV12,\s+16 replace_matched begin CV60,8,CV61,8 end;into device label H_EC code_regex CV13,\s+16 replace_matched begin CV70,8,CV71,8 end;into device label H_EC code_regex CV14,\s+16 replace_matched begin CV80,8,CV81,8 end;into device label H_EC code_regex HPBA,\s+16 replace_matched begin PBA0,8,PBA1,8 end;into device label H_EC code_regex HPBB,\s+16 replace_matched begin PBB0,8,PBB1,8 end;into device label H_EC code_regex BMD0,\s+16 replace_matched begin MD00,8,MD01,8 end;into device label H_EC code_regex BMD1,\s+16 replace_matched begin MD10,8,MD11,8 end;into device label H_EC code_regex BPV0,\s+16 replace_matched begin PV00,8,PV01,8 end;into device label H_EC code_regex BPV1,\s+16 replace_matched begin PV10,8,PV11,8 end;into device label H_EC code_regex BSN0,\s+16 replace_matched begin SN00,8,SN01,8 end;into device label H_EC code_regex BSN1,\s+16 replace_matched begin SN10,8,SN11,8 end;into device label H_EC code_regex BCV0,\s+16 replace_matched begin BV00,8,BV01,8 end;into device label H_EC code_regex BCV1,\s+16 replace_matched begin BV10,8,BV11,8 end;into device label H_EC code_regex CRG0,\s+16 replace_matched begin RG00,8,RG01,8 end;into device label H_EC code_regex CRG1,\s+16 replace_matched begin RG10,8,RG11,8 end;into device label H_EC code_regex CBT0,\s+16 replace_matched begin BT00,8,BT01,8 end;into device label H_EC code_regex CBT1,\s+16 replace_matched begin BT10,8,BT11,8 end; 并且访问这些字段的所有代码都必须修改：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# fix 16-bit methodsinto method label GBTI code_regex \(BDC0, replaceall_matched begin (B1B2(DC00,DC01), end;into method label GBTI code_regex \(BDC1, replaceall_matched begin (B1B2(DC10,DC11), end;into method label GBTI code_regex \(BFC0, replaceall_matched begin (B1B2(FC00,FC01), end;into method label GBTI code_regex \(BFC1, replaceall_matched begin (B1B2(FC10,FC11), end;into method label BTIF code_regex \(BFC0, replaceall_matched begin (B1B2(FC00,FC01), end;into method label BTIF code_regex \(BFC1, replaceall_matched begin (B1B2(FC10,FC11), end;into method label ITLB code_regex \(BFC1, replaceall_matched begin (B1B2(FC10,FC11), end;into method label ITLB code_regex \sBFC0, replaceall_matched begin B1B2(FC00,FC01), end;into method label _Q09 code_regex \(BRC0, replaceall_matched begin (B1B2(RC00,RC01), end;into method label _Q09 code_regex \sBFC0\) replaceall_matched begin B1B2(FC00,FC01)) end;into method label GBTI code_regex \(BDV0, replaceall_matched begin (B1B2(DV00,DV01), end;into method label GBTI code_regex \(BDV1, replaceall_matched begin (B1B2(DV10,DV11), end;into method label BTIF code_regex \(BDV0, replaceall_matched begin (B1B2(DV00,DV01), end;into method label BTIF code_regex \(BDV1, replaceall_matched begin (B1B2(DV10,DV11), end;into method label GBTI code_regex \(BPR0, replaceall_matched begin (B1B2(PR00,PR01), end;into method label GBTI code_regex \(BPR1, replaceall_matched begin (B1B2(PR10,PR11), end;into method label BTST code_regex \sBPR0, replaceall_matched begin B1B2(PR00,PR01), end;into method label BTST code_regex \sBPR1, replaceall_matched begin B1B2(PR10,PR11), end;into method label BTST code_regex \(BPR0, replaceall_matched begin (B1B2(PR00,PR01), end;into method label BTST code_regex \(BPR1, replaceall_matched begin (B1B2(PR10,PR11), end;into method label BTST code_regex \(BRC0, replaceall_matched begin (B1B2(RC00,RC01), end;into method label BTST code_regex \(BRC1, replaceall_matched begin (B1B2(RC10,RC11), end;into method label GBTI code_regex \(BRC0, replaceall_matched begin (B1B2(RC00,RC01), end;into method label GBTI code_regex \(BRC1, replaceall_matched begin (B1B2(RC10,RC11), end;into method label _Q09 code_regex \(BRC0, replaceall_matched begin (B1B2(RC00,RC01), end;into method label GBTI code_regex \(BCC0, replaceall_matched begin (B1B2(CC00,CC01), end;into method label GBTI code_regex \(BCC1, replaceall_matched begin (B1B2(CC10,CC11), end;into method label GBTI code_regex \(CV01, replaceall_matched begin (B1B2(CV10,CV11), end;into method label GBTI code_regex \(CV02, replaceall_matched begin (B1B2(CV20,CV21), end;into method label GBTI code_regex \(CV03, replaceall_matched begin (B1B2(CV30,CV31), end;into method label GBTI code_regex \(CV04, replaceall_matched begin (B1B2(CV40,CV41), end;into method label GBTI code_regex \(CV11, replaceall_matched begin (B1B2(CV50,CV51), end;into method label GBTI code_regex \(CV12, replaceall_matched begin (B1B2(CV60,CV61), end;into method label GBTI code_regex \(CV13, replaceall_matched begin (B1B2(CV70,CV71), end;into method label GBTI code_regex \(CV14, replaceall_matched begin (B1B2(CV80,CV81), end;into method label BTIF code_regex \(BMD0, replaceall_matched begin (B1B2(MD00,MD01), end;into method label BTIF code_regex \(BMD1, replaceall_matched begin (B1B2(MD10,MD11), end;into method label GBTI code_regex \sBMD0\) replaceall_matched begin B1B2(MD00,MD01)) end;into method label GBTI code_regex \(BMD0, replaceall_matched begin (B1B2(MD00,MD01), end;into method label GBTI code_regex \sBMD1\) replaceall_matched begin B1B2(MD10,MD11)) end;into method label GBTI code_regex \(BMD1, replaceall_matched begin (B1B2(MD10,MD11), end;into method label BTST code_regex \(BPV0, replaceall_matched begin (B1B2(PV00,PV01), end;into method label BTST code_regex \(BPV1, replaceall_matched begin (B1B2(PV10,PV11), end;into method label GBTI code_regex \(BPV0, replaceall_matched begin (B1B2(PV00,PV01), end;into method label GBTI code_regex \(BPV1, replaceall_matched begin (B1B2(PV10,PV11), end;into method label BTIF code_regex \(BSN0, replaceall_matched begin (B1B2(SN00,SN01), end;into method label BTIF code_regex \(BSN1, replaceall_matched begin (B1B2(SN10,SN11), end;into method label GBTI code_regex \(BSN0, replaceall_matched begin (B1B2(SN00,SN01), end;into method label GBTI code_regex \(BSN1, replaceall_matched begin (B1B2(SN10,SN11), end;into method label GBTI code_regex \(BCV0, replaceall_matched begin (B1B2(BV00,BV01), end;into method label GBTI code_regex \(BCV1, replaceall_matched begin (B1B2(BV10,BV11), end;into method label GBTI code_regex \(CRG0, replaceall_matched begin (B1B2(RG00,RG01), end;into method label GBTI code_regex \(CRG1, replaceall_matched begin (B1B2(RG10,RG11), end;into method label GBTI code_regex \(CBT0, replaceall_matched begin (B1B2(BT00,BT01), end;into method label GBTI code_regex \(CBT1, replaceall_matched begin (B1B2(BT10,BT11), end; 现在那些 32 位的字段如 BTY0 和 BTY1 如何处理呢？ 它们与 16 位的字段处理方式差不多，除了我们需要再声明一个名为 B1B4 的函数，它能从四个 8 位的参数中构造出一个 32 位的值：123456789101112into method label B1B4 remove_entry;into definitionblock code_regex . insertbeginMethod (B1B4, 4, NotSerialized)\n&#123;\n Store(Arg3, Local0)\n Or(Arg2, ShiftLeft(Local0, 8), Local0)\n Or(Arg1, ShiftLeft(Local0, 8), Local0)\n Or(Arg0, ShiftLeft(Local0, 8), Local0)\n Return(Local0)\n&#125;\nend; 然后我们需要将 BTY0 和 BTY1 转换成 4 个 8 位的字段：123# 32-bit registersinto device label H_EC code_regex BTY0,\s+32 replace_matched begin TY00,8,TY01,8,TY02,8,TY03,8 end;into device label H_EC code_regex BTY1,\s+32 replace_matched begin TY10,8,TY11,8,TY12,8,TY13,8 end; 下面这些在 GBTI 函数中的代码需要修改，因为它们引用了 BTY0 和 BYT1：123 Store (BTY0, BTY)... Store (BTY1, BTYB) 很像针对 16 位字段所做的补丁，但使用的是 B1B4 函数：123# fix 32-bit methodsinto method label GBTI code_regex \(BTY0, replaceall_matched begin (B1B4(TY00,TY01,TY02,TY03), end;into method label GBTI code_regex \(BTY1, replaceall_matched begin (B1B4(TY10,TY11,TY12,TY13), end; 这个补丁将会把上面的代码修改成下面这样：123 Store (B1B4(TY00,TY01,TY02,TY03), BTY)... Store (B1B4(TY10,TY11,TY12,TY13), BTYB) 缓冲字段（大于 32 位的字段）回到我们最初对大于8位的字段的搜索结果，发现我们有这些大于32位的字段：1234BDN0, 56,BCT0, 128,BDN1, 56,BCT1, 128, 要一次以 8 位访问这些字段很繁琐，因此我喜欢通过 offset（偏移量） 来访问它们，并确保没有现有的代码直接访问它们，我们使用如下补丁将其重命名：1234into device label H_EC code_regex (BDN0,)\s+(56) replace_matched begin BDNX,%2,//%1%2 end;into device label H_EC code_regex (BDN1,)\s+(56) replace_matched begin BDNY,%2,//%1%2 end;into device label H_EC code_regex (BCT0,)\s+(128) replace_matched begin BCTX,%2,//%1%2 end;into device label H_EC code_regex (BCT1,)\s+(128) replace_matched begin BCTY,%2,//%1%2 end; 接下来，我们需要确定这些字段在结构体 ECF2 内的偏移量。请记住，大小以位为单位，但偏移量以字节为单位（译者注：这里需要记住）。我在下面的注释中使用的偏移量以十六进制表示。你可以看看是否能计算出相同的数字。12345678910111213141516171819Field (ECF2, ByteAcc, Lock, Preserve)&#123; Offset (0x10), BDN0, 56, //!!0x10 Offset (0x18), BME0, 8, Offset (0x20), BMN0, 32, //0x20 BMN2, 8, //0x24 BMN4, 88, //0x25 BCT0, 128, //!! 0x30 BDN1, 56, //!! 0x40 Offset (0x48), BME1, 8, Offset (0x50), BMN1, 32, //0x50 BMN3, 8, //0x54 BMN5, 88, //0x55 BCT1, 128, //!!0x60 一旦你运行了上面的补丁并编译，编译器会告诉你哪些地方需要被注意（译者注：编译报错的地方即需要被修改的地方）。在这个例子中，我们会看到下面的错误：123456789... Store (BCT0, CTN)... Store (BDN0, BDN)... Store (BCT1, CTNB)... Store (BDN1, BDNB)... 出现这些错误是因为 BCT0, BDN0, BCT1, BDN1 这些字段被我们改了名字。 正如你所看到的，代码在从这些缓冲字段读取并将它们存储在其他位置。为了一次读取这些缓冲字段 8 位数据，我们需要定义其他函数：12345678910111213141516171819202122232425262728# utility methods to read/write buffers from/to ECinto method label RE1B parent_label H_EC remove_entry;into method label RECB parent_label H_EC remove_entry;into device label H_EC insertbeginMethod (RE1B, 1, NotSerialized)\n&#123;\n OperationRegion(ERAM, EmbeddedControl, Arg0, 1)\n Field(ERAM, ByteAcc, NoLock, Preserve) &#123; BYTE, 8 &#125;\n Return(BYTE)\n&#125;\nMethod (RECB, 2, Serialized)\n// Arg0 - offset in bytes from zero-based EC\n// Arg1 - size of buffer in bits\n&#123;\n ShiftRight(Add(Arg1,7), 3, Arg1)\n Name(TEMP, Buffer(Arg1) &#123; &#125;)\n Add(Arg0, Arg1, Arg1)\n Store(0, Local0)\n While (LLess(Arg0, Arg1))\n &#123;\n Store(RE1B(Arg0), Index(TEMP, Local0))\n Increment(Arg0)\n Increment(Local0)\n &#125;\n Return(TEMP)\n&#125;\nend; “RECB” 代表 “读 EC 缓冲区”。它接受两个参数，指示 EC 中的偏移量和希望读取的字段的位大小。以位为单位的大小必须是 8 的倍数。注意，函数中没有检查这个参数。 在此 DSDT 中，比如在名为 H_EC 的 EC 设备（译者注：代码段）中定义这些辅助方法：123Device (H_EC)&#123; Name (_HID, EisaId (&quot;PNP0C09&quot;)) 如果你的 EC 设备（译者注：代码段）名称不同（译者注：不叫 H_EC），则需要更改上面创建 RECB/RE1B 这两个函数的补丁。通常名称为 EC，EC0，在本例中为 H_EC。 为了处理 BCT0 的第一种情况，我们希望修改成这样：1Store(RECB(0x30,128), CTN) 0x30 是 BTC0 字段（现在称为 BCTX）的偏移量，而 128 是位数。 这些可以通过以下补丁来完成修改：1234into method label GBTI code_regex \(BCT0, replaceall_matched begin (RECB(0x30,128), end;into method label GBTI code_regex \(BCT1, replaceall_matched begin (RECB(0x60,128), end;into method label GBTI code_regex \(BDN0, replaceall_matched begin (RECB(0x10,56), end;into method label GBTI code_regex \(BDN1, replaceall_matched begin (RECB(0x40,56), end; 此 DSDT 没有对 EC 缓冲字段的任何写操作，但如果有，则下面的函数非常有用：12345678910111213141516171819202122232425262728into method label WE1B parent_label H_EC remove_entry;into method label WECB parent_label H_EC remove_entry;into device label H_EC insertbeginMethod (WE1B, 2, NotSerialized)\n&#123;\n OperationRegion(ERAM, EmbeddedControl, Arg0, 1)\n Field(ERAM, ByteAcc, NoLock, Preserve) &#123; BYTE, 8 &#125;\n Store(Arg1, BYTE)\n&#125;\nMethod (WECB, 3, Serialized)\n// Arg0 - offset in bytes from zero-based EC\n// Arg1 - size of buffer in bits\n// Arg2 - value to write\n&#123;\n ShiftRight(Add(Arg1,7), 3, Arg1)\n Name(TEMP, Buffer(Arg1) &#123; &#125;)\n Store(Arg2, TEMP)\n Add(Arg0, Arg1, Arg1)\n Store(0, Local0)\n While (LLess(Arg0, Arg1))\n &#123;\n WE1B(Arg0, DerefOf(Index(TEMP, Local0)))\n Increment(Arg0)\n Increment(Local0)\n &#125;\n&#125;\nend; 假设写入 BCT0 的代码是：1Store(Local0, BCT0) 在这种情况下，不能用对 RECB 的调用来代替对 BCT0 的访问。因为这是写操作，而不是读操作。必须使用上面新创建的函数 WECB。1WECB(0x30,128, Local0) WECB 函数的前两个参数与 RECB 相同（EC字段的偏移量和大小）。第三个参数（Arg2）是应写入 EC 字段的值。在这个例子中，是从 Local0 读取数据写入到第一个参数指定的偏移量里。 Store 并不是唯一可以执行写操作的 AML 操作码。Store 也不是唯一可以执行读操作的 AML 操作码。 例如 Add 操作码：1Add(X, Y, Z) 上面的示例从X读取，从Y读取，执行加法…并将结果写入Z。 当不确定 AML 操作码的用途时，请阅读 ACPI 规范。在那里有完整的文档，但不在本文讨论范围之内。 文字开头给出的 github 仓库是示例和学习的良好来源。仓库中的现有修补程序中有许多 WECB/RECB 示例。 充电/放电状态的逻辑错误(充电器检测)某些 DSDT 存在逻辑错误，在这种情况下，容量达到 100％（电池充满电）时，_BST 返回了错误的状态。这主要影响某些华硕笔记本电脑，但也影响其他一些笔记本电脑。 这是解决此问题的补丁程序：12345678910into method label FBST code_regex If\s\(CHGS\s\(Zero\)\)[\s]+\&#123;[\s]+Store\s\(0x02,\sLocal0\)[\s]+\&#125;[\s]+Else[\s]+\&#123;[\s]+Store\s\(One,\sLocal0\)[\s]+\&#125; replaceall_matched beginIf (CHGS (Zero))\n&#123;\n Store (0x02, Local0)\n&#125;\nElse\n&#123;\n Store (Zero, Local0)\n&#125;end; 错误报告下载 patchmatic: https://bitbucket.org/RehabMan/os-x-maciasl-patchmatic/downloads/RehabMan-patchmatic-2015-0107.zip 从 zip 中解压出 ‘patchmatic’ 二进制文件. 复制到 /usr/bin, 即最终的文件位置是：/usr/bin/patchmatic. 在终端中：1234if [ -d ~/Downloads/RehabMan ]; then rm -R ~/Downloads/RehabMan; fimkdir ~/Downloads/RehabMancd ~/Downloads/RehabManpatchmatic -extract 注意：如果使用复制/粘贴而不是手动键入命令，会更容易。 将 ~/Downloads/RehabMan 目录打包成 zip 文件。 另外将 ioreg 也打包成 zip：http://www.tonymacx86.com/audio/58368-guide-how-make-copy-ioreg.html. 注意要用帖子中提到的 IORegistryExplorer v2.1！不要使用其他版本的 IORegistryExplorer.app。 还有以下命令的输出：123kextstat|grep -y acpiplatkextstat|grep -y appleintelcpukextstat|grep -y applelpc 还有打包成 zip 的 EFI/Clover 目录（在打包前先在 Clover 界面按一下 F4）。注意要删除 ‘themes’ 目录，尤其是如果你安装了很多主题，还有只需要提供 EFI/Clover 而不是整个 EFI 目录。 还有以下命令的输出：1sudo touch /System/Library/Extensions &amp;&amp; sudo kextcache -u / 再把上面提到的所有内容打包成一个大的 zip 文件并发布到帖子里。不要使用外部链接，使用编辑帖子时的上传文件功能。 贡献如果你确实完成了给你的电池方法打补丁，建议你将你的补丁和你的电脑信息共享出来，让其他与你是同样配置的人也能使用你的补丁，我可以将你的补丁程序添加到上面提到的 github 仓库中。请同时提供包含补丁和本机 DSDT 的文本文件（以便我能够根据本机 DSDT 查看补丁程序）。只有可以将补丁应用到本机 DSDT上时，我才会将这个补丁添加到仓库中。 译者注：示例 DSDT 文件请从原文中下载。]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>osx</tag>
        <tag>hackintosh</tag>
        <tag>dsdt</tag>
        <tag>电池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将数据从mysql导入到excel碰到的坑]]></title>
    <url>%2F2019%2F10%2F10%2F%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8Emysql%E5%AF%BC%E5%85%A5%E5%88%B0excel%E7%A2%B0%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[记录一些在 windows 下将数据从 mysql 导入到 excel 过程中遇到的坑。首先，这一操作有两种方案： 在 navicat 中进行操作，将数据写入到 excel 文件中 在 excel 中进行操作，将数据从 mysql 服务器写入文件 第一种方案同事说在数据量很大的时候导出速度很慢，原因不明，我猜测是因为 navicat 使用的 POI 技术实现的功能，没有深究。第二种方案就我进行测试的方案，这种方案至少在速度方面有很明显的提升，下面列一下测试过程中遇到的坑： 只能使用 windows 的 office excel，wps 的表格有奇怪的问题无法解决（后来发现是因为系统中没有安装 Visual C++ Redistributable Packages for Visual Studio 2013） 安装 Mysql ODBC 驱动时要注意 excel 的软件位数，如果 excel 是 32 位的，那么 Mysql ODBC 驱动也必须是 32 位的 64 位系统不显示 32 位的 ODBC 驱动，需要手动打开 C:\\Windows\\sysWOW64\\odbcad32.exe 程序添加连接 导入数据时出现错误：MySQL client ran out of memory，调整系统中的数据源(ODBC)中的连接选项，找到并勾选”Do not cache result”之类的选项，应该可以解决]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国际域名缩写]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%9B%BD%E9%99%85%E5%9F%9F%E5%90%8D%E7%BC%A9%E5%86%99%2F</url>
    <content type="text"><![CDATA[转自：http://www.jctrans.com/tool/gjym.htm 国际域名缩写 国际域名缩写 国家或地区 Countries and Regions AD 安道尔共和国 Andorra AE 阿拉伯联合酋长国 United Arab Emirates AF 阿富汗 Afghanistan AG 安提瓜和巴布达 Antigua and Barbuda AI 安圭拉岛 Anguilla AL 阿尔巴尼亚 Albania AM 亚美尼亚 Armenia AO 安哥拉 Angola AR 阿根廷 Argentina AT 奥地利 Austria AU 澳大利亚 Australia AZ 阿塞拜疆 Azerbaijan BB 巴巴多斯 Barbados BD 孟加拉国 Bangladesh BE 比利时 Belgium BF 布基纳法索 Burkina-faso BG 保加利亚 Bulgaria BH 巴林 Bahrain BI 布隆迪 Burundi BJ 贝宁 Benin BL 巴勒斯坦 Palestine BM 百慕大群岛 Bermuda Is. BN 文莱 Brunei BO 玻利维亚 Bolivia BR 巴西 Brazil BS 巴哈马 Bahamas BW 博茨瓦纳 Botswana BY 白俄罗斯 Belarus BZ 伯利兹 Belize CA 加拿大 Canada CF 中非共和国 Central African Republic CG 刚果 Congo CH 瑞士 Switzerland CK 库克群岛 Cook Is. CL 智利 Chile CM 喀麦隆 Cameroon CN 中国 China CO 哥伦比亚 Colombia CR 哥斯达黎加 Costa Rica CS 捷克 Czech CU 古巴 Cuba CY 塞浦路斯 Cyprus CZ 捷克 Czech Republic DE 德国 Germany DJ 吉布提 Djibouti DK 丹麦 Denmark DO 多米尼加共和国 Dominica Rep. DZ 阿尔及利亚 Algeria EC 厄瓜多尔 Ecuador EE 爱沙尼亚 Estonia EG 埃及 Egypt ES 西班牙 Spain ET 埃塞俄比亚 Ethiopia FI 芬兰 Finland FJ 斐济 Fiji FR 法国 France GA 加蓬 Gabon GB 英国 United Kiongdom GD 格林纳达 Grenada GE 格鲁吉亚 Georgia GF 法属圭亚那 French Guiana GH 加纳 Ghana GI 直布罗陀 Gibraltar GM 冈比亚 Gambia GN 几内亚 Guinea GR 希腊 Greece GT 危地马拉 Guatemala GU 关岛 Guam GY 圭亚那 Guyana HK 香港特别行政区 Hongkong HN 洪都拉斯 Honduras HT 海地 Haiti HU 匈牙利 Hungary ID 印度尼西亚 Indonesia IE 爱尔兰 Ireland IL 以色列 Israel IN 印度 India IQ 伊拉克 Iraq IR 伊朗 Iran IS 冰岛 Iceland IT 意大利 Italy JM 牙买加 Jamaica JO 约旦 Jordan JP 日本 Japan KE 肯尼亚 Kenya KG 吉尔吉斯坦 Kyrgyzstan KH 柬埔寨 Kampuchea (Cambodia ) KP 朝鲜 North Korea KR 韩国 Korea KT 科特迪瓦共和国 Republic of Ivory Coast KW 科威特 Kuwait KZ 哈萨克斯坦 Kazakstan LA 老挝 Laos LB 黎巴嫩 Lebanon LC 圣卢西亚 St.Lucia LI 列支敦士登 Liechtenstein LK 斯里兰卡 Sri Lanka LR 利比里亚 Liberia LS 莱索托 Lesotho LT 立陶宛 Lithuania LU 卢森堡 Luxembourg LV 拉脱维亚 Latvia LY 利比亚 Libya MA 摩洛哥 Morocco MC 摩纳哥 Monaco MD 摩尔多瓦 Moldova, Republic of MG 马达加斯加 Madagascar ML 马里 Mali MM 缅甸 Burma MN 蒙古 Mongolia MO 澳门 Macao MS 蒙特塞拉特岛 Montserrat Is MT 马耳他 Malta MU 毛里求斯 Mauritius MV 马尔代夫 Maldives MW 马拉维 Malawi MX 墨西哥 Mexico MY 马来西亚 Malaysia MZ 莫桑比克 Mozambique NA 纳米比亚 Namibia NE 尼日尔 Niger NG 尼日利亚 Nigeria NI 尼加拉瓜 Nicaragua NL 荷兰 Netherlands NO 挪威 Norway NP 尼泊尔 Nepal NR 瑙鲁 Nauru NZ 新西兰 New Zealand OM 阿曼 Oman PA 巴拿马 Panama PE 秘鲁 Peru PF 法属玻利尼西亚 French Polynesia PG 巴布亚新几内亚 Papua New Cuinea PH 菲律宾 Philippines PK 巴基斯坦 Pakistan PL 波兰 Poland PR 波多黎各 Puerto Rico PT 葡萄牙 Portugal PY 巴拉圭 Paraguay QA 卡塔尔 Qatar RO 罗马尼亚 Romania RU 俄罗斯 Russia SA 沙特阿拉伯 Saudi Arabia SB 所罗门群岛 Solomon Is SC 塞舌尔 Seychelles SD 苏丹 Sudan SE 瑞典 Sweden SG 新加坡 Singapore SI 斯洛文尼亚 Slovenia SK 斯洛伐克 Slovakia SL 塞拉利昂 Sierra Leone SM 圣马力诺 San Marino SN 塞内加尔 Senegal SO 索马里 Somali SR 苏里南 Suriname ST 圣多美和普林西比 Sao Tome and Principe SV 萨尔瓦多 EI Salvador SY 叙利亚 Syria SZ 斯威士兰 Swaziland TD 乍得 Chad TG 多哥 Togo TH 泰国 Thailand TJ 塔吉克斯坦 Tajikstan TM 土库曼斯坦 Turkmenistan TN 突尼斯 Tunisia TO 汤加 Tonga TR 土耳其 Turkey TT 特立尼达和多巴哥 Trinidad and Tobago TW 台湾省 Taiwan TZ 坦桑尼亚 Tanzania UA 乌克兰 Ukraine UG 乌干达 Uganda US 美国 United States of America UY 乌拉圭 Uruguay UZ 乌兹别克斯坦 Uzbekistan VC 圣文森特岛 Saint Vincent VE 委内瑞拉 Venezuela VN 越南 Vietnam YE 也门 Yemen YU 南斯拉夫 Yugoslavia ZA 南非 South Africa ZM 赞比亚 Zambia ZR 扎伊尔 Zaire ZW 津巴布韦 Zimbabwe]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在自己的服务器上搭建静态博客]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[最近 coding 的 pages 服务越来越没法用了，不是自动部署失败就是博客无法访问，而且访问速度很慢，估计再过段时间 coding 就不再提供免费的 pages 服务了。但是如果将域名解析到 github 上，百度又无法抓取(github 不允许)，思来想去还是放在自己的服务器上吧。 不过放在自己的服务器上有两个问题： 没有备案不能使用 dnspod 的 301 重定向把 www 的域名重定向到顶级域名 博客更新后不能自动部署 我的博客是个基于 hexo 的静态博客，可以使用 nginx 来提供 web 服务，同时 nginx 可以配置根据域名来重定向，这样就解决了第一个问题，博客内容就使用 git 仓库，注意这个仓库不是 markdown 的原始文件，而是经过 hexo 根据生成后的 html 站点，如果之前在 github 上部署过，在 github 上的仓库的名字应该会是 &lt;UserName&gt;.github.io 或者在 coding 上部署过那仓库名则是 coding 下跟用户名相同的仓库。以后更新了博客依然推送到 github 或者 coding 上，在自己的服务器上 clone 下仓库，然后使用 github 或者 coding 的 webhooks 功能更新自己服务器上的仓库，这样就解决了自己服务器上的博客不能自动部署更新的问题。 下面的例子是基于 github 的，coding 的操作类似，不过鉴于 coding 提供的服务不太稳定的问题，建议博客仓库托管也不要放在 coding 上了。 克隆博客仓库到服务器上这一步很简单，跟克隆普通 git 仓库一样，我把仓库放在了 /opt/hexo-blog 下，如果不放在这个路径下，那后面的内容中的相应路径也要修改。 以我在 github 下的博客仓库为例，注意执行命令的用户权限，后面的命令都假设服务器上的账户是 root： 1git clone git@github.com:listenerri/listenerri.github.io.git /opt/hexo-blog 这里使用了 ssh 协议的仓库地址，这需要将服务器的 ssh public key 部署在自己的 github 账户中，如果不想部署使用 https 协议的地址也可以，不过可能会需要输入用户名和密码，这会影响到后面 python 脚本中的功能，建议还是用 ssh 协议的地址，部署个 key 又不麻烦。 安装配置 nginx在服务器上安装配置 nginx，debian 系的 linux 系统中使用下面的命令就可以安装，其他系统可以在网上找找 ： 1apt install nginx 安装之后不要急着启动 nginx 服务，要先配置下网站路径和域名相关的东西。 编辑 /etc/nginx/nginx.conf 文件，在 http 块中添加两个 server 块配置： 12345678910111213141516http &#123; server &#123; listen 80 default_server; server_name listenerri.com; root /opt/hexo-blog; location / &#123; &#125; &#125; server &#123; listen 80; server_name www.listenerri.com; return 301 http://listenerri.com$request_uri; &#125;&#125; 第一个 server 块定义了主域名下的网站，也就是博客使用的域名和博客在服务器上的路径(上面克隆仓库时指定的地址)，第二个 server 块则是定义了将 www 的域名 301 重定向的顶级域名的网站下，我比较喜欢不带 www 的地址 :) 接下来启动 nginx 服务： 123service nginx start# 或者如果系统是 systemd 的：systemctl start nginx 修改域名解析地址上面 nginx 服务启动后就可以使用服务器的 ip 地址(这时还不能使用域名)进行访问了，如果测试没问题就可以修改域名的解析到这个服务器 ip 上了，这一步没什么好说的，就是把自己域名的 A 记录改成服务器的 ip 地址。 改完之后过一会儿使用 dig 命令查看域名是否已经解析到服务器的地址了，如果解析已经生效了就可以访问域名来测试博客是否可以正常访问了。 注意把 www 的域名也解析到服务器 ip 地址上。 启动 github webhooks在服务器上把下面的代码保存到一个 py 文件中，假设文件路径为 /opt/webhooks.py： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env python3# -*- coding: utf-8 -*-from http.server import BaseHTTPRequestHandlerfrom http.server import HTTPServerimport osimport subprocessimport sysclass MyBaseHTTPRequestHandler(BaseHTTPRequestHandler): def do_GET(self): self.send_response(200) self.send_header(&apos;Content-type&apos;, &apos;text/html&apos;) self.end_headers() self.wfile.write(b&apos;Only handle POST requests.\n&apos;) flushLog() def do_POST(self): statusCode = 403 responseData = b&quot;Reject the request&quot; if self.path == &quot;/pushed&quot;: statusCode, responseData = self.updateBlog() self.send_response(statusCode) self.send_header(&apos;Content-type&apos;, &apos;text/html&apos;) self.end_headers() self.wfile.write(bytes(responseData, &quot;utf-8&quot;)) flushLog() def updateBlog(self): os.chdir(&quot;/opt/hexo-blog&quot;) code, result = subprocess.getstatusoutput(&quot;git pull origin master&quot;) if code == 0: code = 200 result = &quot;blog updated :)&quot; else: code = 500 print(result) result = &quot;blog update failed :(&quot; return code, resultdef flushLog(): sys.stdout.flush() sys.stderr.flush()def main(): port = 2345 httpd = HTTPServer((&quot;&quot;, port), MyBaseHTTPRequestHandler) print(&quot;Running on port: %d&quot;%(port)) flushLog() httpd.serve_forever()if __name__ == &quot;__main__&quot;: main() 脚本的内容就是启动了一个监听 2345 端口的 http 服务，只接受 /pushed 资源路径的 POST 访问，其他资源路径的 POST 访问全都返回 403，每次接收到正确的 POST 访问后就去 /opt/hexo-blog 路径下更新仓库，也就是从 github 远程仓库下拉取更新，如果更新成功返回 200 状态码，否则返回 500，如果更新失败则打印下命令的输出，以便以后根据日志文件定位问题。 接下来给这个脚本增加可执行权限： 1chmod a+x /opt/webhooks.py 启动脚本同时把脚本的输出追加到 /var/log/blog-github-webhooks.log 文件中： 1nohup /opt/webhooks.py &gt;&gt; /var/log/blog-github-webhooks.log 2&gt;&amp;1 &amp; 然后配置下这个脚本开机自启动，如果是 systemd 的系统就写一个 service 文件，将上述命令稍微修改下写入 service 文件中的 EXEC 字段后面，具体的 service 文件怎么写和怎么用可以在网上搜索下： 1/opt/webhooks.py &gt;&gt; /var/log/blog-github-webhooks.log 2&gt;&amp;1 如果不是 systemd 的系统就把上面的命令复制到 /etc/rc.local 文件中的最后一行，不过 systemd 好像也兼容 /etc/rc.local 文件，直接用第二种方法配置开机自启估计也行。 设置 github webhooks去 github 网站博客对应的项目页面下，点击 Settings 按钮，再点击新页面左侧导航栏的 Webhooks 按钮： 再点击上图右上角的 Add Webhook 按钮： 在上图 Payload URL 的输入框中填入自己的服务器 ip 或者域名并加上端口 2345 和资源路径 /pushed，例如： 1http://listenerri.com:2345/pushed 然后直接点击下面绿色的 Add webhook 按钮就行了。 github 会发送一个测试的 POST 请求到设置的地址中，点击刚刚添加的 webhook 可以进入这个 webhook 的设置界面，这个界面最下面会后这个 webhook 的最近活动，如果没有意外会有如下图中的带有绿色对勾的一条记录： 当然可以写一遍新博客测试下。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nginx</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指定 git 使用的 ssh 秘钥]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%8C%87%E5%AE%9A-git-%E4%BD%BF%E7%94%A8%E7%9A%84-ssh-%E7%A7%98%E9%92%A5%2F</url>
    <content type="text"><![CDATA[目前我遇到的两种需要指定 git 使用的 ssh 秘钥的场景是： git 服务地址不同（一个公司，一个 github） 同一个git 服务地址但账户不同 下面分开介绍。 服务地址不同这估计是大多数人遇到的场景，同一个笔记本电脑，有时需要向公司的 git 服务推送代码，有时要向 github 推送代码，当然也可选择在两个不同的服务器上部署自己相同的公钥，但当无法做到这一情况时就要给 git 或者说给 ssh 命令指定哪个服务地址使用哪个秘钥。 首先生成两套秘钥即四个文件，两对公、私秘钥，具体的生成方法这里就不赘述了，不过要注意在生成第二套私钥时需要指定文件名称，否则将覆盖默认秘钥，一般秘钥文件存储在 ~/.ssh 目录下： 1234id_rsaid_rsa.pubid_rsa_companyid_rsa_company.pub 以 .pub 结尾的文件为公钥，需要将其部署在服务端，比如 id_rsa.pub 部署在 github 上，id_rsa_company.pub 部署在公司的服务上，id_rsa 则是 ssh 命令也是 git 命令使用的默认的私钥，当秘钥文件生成完成后使用以下命令将用于公司的私钥添加到 ssh-agent 中： 1ssh-add ~/.ssh/id_ras_company 添加完成后可以查看已经添加过的私钥： 1ssh-add -l 如果默认私钥没有被添加进来则手动按照上面的命令添加。 现在私钥已经在本地部署了，接着配置 ssh 让其针对不同的服务器使用不同的私钥进行认证，在 ~/.ssh目录下创建或编辑 config 文件，假设公司的 git 服务地址为 git.company.com： 123456789Host git.company.com User git IdentityFile ~/.ssh/id_ras_company IdentitiesOnly yesHost github.com User git IdentityFile ~/.ssh/id_ras IdentitiesOnly yes 内容很简单，分为两组第一组用于公司的 git 服务，第二组用于 github 的 git 服务。 账户不同网上搜到的大多数配置 git 使用的秘钥的文章都是在说上面的那种情况，现假设我在 github 上有两个账户，同一个公钥文件无法同时部署在两个账户上，这就要用这个方法了，不过需要注意的是这种方法只是针对项目或者说本地仓库配置的，还是类似与上一个情况，在 ~/.ssh 目录下生成两套秘钥： 1234id_rsaid_rsa.pubid_rsa_otherid_rsa_other.pub 同样要将这两套秘钥添加到 ssh-agent 中，具体方法参见上一场景的介绍。 第一套 id_rsa 和 id_rsa.pub 中的公钥假设已经在 github 主账户上使用了，现在我有了另一个账户 other，id_rsa_other 和 id_rsa_other.pub 给 other 账户使用，首先将公钥 id_rsa_other.pub 部署在 other 这个账户下。 主账户的配置自不必说，主账户的本地仓库不做任何配置，依旧使用默认的那套秘钥，要做的是在 other 账户的本地仓库中进行配置，例如 other 账户有一个本地仓库 other-repo,在仓库目录下编辑 other-repo/.git/config 文件，注意是仓库目录下： 12[core] sshCommand = ssh -i /home/ri/.ssh/id_rsa_other 即在 [core] 这一组配置中，添加一个配置项：sshCommand，其目的是指定 git 命令使用的 ssh 命令，ssh 命令可以使用 -i 参数指定要使用的私钥，这里使用加上了 -i 参数的 ssh 命令代替默认的 ssh 命令，配置到这里就结束了。 配置 git 本地账户网上关于指定 git 使用的秘钥的文章都会提到使用如下命令配置一下 git 本地账户的名字和邮件地址，其实这个不是必须的，这个只是在 git commit 历史中显示的账户，当然，在 github 上也会关联到相应的 github 账户，如果你想要两套秘钥的提交历史显示的是同一个账户所做的提交就不用单独配置本地 git 账户和邮件地址，使用默认的即可。 123456789# 在某个仓库目录下执行，只设置单个仓库中的本地账户# 配置文件在仓库目录下的 .git/configgit config user.name UserNamegit config user.email User@email.com# 在任意位置执行，加上 --global 参数即会设置默认本地账户# 配置文件在 HOME 目录下的 ~/.git/config 也可在 ~/.config/git/configgit config --global user.name UserNamegit config --global user.email User@email.com 如果需要在特定的仓库中使用不用于默认本地账户的账户，则使用上述命令中的第一组命令，在特定仓库目录下执行即可。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>key</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 quilt 给软件包打补丁]]></title>
    <url>%2F2019%2F03%2F16%2F%E4%BD%BF%E7%94%A8-quilt-%E7%BB%99%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%89%93%E8%A1%A5%E4%B8%81%2F</url>
    <content type="text"><![CDATA[quilt 是一个管理补丁的工具，它使用了栈的概念来管理多个补丁，其管理的补丁一般被放在 patches 目录下，在这个目录下除了补丁文件还有一个 series 文件，这个文件中列出的补丁文件才是真正被打入项目的补丁文件，同时补丁文件在 series 文件中出现的顺序也是它们在栈中的顺序，没有包含在 series 文件中的补丁文件将不会被 quilt 管理，当新增或移除补丁时 quilt 会自动更新 series 文件不需要手动管理。 接触到这个命令是因为要给一个 deb 软件包打上我自己的补丁，但是 quilt 命令的 man 手册比较混乱，没有将相关的子命令放在一起进行介绍，下面将根据子命令之间的相关性总结下用到的和与之相关的子命令。 applied-unapplied applied：列出包含在 series 文件中且已经应用（生效）了的补丁 unapplied：列出包含在 series 文件中但没有应用（生效）的补丁 diff指定一个被打过补丁的项目文件并根据其变动生成一个 diff 文件，如果指定了补丁则只把指定补丁对项目文件的改动生成到 diff 文件，当同一个项目文件被多个补丁改动过，这个参数就有用了，如果不指定补丁则默认使用最顶层的补丁，如果被打过补丁的项目文件也没有指定，则将包含指定补丁或最顶层的补丁导致的所有项目文件变动。 files列出最顶层的一个或指定的补丁改动了的所有项目文件 patches列出所有改动了指定的项目文件的补丁 pop-push pop：从栈中移除一个或多个已经生效了的补丁，不会修改 series 文件（使补丁不生效） push：根据 series 文件应用一个或多个补丁，不会修改 series 文件（使补丁生效） import-delete import：将指定的补丁文件导入到项目的补丁系统中，会修改 series 文件，同时将指定的补丁文件复制到 patches 目录下，但不会将这个补丁应用，因此还需要执行 push 命令来让这个补丁生效 delete：从 series 文件中移除指定或最后一行的补丁文件，会修改 series 文件，也可一起将补丁文件从 patches 目录中删除（默认不会删除），在移除前将取消这个补丁的应用，类似执行 pop 命令 add-remove add：将指定的项目文件添加到指定的或顶层的补丁中，一般是为了要使用下面的 edit 命令修改这个文件 remove：从指定的或最顶层的补丁中移除指定的项目文件，大概是当一个补丁修改了多个文件时，移除一个指定的文件不让这个补丁修改 fork-edit-refresh fork：使用指定的名字复制一个补丁，并使用复制后的补丁覆盖 series 文件中旧的补丁 edit：编辑指定的项目文件，这个项目文件应该先被使用 add 命令添加到当前补丁中 refresh：更新指定的或顶层的补丁 fork 通常用于一个补丁应用后又需要被修改，但这个补丁又需要保留这原始内容，这种情况下就可以先复制出来一个副本，然后修改这个副本]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>quilt</tag>
        <tag>patch</tag>
        <tag>deb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QThread 的两种用法]]></title>
    <url>%2F2019%2F03%2F16%2FQThread-%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[QThread 官方文档中介绍了的两种用法： worker-object subclass worker-object引用官方文档中的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142// worker 类// 声明了一个信号，一个槽class Worker : public QObject&#123; Q_OBJECTpublic slots: void doWork(const QString &amp;parameter) &#123; QString result; /* ... here is the expensive or blocking operation ... */ emit resultReady(result); &#125;signals: void resultReady(const QString &amp;result);&#125;;// 控制器类// 运行中主线程，用于管理 worker 对象和 QThread 对象// 也声明了一个信号，一个槽class Controller : public QObject&#123; Q_OBJECT QThread workerThread;public: Controller() &#123; Worker *worker = new Worker; worker-&gt;moveToThread(&amp;workerThread); connect(&amp;workerThread, &amp;QThread::finished, worker, &amp;QObject::deleteLater); connect(this, &amp;Controller::operate, worker, &amp;Worker::doWork); connect(worker, &amp;Worker::resultReady, this, &amp;Controller::handleResults); workerThread.start(); &#125; ~Controller() &#123; workerThread.quit(); workerThread.wait(); &#125;public slots: void handleResults(const QString &amp;);signals: void operate(const QString &amp;);&#125;; 在 worker 类中的槽函数是真正在子线程中工作的内容，而 worker 那个信号被发出时则表示工作完成，控制器中与之连接的槽函数的作用就是处理 worker 对象在完成工作之后使用其信号发出来的数据，控制器中的那个信号被发出时则是命令 worker 对象开始工作。因此需要使用下面的代码让 worker 对象在线程中开始工作： 12345// Note: 不要在主线程中以调用 worker-&gt;doWork() 函数的方式让 worker 开始工作// 否则将会导致主线程阻塞在这个调用上，只能使用信号-槽的方式：Controller *controller = new Controller;emit controller-&gt;operate("some string"); 看起来 worker 对象和 QThread 的对象并没有什么关系，那么 worker 对象是怎么在后台工作的呢？关键的一句代码是： 1worker-&gt;moveToThread(&amp;workerThread); 其中moveToThread方法是在 QObject 类中定义的，这意味着所有继承了 QObject 类的对象都可以调用这个方法来改变与自身关联的线程，使用下面的代码可以将 worker 对象再转移回主线程中： 1worker-&gt;moveToThread(QApplication::instance()-&gt;thread()); subclass引用官方文档中的代码： 12345678910111213141516171819202122// 继承 QThread 并重写其 run 方法class WorkerThread : public QThread&#123; Q_OBJECT void run() override &#123; QString result; /* ... here is the expensive or blocking operation ... */ emit resultReady(result); &#125;signals: void resultReady(const QString &amp;s);&#125;;// 启动子线程的方法// 一般位于主线程中void MyObject::startWorkInAThread()&#123; WorkerThread *workerThread = new WorkerThread(this); connect(workerThread, &amp;WorkerThread::resultReady, this, &amp;MyObject::handleResults); connect(workerThread, &amp;WorkerThread::finished, workerThread, &amp;QObject::deleteLater); workerThread-&gt;start();&#125; 可以看到 subclass 方式是很不同的异步/多线程实现方法，当启动 WorkerThread 这个线程对象时，run 方法将在子线程中调用并执行，直到完成后发出 resultReady 信号将结果交给主线程处理，这没有什么需要解释的细节。 总结这两种用法的区别还是很大的，总的来说 worker-object 方式更为灵活，应用到的场景也较为广泛，如果需要在线程运行过程中不断地与之交互、通讯，则应该使用这种方式；subclass 在实现起来简单，但限制比较大在线程运行期间无法调整其资源状态（或者说不安全）。另外对 QThread 还有一些事情需要牢记，下面是官方的一些描述： It is important to remember that a QThread instance lives in the old thread that instantiated it, not in the new thread that calls run(). This means that all of QThread’s queued slots will execute in the old thread. Thus, a developer who wishes to invoke slots in the new thread must use the worker-object approach; new slots should not be implemented directly into a subclassed QThread.\When subclassing QThread, keep in mind that the constructor executes in the old thread while run() executes in the new thread. If a member variable is accessed from both functions, then the variable is accessed from two different threads. Check that it is safe to do so. 大概意思是说，QThread 对象是始终位于初始化它的那个线程中的（一般是指主线程），这意味着 QThread 对象中的成员和方法是不能（最好不要）直接在主线程中访问的，这也是上面说道 subclass 方式限制比较大的原因。]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>QThread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dde-dock插件开发入门]]></title>
    <url>%2F2019%2F03%2F16%2Fdde-dock%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[最近公司需要补充一些项目的文档，我负责的几个项目中比较有实用价值的是这个 dde-dock 插件的开发入门教程，这里是转载，原发在 dde-dock 项目源码中。 插件的工作原理插件是一种在不需要改动并重新编译主程序本身的情况下去扩展主程序功能的一种机制。\dde-dock 插件是根据 Qt 插件标准所开发的共享库文件(so)，通过实现 Qt 的插件标准和 dde-dock 提供的接口，共同完成 dde-dock 的功能扩展。\可以通过以下链接查看关于 Qt 插件更详细的介绍： https://wiki.qt.io/Plugins\https://doc.qt.io/qt-5/plugins-howto.html dde-dock 插件加载流程在 dde-dock 启动时会跑一个线程去检测目录/usr/lib/dde-dock/plugins下的所有文件，并检测是否是一个正常的动态库文件，如果是则尝试加载。尝试加载即检测库文件的元数据，插件的元数据定义在一个 JSON 文件中，这个后文会介绍，如果元数据检测通过就开始检查插件是否实现了 dde-dock 指定的接口，这一步也通过之后就会开始初始化插件，获取插件提供的控件，进而将控件显示在任务栏上。 接口列表这里先列出 dde-dock 都提供了哪些接口，可作为一个手册查看，注意，为 dde-dock 编写插件并不是要实现所有接口，这些接口提供了 dde-dock 允许各种可能的功能，插件开发者可以根据自己的需求去实现自己需要的接口。后续的插件示例也将会用到这里列出的部分接口。 接口定义的文件一般在系统的如下位置：12/usr/include/dde-dock/pluginproxyinterface.h/usr/include/dde-dock/pluginsiteminterface.h PluginItemInterface只有标明必须实现的接口是必须要由插件开发者实现的接口，其他接口如果不需要对应功能可不实现。 PluginsItemInterface 中定义的接口除了displayMode 和 position（历史遗留），从插件的角度来看都是被动的，只能等待被任务栏的插件机制调用。 名称 简介 pluginName 返回插件名称，用于在 dde-dock 内部管理插件时使用 必须实现 pluginDisplayName 返回插件名称，用于在界面上显示 init 插件初始化入口函数，参数 proxyInter 可认为是主程序的进程 必须实现 itemWidget 返回插件主控件，用于显示在 dde-dock 面板上 必须实现 itemTipsWidget 返回鼠标悬浮在插件主控件上时显示的提示框控件 itemPopupApplet 返回鼠标左键点击插件主控件后弹出的控件 itemCommand 返回鼠标左键点击插件主控件后要执行的命令数据 itemContextMenu 返回鼠标右键点击插件主控件后要显示的菜单数据 invokedMenuItem 菜单项被点击后的回调函数 itemSortKey 返回插件主控件的排序位置 setSortKey 重新设置主控件新的排序位置（用户拖动了插件控件后） itemAllowContainer 返回插件控件是否允许被收纳 itemIsInContainer 返回插件是否处于收纳模式（仅在 itemAllowContainer 为 true 时有作用） setItemIsInContainer 更新插件是否处于收纳模式的状态（仅在 itemAllowContainer 主 true 时有作用） pluginIsAllowDisable 返回插件是否允许被禁用（默认不允许被禁用） pluginIsDisable 返回插件当前是否处于被禁用状态 pluginStateSwitched 当插件的禁用状态被用户改变时此接口被调用 displayModeChanged dde-dock 显示模式发生改变时此接口被调用 positionChanged dde-dock 位置变化时时此接口被调用 refreshIcon 当插件控件的图标需要更新时此接口被调用 displayMode 用于插件主动获取 dde-dock 当前的显示模式 position 用于插件主动获取 dde-dock 当前的位置 PluginProxyInterface由于上面的接口对于插件来说都是被动的，即插件本身无法确定这些接口什么时刻会被调用，很明显这对于插件机制来说是不完整的，因此便有了 PluginProxyInterface，它定义了一些让插件主动调用以控制 dde-dock 的一些行为的接口。PluginProxyInterface 的具体实例可以认为是抽象了的 dde-dock 主程序，或者是 dde-dock 中所有插件的管理员，这个实例将会通过 PluginItemInterface 中的 init 接口传递给插件，因此在上述 init 接口中总是会先把这个传入的对象保存起来以供后续使用。 名称 简介 itemAdded 向 dde-dock 添加新的主控件（一个插件可以添加多个主控件它们之间使用ItemKey区分） itemUpdate 通知 dde-dock 有主控件需要更新 itemRemoved 从 dde-dock 移除主控件 requestWindowAutoHide 设置 dde-dock 是否允许隐藏，通常被用在任务栏被设置为智能隐藏或始终隐藏而插件又需要让 dde-dock 保持显示状态来显示一些重要信息的场景下 requestRefreshWindowVisible 通知 dde-dock 更新隐藏状态 requestSetAppletVisible 通知 dde-dock 显示或隐藏插件的弹出面板（鼠标左键点击后弹出的控件） saveValue 统一的配置保存函数 getValue 统一的配置读取函数 构建一个 dde-dock 插件接下来将介绍一个简单的 dde-dock 插件的开发过程，插件开发者可跟随此步骤熟悉为 dde-dock 开发插件的步骤，以便创造出更多具有丰富功能的插件。 预期功能首先来确定下这个插件所需要的功能： 实时显示 HOME 分区可使用的剩余大小百分比 允许禁用插件 鼠标悬浮在插件上显示 HOME 分区总容量和可用容量 鼠标左键点击插件显示一个提示框显示关于 HOME 分区更详细的信息 鼠标右键点击插件显示一个菜单用于刷新缓存和启动 gparted 程序 安装依赖下面以 Qt + cmake 为例进行说明，以 Deepin 15.9 环境为基础，安装如下的包： dde-dock-dev cmake qtbase5-dev-tools pkg-config 项目基本结构创建必需的项目目录与文件，插件名称叫做home_monitor，所以创建以下的目录结构： 12345home_monitor├── home_monitor.json├── homemonitorplugin.cpp├── homemonitorplugin.h└── CMakeLists.txt 接着来依次分析各个文件的作用。 cmake 配置文件CMakeLists.txt 是 cmake 命令要读取的配置文件，用于管理整个项目的源文件，依赖，构建等等，其内容如下： 以#开头的行是注释，用于介绍相关命令，对创建一份新的 CMakeLists.txt 文件会有所帮助，目前可以简单地过一遍 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# 学习 cmake 时建议直接从命令列表作为入口，遇到不清楚意思的命令都可以在此处查阅：# https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html# 另外下面时完整的文档入口：# https://cmake.org/cmake/help/latest/# 设置运行被配置所需的 cmake 最低版本cmake_minimum_required(VERSION 3.11)# 使用 set 命令设置一个变量set(PLUGIN_NAME "home_monitor")# 设置项目名称project($&#123;PLUGIN_NAME&#125;)# 启用 qt moc 的支持set(CMAKE_AUTOMOC ON)# 启用 qrc 资源文件的支持set(CMAKE_AUTORCC ON)# 指定所有源码文件# 使用了 cmake 的 file 命令，递归查找项目目录下所有头文件和源码文件，# 并将结果放入 SRCS 变量中，SRCS 变量可用于后续使用file(GLOB_RECURSE SRCS "*.h" "*.cpp")# 指定要用到的库# 使用了 cmake 的 find_package 命令，查找库 Qt5Widgets 等，# REQUIRED 参数表示如果没有找到则报错# find_package 命令在找到并加载指定的库之后会设置一些变量，# 常用的有：# &lt;库名&gt;_FOUND 是否找到（Qt5Widgets_FOUND）# &lt;库名&gt;_DIR 在哪个目录下找到的（Qt5Widgets_DIR）# &lt;库名&gt;_INCLUDE_DIRS 有哪些头文件目录（Qt5Widgets_INCLUDE_DIRS）# &lt;库名&gt;_LIBRARIES 有哪些库文件（Qt5Widgets_LIBRARIES）find_package(Qt5Widgets REQUIRED)find_package(DtkWidget REQUIRED)# find_package 命令还可以用来加载 cmake 的功能模块# 并不是所有的库都直接支持 cmake 查找的，但大部分都支持了 pkg-config 这个标准，# 因此 cmake 提供了间接加载库的模块：FindPkgConfig， 下面这行命令表示加载 FindPkgConfig 模块，# 这个 cmake 模块提供了额外的基于 “pkg-config” 加载库的能力# 执行下面的命令后后会设置如下变量，不过一般用不到：# PKG_CONFIG_FOUND pkg-config 可执行文件是否找到了# PKG_CONFIG_EXECUTABLE pkg-config 可执行文件的路径# PKG_CONFIG_VERSION_STRING pkg-config 的版本信息find_package(PkgConfig REQUIRED)# 加载 FindPkgConfig 模块后就可以使用 pkg_check_modules 命令加载需要的库# pkg_check_modules 命令是由 FindPkgConfig 模块提供的，因此要使用这个命令必须先加载 FindPkgConfig 模块。# 执行 pkg_check_modules 命令加载库也会设置一些类似执行 find_package 加载库后设置的变量：# DdeDockInterface_FOUND# DdeDockInterface_INCLUDE_DIRS# DdeDockInterface_LIBRARIES# 还有有另外的一些变量以及更灵活的用法，比如一次性查找多个库，这些请自行查找 cmake 文档学习。pkg_check_modules(DdeDockInterface REQUIRED dde-dock)# add_definitions 命令用于声明/定义一些编译/预处理参数# 根据 cmake 文档描述此命令已经有另外几个功能划分的更为细致的命令所取代，具体请查阅文档# 在我们这里的例子应该使用较新的 add_compile_definitions 命令，不过为了保持与 dock 已有插件一致，# 暂时仍然使用 add_definitions，add_definitions 的语法很简单就是直接写要定义的 flag 并在前面加上 "-D" 即可# 括号中的 $&#123;QT_DEFINITIONS&#125; 变量会在执行 cmake 时展开为它的值，这个变量属于历史遗留，应该是在 qt3/qt4 时有用，# 基于 qt5 或更高版本的新插件不必使用此变量。要查看 qt5 的库定义了哪些变量应该查看变量：$&#123;Qt5Widgets_DEFINITIONS&#125;add_definitions("$&#123;QT_DEFINITIONS&#125; -DQT_PLUGIN")# 新增一个编译目标# 这里使用命令 add_library 来表示本项目要生成一个库文件目标，# 类似的还有命令 add_executable 添加一个可执行二进制目标，甚至 add_custom_target(使用较少) 添加自定义目标# SHARED 表示生成的库应该是动态库，# 变量 $&#123;PLUGIN_NAME&#125; 和 $&#123;SRCS&#125; 都是前面处理好的，# 另外 qrc 资源文件也应该追加在后面以编译进目标中。add_library($&#123;PLUGIN_NAME&#125; SHARED $&#123;SRCS&#125; home_monitor.qrc)# 设置目标的生成位置，这里表示生成在执行 make 的目录,# 另外还有很多可用于设置的属性，可查阅 cmake 文档。set_target_properties($&#123;PLUGIN_NAME&#125; PROPERTIES LIBRARY_OUTPUT_DIRECTORY ./)# 设置目标要使用的 include 目录，即头文件目录# 变量 $&#123;DtkWidget_INCLUDE_DIRS&#125; 是在前面执行 find_package 命令时引入的# 当出现编译失败提示找不到某些库的头文件时应该检查此处是否将所有需要的头文件都包含了target_include_directories($&#123;PLUGIN_NAME&#125; PUBLIC $&#123;Qt5Widgets_INCLUDE_DIRS&#125; $&#123;DtkWidget_INCLUDE_DIRS&#125; $&#123;DdeDockInterface_INCLUDE_DIRS&#125;)# 设置目标要使用的链接库# 变量 $&#123;DtkWidget_LIBRARIES&#125; 和 $&#123;Qt5Widgets_LIBRARIES&#125; 是在前面执行 find_package 命令时引入的# 当出现运行时错误提示某些符号没有定义时应该检查此处是否将所有用的库都写在了这里target_link_libraries($&#123;PLUGIN_NAME&#125; PRIVATE $&#123;Qt5Widgets_LIBRARIES&#125; $&#123;DtkWidget_LIBRARIES&#125; $&#123;DdeDockInterface_LIBRARIES&#125;)# 设置安装路径的前缀(默认为"/usr/local")set(CMAKE_INSTALL_PREFIX "/usr")# 设置执行 make install 时哪个目标应该被 install 到哪个位置install(TARGETS $&#123;PLUGIN_NAME&#125; LIBRARY DESTINATION lib/dde-dock/plugins) 元数据文件home_monitor.json文件是插件的元数据文件，指明了当前插件所使用的 dde-dock 的接口版本，dde-dock 在加载此插件时，会检测自己的接口版本是否与插件的接口版本一致，当双方的接口版本不一致或者不兼容时，dde-dock 为了安全将阻止加载对应的插件。另外，元数据文件是在源代码中使用特定的宏加载到插件中的。 在 dde-dock 内建的插件代码中，可以找到当前具体的接口版本，目前最新的版本是 1.2 。 123&#123; "api": "1.2"&#125; 另外（可选的）还支持指定一个 dbus 服务，dock 在加载插件时会检查此插件所依赖的 dbus 服务，如果服务没有启动则不会初始化这个插件，直到服务启动，如下表示依赖 dbus 地址为 “com.deepin.daemon.Network” 的 dbus 服务。 1234&#123; "api": "1.2", "depends-daemon-dbus-service": "com.deepin.daemon.Network"&#125; 插件核心类homemonitorplugin.h 声明了类 HomeMonitorPlugin，它继承（实现）了前面提到的 PluginItemInterface，这代表了它是一个实现了 dde-dock 接口的插件。 下面是最小化实现了一个 dock 插件的源码，只实现了必须实现的接口，请注意，下文的代码只是为了简述开发一个插件的主要过程，详细的示例代码应该查看 home-monitor 目录下的内容。 1234567891011121314151617181920212223242526272829#ifndef HOMEMONITORPLUGIN_H#define HOMEMONITORPLUGIN_H#include &lt;dde-dock/pluginsiteminterface.h&gt;#include &lt;QObject&gt;class HomeMonitorPlugin : public QObject, PluginsItemInterface&#123; Q_OBJECT // 声明实现了的接口 Q_INTERFACES(PluginsItemInterface) // 插件元数据 Q_PLUGIN_METADATA(IID "com.deepin.dock.PluginsItemInterface" FILE "home_monitor.json")public: explicit HomeMonitorPlugin(QObject *parent = nullptr); // 返回插件的名称，必须是唯一值，不可以和其它插件冲突 const QString pluginName() const override; // 插件初始化函数 void init(PluginProxyInterface *proxyInter) override; // 返回插件的 widget QWidget *itemWidget(const QString &amp;itemKey) override;&#125;;#endif // HOMEMONITORPLUGIN_H homemonitorplugin.cpp 中包含对应接口的实现 1234567891011121314151617181920212223242526#include "homemonitorplugin.h"HomeMonitorPlugin::HomeMonitorPlugin(QObject *parent) : QObject(parent)&#123;&#125;const QString HomeMonitorPlugin::pluginName() const&#123; return QStringLiteral("home_monitor");&#125;void HomeMonitorPlugin::init(PluginProxyInterface *proxyInter)&#123; m_proxyInter = proxyInter;&#125;QWidget *HomeMonitorPlugin::itemWidget(const QString &amp;itemKey)&#123; Q_UNUSED(itemKey); // 这里暂时返回空指针，这意味着插件会被 dde-dock 加载 // 但是不会有任何东西被添加到 dde-dock 上 return nullptr;&#125; 测试插件加载当插件的基本结构搭建好之后应该测试下这个插件能否被 dde-dock 正确的加载，这时候测试如果有问题也可以及时处理。 从源码构建为了不污染源码目录，推荐在源码目录中创建 build 目录用于构建： 123456789cd home_monitormkdir buildcd buildcmake ..make -j4 安装执行下面的命令即可将插件安装到系统中，也是 CMakeList.txt 文件指定的安装位置： 1sudo make install 可以看到有home_monitor.so文件被安装在了 dde-dock 的插件目录。 1install -m 755 -p ./home_monitor/libhome_monitor.so /usr/lib/dde-dock/plugins/libhome_monitor.so 测试加载执行 pkill dde-dock; dde-dock 来重新运行 dde-dock，在终端输出中如果出现以下的输出，说明插件的加载已经正常： 123init plugin: "home_monitor"init plugin finished: "home_monitor" 创建插件主控件创建新文件 informationwidget.h 和 informationwidget.cpp，用于创建控件类：InformationWidget，这个控件用于显示在 dde-dock 上。 此时的目录结构为： 123456789home_monitor├── build/├── home_monitor.json├── homemonitorplugin.cpp├── homemonitorplugin.h├── informationwidget.cpp├── informationwidget.h└── CMakeLists.txt informationwidget.h 文件内容如下： 12345678910111213141516171819202122232425262728293031#ifndef INFORMATIONWIDGET_H#define INFORMATIONWIDGET_H#include &lt;QWidget&gt;#include &lt;QLabel&gt;#include &lt;QTimer&gt;#include &lt;QStorageInfo&gt;class InformationWidget : public QWidget&#123; Q_OBJECTpublic: explicit InformationWidget(QWidget *parent = nullptr); inline QStorageInfo * storageInfo() &#123; return m_storageInfo; &#125;private slots: // 用于更新数据的槽函数 void refreshInfo();private: // 真正的数据显示在这个 Label 上 QLabel *m_infoLabel; // 处理时间间隔的计时器 QTimer *m_refreshTimer; // 分区数据的来源 QStorageInfo *m_storageInfo;&#125;;#endif // INFORMATIONWIDGET_H informationwidget.cpp 文件包含了对类 InformationWidget 的实现，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include "informationwidget.h"#include &lt;QVBoxLayout&gt;#include &lt;QTimer&gt;#include &lt;QDebug&gt;InformationWidget::InformationWidget(QWidget *parent) : QWidget(parent) , m_infoLabel(new QLabel) , m_refreshTimer(new QTimer(this)) // 使用 "/home" 初始化 QStorageInfo // 如果 "/home" 没有挂载到一个单独的分区上，QStorageInfo 收集的数据将会是根分区的 , m_storageInfo(new QStorageInfo("/home"))&#123; m_infoLabel-&gt;setStyleSheet("QLabel &#123;" "color: white;" "&#125;"); m_infoLabel-&gt;setAlignment(Qt::AlignCenter); QVBoxLayout *centralLayout = new QVBoxLayout; centralLayout-&gt;addWidget(m_infoLabel); centralLayout-&gt;setSpacing(0); centralLayout-&gt;setMargin(0); setLayout(centralLayout); // 连接 Timer 超时的信号到更新数据的槽上 connect(m_refreshTimer, &amp;QTimer::timeout, this, &amp;InformationWidget::refreshInfo); // 设置 Timer 超时为 10s，即每 10s 更新一次控件上的数据，并启动这个定时器 m_refreshTimer-&gt;start(10000); refreshInfo();&#125;void InformationWidget::refreshInfo()&#123; // 获取分区总容量 const double total = m_storageInfo-&gt;bytesTotal(); // 获取可用总容量 const double available = m_storageInfo-&gt;bytesAvailable(); // 得到可用百分比 const int percent = qRound(available / total * 100); // 更新内容 m_infoLabel-&gt;setText(QString("Home:\n%1\%").arg(percent));&#125; 现在主控件类已经完成了，回到插件的核心类，将主控件类添加到核心类中。 在 homemonitorplugin.h 中相应位置添加成员声明： 1234567#include "informationwidget.h"class HomeMonitorPlugin : public QObject, PluginsItemInterface&#123;private: InformationWidget *m_pluginWidget;&#125;; 然后在 homemonitorplugin.cpp 中将添加成员的初始化，比如在 init 接口中初始化： 123456void HomeMonitorPlugin::init(PluginProxyInterface *proxyInter)&#123; m_proxyInter = proxyInter; m_pluginWidget = new InformationWidget;&#125; 添加主控件到 dde-dock 面板上在插件核心类的 init 方法中获取到了 PluginProxyInterface 对象，调用此对象的 itemAdded 接口即可实现向 dde-dock 面板上添加项目。 第二个 QString 类型的参数代表了本插件所提供的主控件的 id，当一个插件提供多个主控件时，不同主控件之间的 id 要保证唯一。 12345678void HomeMonitorPlugin::init(PluginProxyInterface *proxyInter)&#123; m_proxyInter = proxyInter; m_pluginWidget = new InformationWidget; m_proxyInter-&gt;itemAdded(this, pluginName());&#125; 在调用 itemAdded 之后，dde-dock 会在合适的时机调用插件的itemWidget接口以获取需要显示的控件。如果插件提供了多个主控件到 dde-dock 上，那么插件核心类应该在 itemWidget 接口中分析参数 itemKey，并返回与之对应的控件对象，当插件只有一个可显示项目时，itemKey 可以忽略 (但不建议忽略)。 123456QWidget *HomeMonitorPlugin::itemWidget(const QString &amp;itemKey)&#123; Q_UNUSED(itemKey); return m_pluginWidget;&#125; 现在再根据“测试插件加载”一节中的步骤，编译、安装、重启 dde-dock，就可以看到主控件在 dde-dock 面板上出现了，如下图所示： 支持禁用插件与插件禁用和启用相关的接口有如下三个： pluginIsAllowDisable pluginIsDisable pluginStateSwitched 故而在插件的核心类头文件中增加这三个接口的声明： 123bool pluginIsAllowDisable() override;bool pluginIsDisable() override;void pluginStateSwitched() override; 同时在插件的核心类实现类中增加这三个接口的定义： 123456789101112131415161718192021222324252627bool HomeMonitorPlugin::pluginIsAllowDisable()&#123; // 告诉 dde-dock 本插件允许禁用 return true;&#125;bool HomeMonitorPlugin::pluginIsDisable()&#123; // 第二个参数 “disabled” 表示存储这个值的键（所有配置都是以键值对的方式存储的） // 第三个参数表示默认值，即默认不禁用 return m_proxyInter-&gt;getValue(this, "disabled", false).toBool();&#125;void HomeMonitorPlugin::pluginStateSwitched()&#123; // 获取当前禁用状态的反值作为新的状态值 const bool disabledNew = !pluginIsDisable(); // 存储新的状态值 m_proxyInter-&gt;saveValue(this, "disabled", disabledNew); // 根据新的禁用状态值处理主控件的加载和卸载 if (disabledNew) &#123; m_proxyInter-&gt;itemRemoved(this, pluginName()); &#125; else &#123; m_proxyInter-&gt;itemAdded(this, pluginName()); &#125;&#125; 此时就会引入一个新的问题，插件允许被禁用，那么在 dde-dock 启动时，插件有可能处于禁用状态，那么在初始化插件时就不能直接将主控件添加到 dde-dock 中，而是应该判断当前是否是禁用状态，修改接口 init 的实现： 1234567891011void HomeMonitorPlugin::init(PluginProxyInterface *proxyInter)&#123; m_proxyInter = proxyInter; m_pluginWidget = new InformationWidget; // 如果插件没有被禁用则在初始化插件时才添加主控件到面板上 if (!pluginIsDisable()) &#123; m_proxyInter-&gt;itemAdded(this, pluginName()); &#125;&#125; 重新编译、安装、重启 dde-dock，然后 dde-dock 面板上点击鼠标右键查看“插件”子菜单就会看到空白项，点击它将禁用插件，再次点击则启用插件。 不过为什么是空白项呢？是因为有一个接口还没有实现：pluginDisplayName 在相应文件中分别添加如下内容，来修复这个问题： 123// homemonitorplugin.hconst QString pluginDisplayName() const override; 123456// homemonitorplugin.cppconst QString HomeMonitorPlugin::pluginDisplayName() const&#123; return QString("Home Monitor");&#125; 支持 hover tip“hover tip” 就是鼠标移动到插件主控件上并悬浮一小段时间后弹出的一个提示框，可以用于显示一些状态信息等待，当然具体用来显示什么完全由插件开发者自己决定，要实现这个功能需要接口： itemTipsWidget 首先在插件核心类中添加一个文本控件作为 tip 控件： 1234// homemonitorplugin.hprivate: InformationWidget *m_pluginWidget; QLabel *m_tipsWidget; // new 在 init 函数中初始化： 1234567891011121314// homemonitorplugin.cppvoid HomeMonitorPlugin::init(PluginProxyInterface *proxyInter)&#123; m_proxyInter = proxyInter; m_pluginWidget = new InformationWidget; m_tipsWidget = new QLabel; // new // 如果插件没有被禁用则在初始化插件时才添加主控件到面板上 if (!pluginIsDisable()) &#123; m_proxyInter-&gt;itemAdded(this, pluginName()); &#125;&#125; 下面在插件核心类中实现接口 itemTipsWidget： 123// homemonitorplugin.hpublic: QWidget *itemTipsWidget(const QString &amp;itemKey) override; 12345678910111213// homemonitorplugin.cppQWidget *HomeMonitorPlugin::itemTipsWidget(const QString &amp;itemKey)&#123; Q_UNUSED(itemKey); // 设置/刷新 tips 中的信息 m_tipsWidget-&gt;setText(QString("Total: %1G\nAvailable: %2G") .arg(qRound(m_pluginWidget-&gt;storageInfo()-&gt;bytesTotal() / qPow(1024, 3))) .arg(qRound(m_pluginWidget-&gt;storageInfo()-&gt;bytesAvailable() / qPow(1024, 3)))); return m_tipsWidget;&#125; dde-dock 在发现鼠标悬停在插件的控件上时就会调用这个接口拿到相应的控件并显示出来。 支持 applet上面的 tips 显示的控件在鼠标移开之后就会消失，如果插件需要长时间显示一个窗体及时鼠标离开也会保持显示状态来做一些提示或功能的话那就需要使用 applet，applet 控件在左键点击后显示，点击控件以外的其他地方后消失。 applet 控件其实跟 tip 控件一样都是一个普通的 widget，但是可以在 applet 控件中显示交互性的内容，比如按钮，输入框等等。出于篇幅的原因这里 applet 控件就添加交互性的特性了，只用来显示一些文字，所以依然使用一个 lable 控件。 在插件核心类中添加一个文本控件作为 applet 控件： 12345// homemonitorplugin.hprivate: InformationWidget *m_pluginWidget; QLabel *m_tipsWidget; QLabel *m_appletWidget; // new 在 init 函数中初始化： 123456789101112131415// homemonitorplugin.cppvoid HomeMonitorPlugin::init(PluginProxyInterface *proxyInter)&#123; m_proxyInter = proxyInter; m_pluginWidget = new InformationWidget; m_tipsWidget = new QLabel; m_appletWidget = new QLabel; // new // 如果插件没有被禁用则在初始化插件时才添加主控件到面板上 if (!pluginIsDisable()) &#123; m_proxyInter-&gt;itemAdded(this, pluginName()); &#125;&#125; 接着实现 applet 相关的接口 itemPopupApplet： 123// homemonitorplugin.hpublic: QWidget *itemPopupApplet(const QString &amp;itemKey) override; 1234567891011121314151617// homemonitorplugin.cppQWidget *HomeMonitorPlugin::itemPopupApplet(const QString &amp;itemKey)&#123; Q_UNUSED(itemKey); m_appletWidget-&gt;setText(QString("Total: %1G\nAvailable: %2G\nDevice: %3\nVolume: %4\nLabel: %5\nFormat: %6\nAccess: %7") .arg(qRound(m_pluginWidget-&gt;storageInfo()-&gt;bytesTotal() / qPow(1024, 3))) .arg(qRound(m_pluginWidget-&gt;storageInfo()-&gt;bytesAvailable() / qPow(1024, 3))) .arg(QString(m_pluginWidget-&gt;storageInfo()-&gt;device())) .arg(m_pluginWidget-&gt;storageInfo()-&gt;displayName()) .arg(m_pluginWidget-&gt;storageInfo()-&gt;name()) .arg(QString(m_pluginWidget-&gt;storageInfo()-&gt;fileSystemType())) .arg(m_pluginWidget-&gt;storageInfo()-&gt;isReadOnly() ? "ReadOnly" : "ReadWrite") ); return m_appletWidget;&#125; 编译，安装，重启 dde-dock 之后点击主控件即可看到弹出的 applet 控件。 支持右键菜单增减右键菜单功能需要实现以下两个接口： itemContextMenu invokedMenuItem 1234// homemonitorplugin.hpublic: const QString itemContextMenu(const QString &amp;itemKey) override; void invokedMenuItem(const QString &amp;itemKey, const QString &amp;menuId, const bool checked) override; 12345678910111213141516171819202122232425262728293031323334353637383940// homemonitorplugin.cppconst QString HomeMonitorPlugin::itemContextMenu(const QString &amp;itemKey)&#123; Q_UNUSED(itemKey); QList&lt;QVariant&gt; items; items.reserve(2); QMap&lt;QString, QVariant&gt; refresh; refresh["itemId"] = "refresh"; refresh["itemText"] = "Refresh"; refresh["isActive"] = true; items.push_back(refresh); QMap&lt;QString, QVariant&gt; open; open["itemId"] = "open"; open["itemText"] = "Open Gparted"; open["isActive"] = true; items.push_back(open); QMap&lt;QString, QVariant&gt; menu; menu["items"] = items; menu["checkableMenu"] = false; menu["singleCheck"] = false; // 返回 JSON 格式的菜单数据 return QJsonDocument::fromVariant(menu).toJson();&#125;void HomeMonitorPlugin::invokedMenuItem(const QString &amp;itemKey, const QString &amp;menuId, const bool checked)&#123; Q_UNUSED(itemKey); // 根据上面接口设置的 id 执行不同的操作 if (menuId == "refresh") &#123; m_pluginWidget-&gt;storageInfo()-&gt;refresh(); &#125; else if ("open") &#123; QProcess::startDetached("gparted"); &#125;&#125; 编译，安装，重启 dde-dock 之后右键点击主控件即可看到弹出右键菜单。 至此，一个包含基本功能的插件就完成了。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>dde-dock</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码构建qtcreator记录]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAqtcreator%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[在 deepin linux 系统下编译 qtcreator 4.8.0 版本，可是按照官方 README 却始终编译不通过，遇到了以下几个问题，并列出了相关解决方案。当然官方的 README 上所说的编译依赖还是要装上的。 问题0 这个可能不是必须的 不要在源码目录下建立 build/build-debug/build-release 之类的构建目录, 否则会出现一些奇奇怪怪的问题, 导致编译失败 只需要直接在源码根目录下执行:1234# 仅供参考qmakemakemake install 问题11234g++ -Wl,-z,origin &apos;-Wl,-rpath,$ORIGIN:$ORIGIN/..:$ORIGIN/../lib/qtcreator&apos; -Wl,--no-undefined -Wl,-z,origin -Wl,-rpath,/usr/lib/llvm-7/lib -Wl,--exclude-libs,ALL -Wl,-O1 -shared -Wl,-soname,libClangFormat.so -o libClangFormat.so .obj/release-shared/clangformatconfigwidget.o .obj/release-shared/clangformatindenter.o .obj/release-shared/clangformatplugin.o .obj/release-shared/clangformatutils.o .obj/release-shared/moc_clangformatconfigwidget.o .obj/release-shared/moc_clangformatplugin.o -L/home/ri/coding/qt-creator/lib/qtcreator -L/home/ri/coding/qt-creator/lib/qtcreator/plugins -lCppTools -lProjectExplorer -lTextEditor -lCore -lCPlusPlus -lQtcSsh -lAggregation -lExtensionSystem -lUtils -L/usr/lib/llvm-7/lib -lclangFormat -lclangToolingInclusions -lclangToolingCore -lclangRewrite -lclangLex -lclangBasic -lLLVM-7 -lQt5Widgets -lQt5Gui -lQt5Concurrent -lQt5Network -lQt5Core -lGL -lpthread /usr/bin/ld: 找不到 -lclangToolingInclusionscollect2: error: ld returned 1 exit statusmake[3]: *** [Makefile:286：../../../lib/qtcreator/plugins/libClangFormat.so] 错误 1 报错里提到找不到 clangToolingInclusions 这个库文件, 根据 -L/usr/lib/llvm-7/lib 可知构建系统要在这个目录下找, 尝试了以下三个方法: 手动进入此目录搜索的确没有找到 故而又在 /usr/lib 目录搜索依然没有 接着使用 apt-file search clangToolingInclusions 命令搜索看是不是因为某个包没装, 结果依然没有 这就奇怪了, 难道是 debian 系的系统中没有这个库文件吗? 被改名了? ag clangToolingInclusions src/shared/clang/clang_installation.pri 文件中: 123456789!isEmpty(LLVM_VERSION) &#123; versionIsAtLeast($$LLVM_VERSION, 7, 0, 0): &#123; CLANGFORMAT_LIBS=-lclangFormat -lclangToolingInclusions -lclangToolingCore -lclangRewrite -lclangLex -lclangBasic win32:CLANGFORMAT_LIBS += -lversion &#125; else:versionIsAtLeast($$LLVM_VERSION, 6, 0, 0): &#123; CLANGFORMAT_LIBS=-lclangFormat -lclangToolingCore -lclangRewrite -lclangLex -lclangBasic win32:CLANGFORMAT_LIBS += -lversion &#125;&#125; 移除7.0 clang llvm 创建6.0链接 Reading /home/ri/coding/qt-creator/src/plugins/clangformat/clangformat.prosh: 1: llvm-config: not foundProject WARNING: Cannot determine clang version. Set LLVM_INSTALL_DIR to build the Clang Code ModelProject file(clangformat.pro) not recursed because all requirements not met: !isEmpty(CLANGFORMAT_LIBS) 搞完才发现: Get LLVM/Clang for the Clang Code ModelThe Clang Code Model depends on the LLVM/Clang libraries. The currently supported LLVM/Clang version is 6.0. 问题212345In file included from source/collectbuilddependencyaction.h:28:0, from source/collectbuilddependencytoolaction.h:28, from source/builddependencycollector.cpp:28:source/collectbuilddependencypreprocessorcallbacks.h:88:10: error: ‘void ClangBackEnd::CollectBuildDependencyPreprocessorCallbacks::InclusionDirective(clang::SourceLocation, const clang::Token&amp;, llvm::StringRef, bool, clang::CharSourceRange, const clang::FileEntry*, llvm::StringRef, llvm::StringRef, const clang::Module*, clang::SrcMgr::CharacteristicKind)’ marked ‘override’, but does not override void InclusionDirective(clang::SourceLocation hashLocation, 目录: qt-creator/src/tools/clangpchmanagerbackend 12345678910void InclusionDirective(clang::SourceLocation hashLocation, const clang::Token &amp; /*includeToken*/, llvm::StringRef /*fileName*/, bool /*isAngled*/, clang::CharSourceRange /*fileNameRange*/, const clang::FileEntry *file, llvm::StringRef /*searchPath*/, llvm::StringRef /*relativePath*/, const clang::Module * /*imported*/, clang::SrcMgr::CharacteristicKind fileType) override 移除 override]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>qtcreator</tag>
        <tag>build</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QPropertyAnimation不生效]]></title>
    <url>%2F2019%2F02%2F02%2FQPropertyAnimation%E4%B8%8D%E7%94%9F%E6%95%88%2F</url>
    <content type="text"><![CDATA[在 Qt 中实现动画的一种方便的做法就是使用 QPropertyAnimation 类, 构造 QPropertyAnimation 时设置目标 widget 和 property, 然后设置一下初始和结束的 property 值剩下的 Qt 就会帮我们做了. 常用的一个动画属性就是 “geometry”, 这个属性包含了 widget 的位置以及形状(矩形), 所以通过设置这个属性可以实现 widget 的位置和大小动画. 只是使用这个属性实现大小动画时要留意, widget 不能被设置固定的大小, 即下面这类函数不能调用, 否则 QPropertyAnimation 将无法调整目标 widget 的大小, 其中缘由细细想一下便可知道: setFixedSize setFixedWidth setFixedHeight 但如果目的 widget 不得不设置一个初始大小的话可以调用如下这些函数: setMinimumSize setMaxmumSize setGeometry]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>QPropertyAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qt中的QPointer QSharedPointer等智能指针]]></title>
    <url>%2F2018%2F11%2F24%2Fqt%E4%B8%AD%E7%9A%84QPointer-QSharedPointer%E7%AD%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[QPointerQPointer在用法上跟普通的指针没有什么区别, 可以将它当做是一个普通指针一样使用. 例如: 123456789void barFunc(QLabel *label) &#123; ...&#125;QPointer&lt;QLabel&gt; pointer;pointer = new QLabel;// 直接将pointer作为QLabel类型的指针传入barFunc函数作为参数barFunc(pointer); 主要作用: QPointer的主要功能是避免悬空指针的出现, 悬空指针是指: 指针不为空, 但是其指向的对象已经不在了. 也就是说当对象在其他地方被delete了, 而我们所持有的指向这个对象的指针依然指向那块内存地址, 而没有被置为空, 此时如果使用这个指针就会出错. 下面的QSharedPointer也有避免悬空指针的功能. 使用场景: 在多个不同地方的指针指向同一个对象, 当一个地方delete了这个对象后, 其他地方依然会使用指向这个对象的指针, 此时如果没有使用QPointer封装, if (pointer)返回的是true, 而如果使用QPointer封装, QPointer检测到对象被销毁那么if (pointer)返回的是false. 场景举例: 我需要将我的一个对象以指针的形式暴露出去, 而且我会在某些情况下delete这个对象, 那我暴露出去的指针就应该使用QPointer封装一下. (上面情况的另一个视角)我接收了一个指针, 但指针指向的对象会在别的地方被销毁, 那我接收这个指针时就应该使用QPointer封装一下. QSharedPointerQSharedPointer提供了对引用计数的共享指针实现.引用计数即: 每当创建一个QSharedPointer副本时, 其引用计数加1, 每当一个QSharedPointer副本被销毁时, 其引用计数减1, 当引用计数为0时, 则销毁其封装或指向的对象. 主要作用:使用QSharedPointer时不需要再时刻牢记delete对象以避免内存泄漏, 因为当QSharedPointer超出其作用域被销毁时, 如果没有其他QSharedPointer引用这个对象时, 即当引用计数为0时, 就会销毁其封装或指向的对象. 使用场景: 如果不想手动删除new出来的对象就可以使用QSharedPointer封装它 一个对象有很多地方在使用, 而且有可能不小心删除(不应该被删除) QWeakPointer主要用途跟QPointer差不多, 但却不如QPointer好用, 因为要创建它只能通过一个已有的QSharedPointer对象来创建, 而且也不能将它看做其追踪的指针对象直接进行操作, 还要先将其转到QSharedPointer才行, 但是既然有这类, 就应该有其道理, 只是我还没碰到使用它的场景. 总之, 目前感觉这个类没用. QScopedPointer从名字可以看出来, 这是一个跟作用域有关的智能指针, 一般只将其声明为栈对象但封装一个堆对象, 它只做一件事, 就是当QScopedPointer对象(栈对象)超出其作用域要被销毁时, 在它的析构函数里删除追踪的对象(堆对象). 注意这里并不会检查这个对象是否应该删除, 或者是否有其他指针依然引用/指向这个对象, 而是直接删除它. 这也是QScopedPointer和QSharedPointer在自动销毁对象这一作用上的区别. QSharedDataPointerQSharedDataPointer主要用来结合QSharedData实现隐式共享数据类, 隐式共享即写时拷贝机制, 当修改一个对象时才将其数据拷贝一份到自己名下, 否则大家公用一份数据, 读取一份数据, 从智能指针的角度来看这个类并不主要为指针服务, 因此如果不是为了实现自己的隐式共享不需要深入了解这个类. 其具体作用和详细用法可以在qt的文档中查看. QExplicitlySharedDataPointerQExplicitlySharedDataPointer用来实现显示共享数据类, 显示共享与隐式共享是相反的, 隐式共享会自动调用QSharedDataPointer的detach()方法实现写时拷贝, 而显示共享则需要手动明确调用detach()方法来进行数据的拷贝, 如果没有明确调用detach()方法则会直接修改共享的数据, 如果一直没有明确调用detach()方法则这个类的行为与QSharedPointer一样.]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>智能指针</tag>
        <tag>QPointer</tag>
        <tag>QSharedPointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qt中翻译静态成员变量中的字符串]]></title>
    <url>%2F2018%2F11%2F04%2Fqt%E4%B8%AD%E7%BF%BB%E8%AF%91%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[在 qt 中要翻译一个字符串很简单，只需要使用 tr 函数包裹住字符串即可。后来发现这一方法对于静态变量无效，经同事提醒原来静态数据初始化时，程序还没有加载翻译数据，也就是一般写在 main 函数中的 QTranslator::load() / app.installTranslator() 类似代码。 经过一番搜索和阅读 qt 文档，找到了解决方法，原来 qt 早已有应对之策：QT_TR_NOOP 这个宏，或者说这类宏，因为类似的还有 QT_TR_NOOP_UTF8 QT_TRANSLATE_NOOP，这里只是简要说一下其大概用法，想要了解更多可以查阅 qt 相关文档。下面只介绍 QT_TR_NOOP 这个宏的用法： 这个宏跟 tr 函数的原理不同，tr 函数中的字符串会在程序加载时被替换为翻译后的文本，可以理解为这是一种类似宏展开的过程，因此这是一种静态的翻译，而 QT_TR_NOOP 这个宏则是动态翻译，传给这个宏的字符串将会被标记为需要动态翻译的内容，何为动态翻译，也就是说在程序加载时不会被修改/替换字符串( tr() 函数的过程)，而是在真正使用时再进行翻译，拿 qt 文档中的例子来看： 12345678QString FriendlyConversation::greeting(int type)&#123;static const char *greeting_strings[] = &#123; QT_TR_NOOP("Hello"), QT_TR_NOOP("Goodbye")&#125;;return tr(greeting_strings[type]);&#125; 上述代码中数组 greeting_strings 的成员是两个被标记为需要动态翻译的字符串，下面 return 就是真正要使用的地方，同样是用到了 tr 函数，将数据的成员传入即可。 如果静态字符串数据是一个 QMap 或者 QList 那使用时就要将成员转化为 c 风格的字符串或byte数组，还是上面的代码，稍加修改为 QList 类型的： 123456789QString FriendlyConversation::greeting(int type)&#123;static const QList *greeting_string_list = &#123; QT_TR_NOOP("Hello"), QT_TR_NOOP("Goodbye")&#125;;return tr(greeting_string_list[type].toUtf8());// 或者：greeting_string_list[type].toLocal8Bit() 之类的&#125;]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>static</tag>
        <tag>qt</tag>
        <tag>tr</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qtcreator-fakevim-小企鹅输入法自动切换到英文]]></title>
    <url>%2F2018%2F11%2F04%2Fqtcreator-fakevim-%E5%B0%8F%E4%BC%81%E9%B9%85%E8%BE%93%E5%85%A5%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E5%88%B0%E8%8B%B1%E6%96%87%2F</url>
    <content type="text"><![CDATA[qtcreator 的 fakevim 不支持原生 vim 的插件，所以就用不了 fcitx.vim 这个好用的插件了，所以只能自食其力喽。根据 fcitx 支持 dbus 通信的原理，实现了在 INSERT 模式下按 ESC 键回到 NORMAL 模式时自动切换到英文状态。由于 fakevim 支持的特性过于简陋，目前只实现了这个，并不能像 fcitx.vim 插件一样记住 INSERT 模式下的中英文状态，等下次进入 INSERT 模式时再自动切回去，不过这样也舒服了很多了，将下面的配置放到 qtcreator fakevim 插件的配置文件中即可： 12&quot; 从insert模式按esc回到normal模式时自动关闭小企鹅输入法inoremap &lt;ESC&gt; &lt;ESC&gt;:!dbus-send --type=method_call --dest=org.fcitx.Fcitx /inputmethod org.fcitx.Fcitx.InputMethod.InactivateIM&lt;CR&gt; 在 qtcreator 的设置里有 fakevim 设置项，里面有一项是设置 fakevim 启动时要加载的配置文件的路径。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>qtcreator</tag>
        <tag>fakevim</tag>
        <tag>vim</tag>
        <tag>fcitx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb调试qt程序时打印qt特有的类型数据]]></title>
    <url>%2F2018%2F10%2F23%2Fgdb%E8%B0%83%E8%AF%95qt%E7%A8%8B%E5%BA%8F%E6%97%B6%E6%89%93%E5%8D%B0qt%E7%89%B9%E6%9C%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[如果没有使用 qtcreator 调试 qt 程序，而是手动或利用其他 IDE 使用 gdb 调试，会发现 qt 类型的数据如 QString QList QMap 等不能直接查看其值。其实 gdb 是提供了关于打印数据的接口的，叫做 Pretty-Printer，这是一种利用 python 代码更好的输出变量数据的机制，感兴趣的可以搜索下相关内容。qtcreator 之所以可以愉快的打印出 qt 相应的数据也是因为它使用了这种机制，下面的命令可以查看 qtcreator 的安装目录中的 python 文件，命令在 debian 系的 linux 系统上有效: 1234567891011121314151617181920# apt-file show qtcreator-data | grep pyqtcreator-data: /usr/share/doc/qtcreator-data/copyrightqtcreator-data: /usr/share/qtcreator/debugger/boosttypes.pyqtcreator-data: /usr/share/qtcreator/debugger/cdbbridge.pyqtcreator-data: /usr/share/qtcreator/debugger/creatortypes.pyqtcreator-data: /usr/share/qtcreator/debugger/dumper.pyqtcreator-data: /usr/share/qtcreator/debugger/gdbbridge.pyqtcreator-data: /usr/share/qtcreator/debugger/lldbbridge.pyqtcreator-data: /usr/share/qtcreator/debugger/misctypes.pyqtcreator-data: /usr/share/qtcreator/debugger/opencvtypes.pyqtcreator-data: /usr/share/qtcreator/debugger/pdbbridge.pyqtcreator-data: /usr/share/qtcreator/debugger/personaltypes.pyqtcreator-data: /usr/share/qtcreator/debugger/qttypes.pyqtcreator-data: /usr/share/qtcreator/debugger/stdtypes.pyqtcreator-data: /usr/share/qtcreator/qml/qmlpuppet/qml2puppet/instances/nodeinstancesignalspy.cppqtcreator-data: /usr/share/qtcreator/qml/qmlpuppet/qml2puppet/instances/nodeinstancesignalspy.hqtcreator-data: /usr/share/qtcreator/templates/wizards/classes/python/file.pyqtcreator-data: /usr/share/qtcreator/templates/wizards/classes/python/wizard.jsonqtcreator-data: /usr/share/qtcreator/templates/wizards/files/python/file.pyqtcreator-data: /usr/share/qtcreator/templates/wizards/files/python/wizard.json 可以看到 /usr/share/qtcreator/debugger/ 目录下关于 qtcreator 对 debug 所做的优化，不过不知道为什么直接使用 qtcreator 提供的 qt 类型相关的脚本没有成功(有成功的可以在下面回复方法指点一下)。因此又在 github 上搜索相关内容找到了另一个 qt 相关的 Pretty-Print 脚本，项目地址为：https://github.com/Lekensteyn/qt5printers，在 linux 系统下具体使用方法如下： 12# 克隆项目到~/.git/qt5printers目录下git clone git@github.com:Lekensteyn/qt5printers.git ~/.git/qt5printers 复制以下内容到~/.gdbinit文件中，若文件不存在则手动创建：123456pythonimport sys, os.pathsys.path.insert(0, os.path.expanduser('~/.gdb'))import qt5printersqt5printers.register_printers(gdb.current_objfile())end 做完之后就可以 debug 一个 qt 程序测试了]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hides overloaded virtual function]]></title>
    <url>%2F2018%2F10%2F04%2Fhides-overloaded-virtual-function%2F</url>
    <content type="text"><![CDATA[在重载父类的同名虚函数时会出现hides overloaded virtual function编译警告。从字面上的意思其实就可以理解：重载的虚函数被隐藏了。 三个关键点： 重载 虚函数 隐藏 这个编译警告之所以出现，是因为上面三个关键点，首先是发生了重载，子类重载了父类的函数，其次被重载的是虚函数，这时这个被重载的父类的虚函数将会被隐藏。何为隐藏呢，应该是不能使用子类实例直接调用父类被隐藏的函数，调用时必须指定父类命名空间，往深了说也就是编译器如果在子类中发现了要使用的函数的名字，注意，是名字不包含函数签名，只要名字匹配上，就不会再去父类中去寻找这个名字的函数，即便子类中的函数参数不匹配，也不会再去父类中寻找。 其实去掉虚函数这个关键点，在c++中当重载了父类的函数时，隐藏同样会发生，举个例子： 12345678910111213141516171819202122class A &#123;public: void foo() &#123; cout &lt;&lt; "foo of A" &lt;&lt; endl; &#125;&#125;;class B : public A&#123;public: void foo(int i) &#123; cout &lt;&lt; "foo of B" &lt;&lt; endl; &#125;&#125;;int main(void)&#123; B *b = new B(); b-&gt;foo(); //编译报错 b-&gt;A::foo(); //应该指定命名空间A:: b-&gt;foo(1); return 0;&#125; 当重载的父类函数为虚函数时，代码如下： 12345678910111213141516171819202122class A &#123;public: virtual void foo() &#123; //将父类函数声明为虚函数 cout &lt;&lt; "foo of A" &lt;&lt; endl; &#125;&#125;;class B : public A&#123;public: void foo(int i) &#123; //此处会有编译警告："'B::foo' hides overloaded virtual function" cout &lt;&lt; "foo of B" &lt;&lt; endl; &#125;&#125;;int main(void)&#123; B *b = new B(); b-&gt;foo(); //编译报错依旧 b-&gt;A::foo(); //应该指定命名空间A:: b-&gt;foo(1); return 0;&#125; 编译错误依旧，但多了一个编译警告，关于这个编译警告，有种解释说是为了避免书写错误，这就要说到多态，上面的例子没有应用多态有些不合适，修改一下： 1234567891011121314151617181920212223class BookA; //改动处class BookB; //改动处class A &#123;public: virtual void foo(BookA *) &#123; //改动处 cout &lt;&lt; "foo of A" &lt;&lt; endl; &#125;&#125;;class B : public A&#123;public: void foo(BookB *) &#123; //改动处 cout &lt;&lt; "foo of B" &lt;&lt; endl; &#125;&#125;;int main(void)&#123; A *b = new B(); //改动处 b-&gt;foo(new BookB()); return 0;&#125; 与之前的例子的区别是多声明了两个类：BookA和BookB，函数的参数类型换成了这两个类，最重要的一点是main函数中将实例B声明为了A类型，此时就可以比较清晰的看出为什么这个警告是为了书写错误： 假设我们就是要在B类中重写父类A的void foo(BookA *)函数，以便在main函数中实现以类型A的实例去调用B对象的重写函数(多态调用)，但却因为书写错误，把B类行的函数的参数写成了BookB *，这就与初衷不符了，此时这个编译警告就是有价值的了。 再假设，我们就是要在B类中声明void foo(BookB *)这么一个函数，且并不是为了重写父类中的函数，那么此时这个编译警告就是多余的，我们可以使用using来避免这个警告，例如在类B中做出如下声明： 1234567class B : public A&#123;public: using A::foo; void foo(BookB *) &#123; cout &lt;&lt; "foo of B" &lt;&lt; endl; &#125;&#125;; 这样就是告诉编译器，我们明确要使用这两个函数，并不是为了重写，这样有一个可能不期望出现的情况，就是B的实例也可调用void foo(BookA *)函数，如果不想这个情况发生，可以把using放到私有的里面，这样既解决了编译警告，又不会暴露父类的这个函数出去： 12345678class B : public A&#123;public: void foo(BookB *) &#123; cout &lt;&lt; "foo of B" &lt;&lt; endl; &#125;private: using A::foo;&#125;; 参考了一个帖子：https://stackoverflow.com/questions/18515183/c-overloaded-virtual-function-warning-by-clang]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>virtual</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-找回已删除的分支]]></title>
    <url>%2F2018%2F10%2F04%2Fgit-%E6%89%BE%E5%9B%9E%E5%B7%B2%E5%88%A0%E9%99%A4%E7%9A%84%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[手残总是难免的，有时候不小心删掉了一个还没有合并或者push的分支，等反应过来似乎已经找不到这个分支在仓库中存在的痕迹了。 这时git reflog命令就体现出了它的价值，其实git会把我们在仓库里的所有操作都记录下来，从git reflog命令的输出就可以看到，就算是从分支A切换到分支B也会被记录下来，那么假设，分支B被误删，执行git reflog命令后就可以找到分支B的痕迹: “commit id”，不管是从其他分支切换到分支B，还是分支B的一个提交记录，都会看到其”commit id”，复制这个”commit id”然后切换过去，此时仓库处于分离头指针状态，其实现在已经是在分支B了，只需要从当前状态创建一个分支，那么分支B也就复活了： git checkout -b B-reborn这个分支B-reborn就是先前删除的分支B。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qprocess参数设置]]></title>
    <url>%2F2018%2F09%2F24%2Fqprocess%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[QProcess用于启动一个外部程序，并提供了与之通信的接口。使用setProgram来设置要启动的外部程序，setArguments来设置要传递给这个外部程序的参数。setArguments需要一个QStringList类型的参数，在构造这个参数的时候要注意不能把外部程序需要的参数作为一整个字符串。举个例子：要用QProcess执行find -name abc.txt 1234QProcess process;process.setProgram("find");process.setArguments(QStringList("-name abc.txt")); // 这是错误的process.setArguments(QStringList() &lt;&lt; "-name" &lt;&lt; "abc.txt");]]></content>
  </entry>
  <entry>
    <title><![CDATA[the menu is gone in qt on mac osx]]></title>
    <url>%2F2018%2F01%2F06%2Fthe-menu-is-gone-in-qt-on-mac-osx%2F</url>
    <content type="text"><![CDATA[在osx系统下, qt程序菜单项的名字如果是“quit”,”about”(不区分大小写), 这个菜单项就会消失, 如果这个菜单只包含这些会消失的菜单项, 那么这个菜单也会消失.猜测: 这应该是由于跟osx系统默认给程序提供了一些菜单项有冲突的关系. 问题示例代码:123456789101112131415SimpleMenu::SimpleMenu(QWidget *parent) : QMainWindow(parent) &#123; // 只要菜单项的名字不是“Quit”或“quit”就可以正常显示 QAction *quit = new QAction("&amp;Quit", this); // 只要菜单项的名字不是“About”或“about”就可以正常显示 QAction *about = new QAction("&amp;about", this); QMenu *file; file = menuBar()-&gt;addMenu("&amp;File"); file-&gt;addAction(quit); file-&gt;addAction(about); connect(quit, &amp;QAction::triggered, qApp, QApplication::quit);&#125;]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>menu</tag>
        <tag>disappear</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim-ycm-qt自动补全问题]]></title>
    <url>%2F2017%2F12%2F21%2Fvim-ycm-qt%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[更新：可以使用rdnetto/YCM-Generator插件来自动生成.ycm_extra_conf.py 当前操作系统: osx 10.13使用brew安装的qt5 qt安装目录在哪里不需要管, 因为使用brew更新qt后安装目录会随着版本变动而变动, 但不管哪个版本brew都会在/usr/local/opt/创建一个链接指向真正的目录, 我只安装了qt5, 所以上述目录下有两个链接, qt和qt5, 这两个目录都指向qt5的安装目录, 任选一个路径用于下面的命令即可, 这里使用这个路径:/usr/local/opt/qt. 执行一个命令来找到所有需要的库的路径:1find /usr/local/opt/qt/ -name &quot;Headers&quot; | grep &quot;framework\/Headers&quot; &gt; ~/headers 执行完毕后会在HOME下生成headers文件, 文件的内容就是qt5所有的库的路径(头文件), 接下来就是将这些路径添加到ycm的配置文件.ycm_extra_conf.py里了, 下面是我修改好的, 保存为:.ycm_extra_conf.py放到项目目录下(或上级目录), ycm就会自动读取了.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195from distutils.sysconfig import get_python_incimport platformimport osimport ycm_core# These are the compilation flags that will be used in case there&apos;s no# compilation database set (by default, one is not set).# CHANGE THIS LIST OF FLAGS. YES, THIS IS THE DROID YOU HAVE BEEN LOOKING FOR.flags = [&apos;-Wall&apos;,&apos;-Wextra&apos;,&apos;-Werror&apos;,&apos;-Wno-long-long&apos;,&apos;-Wno-variadic-macros&apos;,&apos;-fexceptions&apos;,&apos;-DNDEBUG&apos;,# You 100% do NOT need -DUSE_CLANG_COMPLETER in your flags; only the YCM# source code needs it.&apos;-DUSE_CLANG_COMPLETER&apos;,# THIS IS IMPORTANT! Without the &apos;-x&apos; flag, Clang won&apos;t know which language to# use when compiling headers. So it will guess. Badly. So C++ headers will be# compiled as C headers. You don&apos;t want that so ALWAYS specify the &apos;-x&apos; flag.# For a C project, you would set this to &apos;c&apos; instead of &apos;c++&apos;.&apos;-x&apos;,&apos;c++&apos;,&apos;-isystem&apos;,&apos;../BoostParts&apos;,&apos;-isystem&apos;,get_python_inc(),&apos;-isystem&apos;,&apos;../llvm/include&apos;,&apos;-isystem&apos;,&apos;../llvm/tools/clang/include&apos;,&apos;-I&apos;,&apos;.&apos;,&apos;-I&apos;,&apos;./ClangCompleter&apos;,&apos;-isystem&apos;,&apos;./tests/gmock/gtest&apos;,&apos;-isystem&apos;,&apos;./tests/gmock/gtest/include&apos;,&apos;-isystem&apos;,&apos;./tests/gmock&apos;,&apos;-isystem&apos;,&apos;./tests/gmock/include&apos;,&apos;-isystem&apos;,&apos;./benchmarks/benchmark/include&apos;,# for qt5 which installed by brew in mac&apos;-I&apos;, &apos;/usr/local/opt/qt/include&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/Qt3DAnimation.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/Qt3DCore.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/Qt3DExtras.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/Qt3DInput.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/Qt3DLogic.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/Qt3DQuick.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/Qt3DQuickAnimation.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/Qt3DQuickExtras.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/Qt3DQuickInput.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/Qt3DQuickRender.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/Qt3DQuickScene2D.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/Qt3DRender.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtBluetooth.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtCharts.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtConcurrent.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtCore.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtDataVisualization.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtDBus.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtDesigner.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtDesignerComponents.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtGamepad.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtGui.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtHelp.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtLocation.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtMacExtras.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtMultimedia.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtMultimediaQuick_p.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtMultimediaWidgets.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtNetwork.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtNetworkAuth.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtNfc.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtOpenGL.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtPositioning.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtPrintSupport.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtPurchasing.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtQml.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtQuick.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtQuickControls2.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtQuickParticles.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtQuickTemplates2.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtQuickTest.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtQuickWidgets.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtRemoteObjects.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtRepParser.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtScript.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtScriptTools.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtScxml.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtSensors.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtSerialBus.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtSerialPort.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtSql.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtSvg.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtTest.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtTextToSpeech.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtUiPlugin.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtWebChannel.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtWebEngine.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtWebEngineCore.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtWebEngineWidgets.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtWebSockets.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtWebView.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtWidgets.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtXml.framework/Headers&apos;,&apos;-I&apos;,&apos;/usr/local/opt/qt/lib/QtXmlPatterns.framework/Headers&apos;,]# Clang automatically sets the &apos;-std=&apos; flag to &apos;c++14&apos; for MSVC 2015 or later,# which is required for compiling the standard library, and to &apos;c++11&apos; for older# versions.if platform.system() != &apos;Windows&apos;: flags.append( &apos;-std=c++11&apos; )# Set this to the absolute path to the folder (NOT the file!) containing the# compile_commands.json file to use that instead of &apos;flags&apos;. See here for# more details: http://clang.llvm.org/docs/JSONCompilationDatabase.html## You can get CMake to generate this file for you by adding:# set( CMAKE_EXPORT_COMPILE_COMMANDS 1 )# to your CMakeLists.txt file.## Most projects will NOT need to set this to anything; you can just change the# &apos;flags&apos; list of compilation flags. Notice that YCM itself uses that approach.compilation_database_folder = &apos;&apos;if os.path.exists( compilation_database_folder ): database = ycm_core.CompilationDatabase( compilation_database_folder )else: database = NoneSOURCE_EXTENSIONS = [ &apos;.cpp&apos;, &apos;.cxx&apos;, &apos;.cc&apos;, &apos;.c&apos;, &apos;.m&apos;, &apos;.mm&apos; ]def DirectoryOfThisScript(): return os.path.dirname( os.path.abspath( __file__ ) )def IsHeaderFile( filename ): extension = os.path.splitext( filename )[ 1 ] return extension in [ &apos;.h&apos;, &apos;.hxx&apos;, &apos;.hpp&apos;, &apos;.hh&apos; ]def GetCompilationInfoForFile( filename ): # The compilation_commands.json file generated by CMake does not have entries # for header files. So we do our best by asking the db for flags for a # corresponding source file, if any. If one exists, the flags for that file # should be good enough. if IsHeaderFile( filename ): basename = os.path.splitext( filename )[ 0 ] for extension in SOURCE_EXTENSIONS: replacement_file = basename + extension if os.path.exists( replacement_file ): compilation_info = database.GetCompilationInfoForFile( replacement_file ) if compilation_info.compiler_flags_: return compilation_info return None return database.GetCompilationInfoForFile( filename )def FlagsForFile( filename, **kwargs ): if not database: return &#123; &apos;flags&apos;: flags, &apos;include_paths_relative_to_dir&apos;: DirectoryOfThisScript() &#125; compilation_info = GetCompilationInfoForFile( filename ) if not compilation_info: return None # Bear in mind that compilation_info.compiler_flags_ does NOT return a # python list, but a &quot;list-like&quot; StringVec object. final_flags = list( compilation_info.compiler_flags_ ) # NOTE: This is just for YouCompleteMe; it&apos;s highly likely that your project # does NOT need to remove the stdlib flag. DO NOT USE THIS IN YOUR # ycm_extra_conf IF YOU&apos;RE NOT 100% SURE YOU NEED IT. try: final_flags.remove( &apos;-stdlib=libc++&apos; ) except ValueError: pass return &#123; &apos;flags&apos;: final_flags, &apos;include_paths_relative_to_dir&apos;: compilation_info.compiler_working_dir_ &#125;]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>vim</tag>
        <tag>ycm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[增大osx启动分区大小]]></title>
    <url>%2F2017%2F11%2F25%2F%E5%A2%9E%E5%A4%A7osx%E5%90%AF%E5%8A%A8%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[场景：osx，deepin linux, windows三系统, 需要扩大黑苹果的分区. osx下的磁盘工具简直不能更难用，有下面几个坑，很重要，要想扩容osx系统分区需要知道这些： 不识别空分区，分区必要格式化，否则磁盘工具不识别 必须是系统分区后面的分区才能合并到系统分区里 要合到系统分区的分区必须和系统分区统一格式!! 上面三个坑, 尤其是第三个, 搞得我差点重装osx, 磁盘工具竟然不自动格式化分区就直接和osx的系统盘合并了,导致虽然系统盘容量增大了, 但却出现一个分区里却有两块不同格式的磁盘空间, 幸好我记得合并进去的分区是多大,又动手压缩出来了, 然后格式化为osx系统分区格式, 再次合并才成功 osx下的磁盘工具虽然难用, 但是要扩大osx系统分区只能用这个工具, 不像linux或windows可以在livecd或者pe下调整. 正文:草草画了几个图, 当时操作的时候没有截图, 下面这张图是我的硬盘的分区: 既然是扩容osx分区, 那就需要从其他分区压缩出来一部分空间, 推荐在linux下使用gparted工具压缩和移动分区,当然windows下也可以, 可以用diskgenius软件操作.我需要从linux分区中压缩出来100G分给osx, 那么我就压缩之后的样子如下图: 虽然压缩出来的空间已经挨着osx的分区了, 但是osx的磁盘工具不能将osx之前的分区合并到osx的系统分区中,所以仅仅是压缩出来是不够的, 还需要将压缩出来的分区移动到osx分区之后, 且紧挨着osx分区, 移动后如下图: 然后格式化那块压缩出来的空间, 如果gparted或者diskgenius不支持当前osx分区的格式, 那就格式化成fat32格式,格式化完成之后就可以启动到osx系统了, 打开磁盘工具, 将那块压缩出来的分区的格式改成当前osx分区的格式,切记!! 一定要与当前osx分区的格式相同!!然后点击磁盘工具上的‘分区’按钮, 再点击那块格式化好的压缩出来的分区, 再点一下’+‘旁边的’-‘号按钮,也就是删除这个分区, 点击确定就行了, 删除这个分区后磁盘工具就会将其合并到osx的分区了.大功告成, 如下图:]]></content>
      <categories>
        <category>osx</category>
      </categories>
      <tags>
        <tag>osx</tag>
        <tag>分区</tag>
        <tag>扩容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下控制风扇转速]]></title>
    <url>%2F2017%2F10%2F26%2Flinux%E4%B8%8B%E6%8E%A7%E5%88%B6%E9%A3%8E%E6%89%87%E8%BD%AC%E9%80%9F%2F</url>
    <content type="text"><![CDATA[本文不一定适用于所有电脑，需要自己找到对应的设备文件 我的电脑中，风扇对应到linux下的设备文件的路径是：1/sys/class/hwmon/hwmon2/pwm1 其他电脑即便不是这个文件，也在类似的目录下，这个文件的内容是”0-255“的数值，相应的数值大小对应相应的风扇转速，向这个文件中写入不同的数据风扇就控制风扇的转速了。 我的电脑中这个文件的默认值是”85“。 下面附上我写的一个shell脚本，放到PATH里就可以方便的控制风扇转速了：12345#!/bin/bashread -p &quot;input speed(0-255) and ENTER: &quot; SPEED[[ -z $SPEED ]] &amp;&amp; SPEED=85echo $SPEED | sudo tee /sys/class/hwmon/hwmon2/pwm1 注意如果上述提到的设备文件不同，需要修改脚本中的路径。将上述代码保存为一个shell文件，如fancontrol.sh，并为其增加可执行权限：1chmod a+x fancontrol.sh 然后复制到PATH下，如/bin下。 使用方法：12//最大转速fancontrol.sh 255]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>fanspeed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞明白android中layout_weight的用法]]></title>
    <url>%2F2017%2F09%2F15%2F%E6%90%9E%E6%98%8E%E7%99%BDandroid%E4%B8%ADlayout-weight%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文是学习这篇博客所得的收获: Android：Layout_weight的深刻理解 当子控件有layout_weight属性时, 系统将先按照layout_width或layout_hight属性先把子控件放到父控件中, 之后才解析layout_weight属性, 然后计算父控件中的剩余空间,最后按比例分配剩余空间给子控件. 看一下处理layout_weight时所用到的公式:123456789# 实际尺寸: 子控件最终展示出来的尺寸# 当前尺寸: 子控件刚被放到布局中, 系统还没有解析其weight属性时的尺寸# weight比例: 子控件在所有有`layout_weight`属性的控件中所占的比例# (例: 三个子控件, 第一个比重为1, 第二个为2, 第三个为2,# 那么第一个所占比例为1/5, 第二个为2/5, 第三个为2/5)# 剩余空间: 子控件刚被放到父控件中, 系统还没有解析其weight属性时父控件还有多少剩余空间剩余空间 = 父控件尺寸 - 子控件1尺寸 - 子控件2尺寸 - 子控件3尺寸...实际尺寸 = 当前尺寸 + weight比例 * 剩余空间尺寸 当控件的layout_width以及layout_hight的值为0或者wrap_content时,layout_weight属性很容易预测最终效果, 它们会按照自己的weight比例去分配剩余空间尺寸. 需要留意的是当控件的layout_width或layout_hight的值为fill_parent的时候,此时每个子控件在刚被放到父控件中, 且系统还没有解析子控件的layout_weight时,父控件就已经没有剩余空间了, 因为此时所有子控件的当前尺寸都等于父控件的尺寸, 且第一个子控件就已经占满了父控件! 那么套用上述公式, 计算子控件最终实际尺寸的过程如下: 下面假设一个父控件中有三个子控件, 其比重为1 : 2 : 3,则子控件的weight比例依次为1/6, 2/6, 3/6 剩余空间的计算如下:12345剩余空间 = 父控件尺寸 - 子控件1当前尺寸 - 子控件2当前尺寸 - 子控件3当前尺寸# 上述等同于:剩余空间 = 父控件尺寸 - 父控件尺寸 - 父控件尺寸 - 父控件尺寸# 则(注意是负2):剩余空间 = -2 * 父控件尺寸 子控件最终实际尺寸的计算如下:123456789101112131415161718实际尺寸 = 当前尺寸 + weight比例 * 剩余空间尺寸# 子控件1:实际尺寸 = 父控件尺寸 + 1/6 * (-2 * 父控件尺寸) = 父控件尺寸 - 2/6 * 父控件尺寸 = 4/6 * 父控件尺寸 = 2/3 * 父控件尺寸# 子控件2:实际尺寸 = 父控件尺寸 + 2/6 * (-2 * 父控件尺寸) = 父控件尺寸 - 4/6 * 父控件尺寸 = 2/6 * 父控件尺寸 = 1/3 * 父控件尺寸# 子控件3:实际尺寸 = 父控件尺寸 + 3/6 * (-2 * 父控件尺寸) = 父控件尺寸 - 6/6 * 父控件尺寸 = 父控件尺寸 - 父控件尺寸 = 0 所以此时子控件3将会消失, 不会显示在屏幕上.]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>layout_weight</tag>
        <tag>linearlayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-CMD-ENTRYPOINT]]></title>
    <url>%2F2017%2F09%2F13%2Fdocker-CMD-ENTRYPOINT%2F</url>
    <content type="text"><![CDATA[一张图解释Dockerfile中CMD和ENTRYPOINT的关系,另外使用’docker run’新建容器时, 镜像后面跟的命令会覆盖Dockerfile中的CMD.]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>cmd</tag>
        <tag>entrypoint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker运行php容器网站无法运行]]></title>
    <url>%2F2017%2F09%2F12%2Fdocker%E8%BF%90%E8%A1%8Cphp%E5%AE%B9%E5%99%A8%E7%BD%91%E7%AB%99%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[使用如下命令启动一个php容器, 并将php项目的目录映射到容器内的apache容器下:1docker run -p 80:80 --name php_app -v "/project/directory":/var/www/html -d php 然后访问127.0.0.1, 结果网站无法运行, 提示:Permission denied, 进入正在运行的php容器, 去看看项目目录在容器里的权限是什么:123docker exec -it php_app bashcd /var/www/htmlls -l 发现文件的拥有者和属组都无法识别, 直接显示的UID和GID, 都是1000,这是因为项目文件在容器外, 也就是主机本地的拥有者和属组是都是我的用户,而我的用户的UID和GID在主机中是1000,但是php容器里却没有我这个账户, 所以也就无法正常识别所有者了,自然网站无法正常运行. 要想解决这个问题就得知道php这个容器使用的是哪个用户来启动apache和php服务, 经过搜索得知是”www-data”用户,那么修改这个用户的UID和GID为我的就行了(这里都是1000):1groupmod -g 1000 www-data &amp;&amp; usermod -u 1000 -g 1000 www-data 然后重启php容器即可:1docker restart php_app]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
        <tag>权限</tag>
        <tag>permission-denied</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的库文件在哪儿]]></title>
    <url>%2F2017%2F07%2F20%2Fpython%E7%9A%84%E5%BA%93%E6%96%87%E4%BB%B6%E5%9C%A8%E5%93%AA%E5%84%BF%2F</url>
    <content type="text"><![CDATA[当前操作系统: deepin基于debian 模块管理器pip默认的命令pip可能是来自pip2也可能是pip3, 这取决于安装pip2和pip3的顺序,安装pip2或pip3时会覆盖原有pip可执行文件, 所以在使用pip安装python模块时,最好明确指出使用pip2还是pip3, 而不是直接使用pip命令, 这样可以避免明明要安装python3的模块库, 下载安装的却是python2的模块库. 安装模块(库)使用pip命令安装模块时, 是否使用sudo提权会影响安装路径. 使用sudo提权会安装模块到以下路径:12/usr/lib/python*(版本不同,具体目录不同)# python自带的一些模块文件在这个路径下. 12/usr/local/lib/python*(版本不同,具体目录不同)# 用户自行安装的模块一般在这个路径下. 没有使用sudo提权会安装模块到以下路径:1~/.local/lib/python*(版本不同,具体目录不同)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocos2d-x-3.15缺少libfmod.so.6]]></title>
    <url>%2F2017%2F06%2F20%2Fcocos2d-x-3-15%E7%BC%BA%E5%B0%91libfmod-so-6%2F</url>
    <content type="text"><![CDATA[cocos2d-x v3.15版, 在linux下编译之后执行test里的demo时报错:123$ ./cpp-tests ./cpp-tests: error while loading shared libraries: libfmod.so.6:cannot open shared object file: No such file or directory 从报错可以看出缺少libfmod.so.6这个库文件, 网上搜索后得知这个文件在:$COCOS2D_HOME/external/linux-specific/fmod/prebuilt/64-bit目录下,而且是在执行$COCOS2D_HOME/build/install-deps-linux.sh时发生报错的, 他们的解决办法是将上述目录下的两个库文件libfmod.so和libfmodL.so,复制到/usr/local/lib/目录下, 并创建链接文件, 然后接着执行install-deps-linux.sh,但是这个方法对我没有作用, 可能是因为我是用的系统的缘故(deepin linux). 如果上述方法对你也没用就试试下面的方法:复制两个库文件到/usr/lib/目录下, 然后创建链接文件:1234#在cocos2d目录下执行cp external/linux-specific/fmod/prebuilt/64-bit/* /usr/lib/cd /usr/libln -s libfmod.so libfmod.so.6 然后就可以直接测试demo了, 不用重新编译]]></content>
      <categories>
        <category>cocos2d</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>deepin</tag>
        <tag>cocos2d</tag>
        <tag>libfmod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[miui 正在通过usb安装]]></title>
    <url>%2F2017%2F02%2F25%2Fmiui-%E6%AD%A3%E5%9C%A8%E9%80%9A%E8%BF%87usb%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[最近miui有个坑爹的设计, 就是使用adb从电脑端安装应用的时候会弹出一个提示,询问是否同意安装, 之所以坑爹是最近的版本把关闭这个功能的选项取消了,导致每次调试应用都要手动点击同意安装, 解决方法: 需要的东西root任何可以管理手机根目录下文件的文件管理器, 比如RE文件管理器 位置以及修改用RE管理器进入以下目录:1/data/data/com.miui.securitycenter/shared_prefs 用RE管理器的编辑模式(默认是查看模式)打开这个文件:1remote_provider_preferences.xml 找到下面这句:1234&lt;boolean name=&quot;perm_adb_install_notify&quot; value=&quot;true&quot; /&gt;# 将其中的&quot;true&quot;修改为&quot;false&quot;# 修改后为:&lt;boolean name=&quot;perm_adb_install_notify&quot; value=&quot;false&quot; /&gt; 还有找到这句:1234# 要确保这句中的值为&quot;true&quot;# 这个选项对应的时开发者选项里的&quot;USB安装&quot;# 只有这个值为&quot;true&quot;的时候这个选项才是打开的&lt;boolean name=&quot;security_adb_install_enable&quot; value=&quot;true&quot; /&gt; OK了, 不过这个方法好像重启手机后会重置, 需要再次设置, 不过也是不错的了]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>miui</tag>
        <tag>usb</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim中javacomplete2与syntastic一点使用心得]]></title>
    <url>%2F2017%2F02%2F12%2Fvim%E4%B8%ADjavacomplete2%E4%B8%8Esyntastic%E4%B8%80%E7%82%B9%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[插件简介javacomplete2 提供java语言的补全 便捷的import,extends,implement等 快速插入setter,getter方法,等等 插件地址: https://github.com/artur-shaik/vim-javacomplete2 syntastic 支持大量语言的语义检测 插件地址: https://github.com/vim-syntastic/syntastic 问题问题1当使用javacomplete2(以下简称jc2)补全非项目java文件时,也就是说编辑的文件不是eclipse,gradle,maven等管理的项目中的文件,这时如果是单个文件还没有什么问题,但如果是两个或两个以上,相互关联的文件(如:A文件中new到了B文件中定义的类),jc2就会力不从心,因为jc2不知道所有源文件的位置,以及CLASSPATH应该如何设置,如果是项目文件jc2可以利用项目的配置文件来处理上述问题. 问题2 这个问题已经在最新版本中解决了! 当项目中的java文件没有在某个包中时,也就是文件头部没有”package”语句,在eclipse中这叫”default package”,这时jc2也无法处理好多个类文件之间的关系. 问题3syntastic在进行java的语法检查时,如果你当前目录不是特定的位置,也会发生找不到某个类的情况. 处理问题处理1当使用eclipse等IDE时也就不会使用vim了,但如果不使用IDE时呢?那就用gradle或maven吧,我现在是用的gradle,用gradle可以方便的创建一个项目,而且项目的配置文件简单,甚至不用配置.使用如下命令就可以轻松创建一个项目:1gradle init --type java-library 执行完毕后当前目录结构如下:12345678build.gradlesettings.gradle (不重要)gradle/wrapper/gradle-wrapper.jar (不重要)gradle/wrapper/gradle-wrapper.properties (不重要)gradlew (不重要)gradlew.bat (不重要)src/main/java/Library.java (创建的默认类)src/test/java/LibraryTest.java (创建的默认测试类,不重要) 如上这个项目只是测试一个小问题或者什么的,那么被标记’不重要’的就是可以删除掉的了,这样就只剩下:12build.gradlesrc/main/java/ 简单明了,把java文件创建到”src/main/java/“下就行了.但这样还不够,请看问题2. 处理2问题2说了jc2需要有package语句,那就是说需要创建包目录,比如需要创建com.listenerri.test包,那么就在src/main/java/目录下执行:1mkdir -p com/listenerri/test/ 这样就创建了这个包目录,现在目录结构如下:1src/main/java/com/listenerri/test/ 这时就可以在test/目录下创建java文件了,而且要文件头部声明包:1package com.listenerri.test; 现在就可以完整的使用jc2的补全功能,游走在多个类文件之间了.如果你有使用syntastic插件,那就往下看,否则就可以去测试了. 处理3在上面问题3中提到syntastic需要在特定的目录下才能正常检测java语法,在本例中那个特定的目录就是src/main/java/,只需要在这个目录下打开java文件就可以了,如:1vim com/listenerri/test/HelloWorld.java 其实这个问题也跟java中间中声明的package语句有关,当声明包为: package com.listenerri.test;包的起始目录为com,那么就要在com目录的上层目录打开java文件,也就是要确保当前的工作目录下有完整的包目录. Over : )]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>vim</tag>
        <tag>javacomplete2</tag>
        <tag>syntastic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下使用drcom登录认证]]></title>
    <url>%2F2016%2F12%2F02%2Flinux%E4%B8%8B%E4%BD%BF%E7%94%A8drcom%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[下载首先感谢开发者:https://github.com/drcoms/drcom-generic这个项目基于python实现了d,p,x版drcom认证,请到上述链接查看相关信息,项目的wiki简单介绍了各版本的使用方法. 首先下载上面的drcom-generic,我将其下载到了家目录~/下,完整目录:~/drcom-generic 取得必要信息下面启动到windows,或者找一个有windows系统的电脑,因为需要知道官方的drcom客户端是连接的哪个服务器,以及其他信息,用来配置drcom-generic 在windows下安装上一个软件: wireshark这个软件很好找,就不说怎么安装了,安装好之后,如果你现在使用drcom上网的,那么就退出drcom客户端,也就是注销登录(这一步是必须的) 然后打开wireshark, 软件会列出有所有的网络适配器,我用的是无线网,适配器名称时:”无线网络连接”,只有已连接网络的适配器会有数据波动,如图所示: 双击已连接网络的适配器,本例中是第二项”无线网络连接”,然后wireshark就开始记录这个适配器的数据了, 现在打开drcom客户端,输入账户密码点击登录,如图所示: 等登录成功后,点击drcom客户端里的注销,注销之后点击wireshark软件里的”停止”按钮,如图: 然后选择左上角的”文件”按钮,点击另存为: 名字随便写就行了,一会儿还要改的,本例中保存为abc.pcapng,到这里windows下的工作就完成了. 配置drcom-generic回到linux系统,把之前保存的abc.pcapng文件复制到~/drcom-generic目录下,然后打开”drcom_d_config.py”文件,1filename = 搜索上面的文字,看看等号后面是什么,本例中是3.pcapng,那么就把abc.pcapng改名为3.pcapng,然后打开一个终端,执行以下命令:12cd ~/drcom-genericpython2 drcom_d_config.py &gt; config.txt 执行完毕后,如果一切正常那么打开”~/drcom-generic/config.txt”文件,就可以看到一些配置信息, 不要关闭”config.txt”文件,再打开同目录下的”latest-wired.py”文件,找到类似”config.txt”内容的部分,修改”latest-wired.py”里的那部分内容,改成和”config.txt”一样就行了 然后再在”latest-wired.py”文件里找”IS_TEST =”,找到后将等号后面改成”False” 最后连接就开始测试在linux下登录了,使用下面的命令来登录:12cd ~/drcom-genericpython2 latest-wired.py 我写了一个方便启动，关闭drcom的脚本，有兴趣的可以看看:https://github.com/ListenerRi/shells/blob/master/drcom.sh 下载下来后赋予可执行权限:1chmod +x drcom.sh 就可以用这个脚本来启动和关闭了,具体命令是:12345678#当不使用参数直接执行drcom.sh时,等同于使用-l参数#登录drcom.sh -l#重启drcom.sh -r#退出drcom.sh -q]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>drcom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言在函数中修改指针的值]]></title>
    <url>%2F2016%2F11%2F06%2Fc%E8%AF%AD%E8%A8%80%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BF%AE%E6%94%B9%E6%8C%87%E9%92%88%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[继续学习c语言中… 引入话题请注意文章标题: 在函数中修改指针的值, 而不是修改指针指向的值修改指针指向的值很容易理解, 在函数参数中声明一个指针类型,然后调用方法的时候把需要修改的值的指针传递过去就行了, 大体如下:12345678910#include &lt;stdio.h&gt;void test(int *a) &#123; *a = *a + 1; //使用取值运算符让指针a指向的值+1 printf(&quot;a: %d&quot;, *a);&#125;int main(void) &#123; int a = 0; test(&amp;a); return 0;&#125; 运行结果为:1a: 1 但本文所要说的是如何修改指针的值, 看下面的例子:123456789101112131415161718#include &lt;stdio.h&gt;void test(int *a) &#123; a = a + 1; //让指针a的值+1 if (a != NULL) &#123; printf(&quot;test: a不为空\n&quot;); &#125;&#125;int main(void) &#123; int *a = NULL; if (a == NULL) &#123; printf(&quot;main: a为空\n&quot;); &#125; test(a); if (a == NULL) &#123; printf(&quot;main: a为空\n&quot;); &#125; return 0;&#125; 运行结果为:123main: a为空test: a不为空main: a为空 可以看到虽然在test()方法里修改了指针的值(不是其指向的值),但main()方法中的指针的值并没有改变, 其实这很容易理解,因为指针也是一种变量而且在c语言中方法之间传参都是按值传递, 第一个例子之所以成功修改变量a的值,是因为相对于变量a来说是传递了a的地址(按地址传递),但如果相对于指针而言, 则依然是按值传递(传递的a的地址就是指针的值) 方法一所以如果要通过函数修改传递过去的指针的值, 就得使用指向指针的指针,可以如下声明:1234567//声明test方法void test(int **b);//在main中声明指向指针a的指针bint *a = NULL;int **b = NULL;b = &amp;a; 这样调用test方法时将b传过去就行了, 在test()方法中修改b所指向的值,也就是修改了指针a的值 方法二但上述方法比较容易把人搞糊涂, 所以最明了的方式是让test()方法返回修改后的指针,还是第二个例子, 稍作修改:12345678910111213141516171819#include &lt;stdio.h&gt;int * test(int *a) &#123; a = a + 1; //让指针a的值+1 if (a != NULL) &#123; printf(&quot;test: a不为空\n&quot;); &#125; return a;&#125;int main(void) &#123; int *a = NULL; if (a == NULL) &#123; printf(&quot;main: a为空\n&quot;); &#125; a = test(a); if (a != NULL) &#123; printf(&quot;main: a不为空\n&quot;); &#125; return 0;&#125; 运行结果为:123main: a为空test: a不为空main: a不为空 如果学过传c++, 那么c++中的引用这个概念可以很容易的实现在方法内修改指针,后来才知道c中并没有引用这个东西…]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>指针</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome adobe flash不是最新版本]]></title>
    <url>%2F2016%2F11%2F02%2Fchrome-adobe-flash%E4%B8%8D%E6%98%AF%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[google-chrome最近更新后flash不能正常运行了, 好象是不再包含flash player了,在看视频或者需要用到flash player的时候就会提示:adobe flash player 不是最新版本 解决方法也简单, 只是需要梯(fan)子(qiang), 如何找梯子本文就不提及了.有了梯子之后, 设置好代理启动chrome, 在地址栏输入: chrome://components/, 回车,然后找到flash player那一项, 点击更新就行了. 下面详细说说linux下和windows下怎么设置代理: linux下在终端中设置好代理变量, 然后接着在同一个终端下以命令的方式启动chrome就行了,下面是具体命令:123export http_proxy=127.0.0.1:8787export https_proxy=127.0.0.1:8787google-chrome 命令解释, 前两行主要是指定代理地址和端口, 因为我是在本机运行的代理软件, 所以地址是127.0.0.1而8787则是代理软件监听的端口, 第三行则是启动chrome windows下就十分简单了, 启动代理软件, 一般代理软件都有系统代理的选项, 选择启动系统代理,然后运行chrome就行了. 下面附上linux下的过程:]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>flash</tag>
        <tag>版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux映射修饰键]]></title>
    <url>%2F2016%2F10%2F24%2Flinux%E6%98%A0%E5%B0%84%E4%BF%AE%E9%A5%B0%E9%94%AE%2F</url>
    <content type="text"><![CDATA[首先，先说一个并不好用的方法，请看链接：使用xmodmap命令映射按键之所以说这是一个不好用的方法是因为它在大多数桌面环境下没法实现开机自动映射，只能进入系统后手动执行命令才能实现映射，而且即便手动执行映射命令生效了，也会由于未知原因，过一段时间后失效，所以要想安稳的实现映射还是看下面的方法吧。 本方法基于X图形框架，也就是要实现按键映射必须启动X 请留意文章标题，说的是修饰键(modified key)，也就是Ctrl,Alt,Shift,Esc,Super(windows)等键，而是不键盘上的任意键，应该也可以实现任意键，但就需要深入学习X框架了，推荐从这里入门： Arch WiKi: X KeyBoard extension 下面说简单的修饰键映射方法：首先在X图形框架的配置文件夹/etc/X11/xorg.conf.d/下新建90-custom-kbd.conf文件，然后将下面的代码粘贴到上面新建的文件中： 123456Section &quot;InputClass&quot; Identifier &quot;keyboard defaults&quot; MatchIsKeyboard &quot;on&quot; Option &quot;XKbOptions&quot; &quot;caps:escape&quot;EndSection 我们需要注意以及修改的地方只有“caps:escape”这个位置，当前这段配置的作用是将caps（大写锁定）键映射到esc键，也就是说，让大写锁定键的作用变成esc键，而不再是原有的大写锁定作用，同时esc键保留原有的作用。 看到这里你可能以为so easy，这样看来只需要修改成”ctrl:alt”就可以实现，让ctrl键变成alt键了。 然而，并不是。。起初我也以为是这样，经过测试后无效，摸索了很久终于弄懂了，原来”caps:escape”是一个已经定义好的选项，所以可以直接拿来用，而不是随便写的,而”ctrl:alt”并不是以定义的选项所以无效。 那么怎么定义选项呢，抱歉，我也没学会，就像文章开头所说的这就需要深入学习X框架了，庆幸的是，已经有了大量以定义的选项，我们可以找到自己需要的并拿来使用， 以定义的选项可以从系统的这个文件里找： 1/usr/share/X11/xkb/rules/base.lst 打开这个文件，搜索”! option”，注意搜索关键字里包含感叹号和空格，这个关键字下面就是以定义的选项了，共分为两列，第一列是选项名，第二列可以理解为选项的作用，向下翻，以”grp”和”lv3”开头的选项不看，这些是更改键盘布局的选项，再往下就基本都是修饰键映射的选项了。 比如这个选项”ctrl:menu_rctrl”可以实现把menu键映射为右ctrl键，那么就修改之前新建的那个文件：/etc/X11/xorg.conf.d/90-custom-kbd.conf的内容为： 123456Section &quot;InputClass&quot; Identifier &quot;keyboard defaults&quot; MatchIsKeyboard &quot;on&quot; Option &quot;XKbOptions&quot; &quot;ctrl:menu_rctrl&quot;EndSection 保存后重启X图形框架，或者重启系统就可以实现把menu键映射为右ctrl键了。 下面给出一些特殊名字的含义： menu: 一般在右ctrl键的左边，正常功能相当于鼠标右键 super: 我们一般叫它windows键 numlock: 右边数字键盘开关键 compose: Fn功能键 另外左右ctrl或者alt键通过字母l和r来区分，比如左ctrl键是lctrl,右ctrl键是rctrl]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>map</tag>
        <tag>key</tag>
        <tag>modified</tag>
        <tag>映射</tag>
        <tag>按键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类与接口是否可以实例化]]></title>
    <url>%2F2016%2F08%2F08%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%9E%E4%BE%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[抽象类与接口简介具体的就不说了,直说一下二者的重要的相同点和区别: 相同点: 都是抽象的(不能正常实例化的) 都可以有抽象方法 都可以有成员变量 区别: 抽象类除了不能正常实例化和可以含有抽象方法外其他特性与普通类相同 抽象类既可以有抽象方法也可以有普通的方法,而接口只能包含抽象方法 抽象类可以只声明成员变量而不初始化,接口必须在声明成员方法时初始化 不能实例化以前我一直认为抽象类和接口是不能被初始化的, 意思就是不能使用new关键字来获取类的实例(接口也算是一个类),如:1TestInterface inter = new TestInterface(); 当TestInterface是一个抽象类或者接口时,上述代码将会产生编译时错误. 但是当我在学习鸿洋的一篇关于Android中RecyclerView的博客时发现他对一个接口使用了new关键字原文链接请点击:Android中RecyclerView这让我不得不重新思考接口和抽象类到底能否实例化,还是仅仅不能用上述的普通方法来实例化,于是有了下面的一段测试:12345678910111213141516171819202122232425262728293031323334public class test &#123; public test() &#123; TestInterface inter = new TestInterface() &#123; public void myTestInterface() &#123; System.out.println("run method myTestInterface"); &#125; &#125;; TestAbstract abs = new TestAbstract() &#123; public void myTestAbstract() &#123; System.out.println("run method myTestAbstract"); &#125; &#125;; inter.myTestInterface(); abs.myTestAbstract(); abs.print(); &#125; public static void main(String[] args) &#123; test t = new test(); &#125;&#125;interface TestInterface &#123; public void myTestInterface();&#125;abstract class TestAbstract &#123; public abstract void myTestAbstract(); public void print() &#123; System.out.println("run method print"); &#125;&#125; 执行结果为:123run method myTestInterfacerun method myTestAbstractrun method print 所以是可以对抽象类和接口使用new关键字的,但是在初始化的时候还是需要去实现抽象类和接口中所定义的抽象方法那么这到底是算是对抽象了和接口实例化了吗? 个人想法以下是个人想法,有待验证,如果错误请指出java之所以不允许以正常方式使用new关键字来实例化抽象类和接口,是因为其中定义了抽象方法,既然有抽象方法,那么即使你获取了抽象类和接口的实例,这些抽象方法也没有具体的实现(方法内容),也是没有意义的.但即使你删除上面测试代码中抽象类所定义的抽象方法myTestAbstract()之后,只保留抽象类的具体方法print(),依然无法对TestAbstract抽象类进行普通实例化,所以java应该是认为只要是抽象类和接口都是不能被正常实例化的. 而上述代码又确实使用new关键字进行了实例化,但是请注意,上述代码在实例化时,实现了抽象类和接口所定义的抽象方法,所以关键字new后面的类型已经不能算是原来的抽象类和接口了,它已经是一个具体的类了,而不是抽象的了,因为原来的抽象类和接口里的抽象方法是没有方法体的,也就是没有具体内容的, 当你在一个”类”中实现了这些抽象方法,那么这个类就已经不是原来的”类”了.所以上述代码之所以能够正常运行,是因为new关键字所获取的类的实例并不是抽象类或接口的实例.因而”抽象类和接口不能被实例化”这句话是正确的所以按照上面测试中的方法对抽象类和接口使用new关键字与上面这句话并不冲突.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>abstract</tag>
        <tag>iterface</tag>
        <tag>抽象类</tag>
        <tag>接口</tag>
        <tag>实例化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下添加UEFI启动项]]></title>
    <url>%2F2016%2F07%2F25%2Flinux%E4%B8%8B%E6%B7%BB%E5%8A%A0UEFI%E5%90%AF%E5%8A%A8%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[今天突然发生了一件怪事,系统重启后没有了硬盘的uefi启动项, 吓了我一跳,我以为硬盘挂了,立即进livecd查看硬盘信息,好在一切正常.我的电脑通常会自动添加应该第一分区(esp分区)里的一些启动项, 但这次重启几次之后依然不能自动添加,而我又是archlinux单系统,没得用easyuefi,所以只能手动在linux下添加了,我没有在livecd中进行添加,而是进入硬盘中的archlinux后添加的.有人会疑惑,没有启动项是怎么进入系统的??详细的就不说了,本文主要说怎么添加uefi启动项,就只简单描述下如何在没有uefi启动项的情况下进入系统:进入BIOS,启动uefi的shell模式,在shell模式中找到archlinux的efi引导文件,直接回车就行了 efibootmgr命令在windows下通常使用easyuefi软件来管理uefi启动项,linux下我还不知道有什么图形化的软件来管理uefi启动项,只知道一个efibootmgr命令,在终端中进行操作,这个命令的参数选项有:12345678910111213141516171819202122232425262728293031usage: efibootmgr [options] -a | --active sets bootnum active -A | --inactive sets bootnum inactive -b | --bootnum XXXX modify BootXXXX (hex) -B | --delete-bootnum delete bootnum (hex) -c | --create create new variable bootnum and add to bootorder -C | --create-only create new variable bootnum and do not add to bootorder -D | --remove-dups remove duplicate values from BootOrder -d | --disk disk (defaults to /dev/sda) containing loader -e | --edd [1|3|-1] force EDD 1.0 or 3.0 creation variables, or guess -E | --device num EDD 1.0 device number (defaults to 0x80) -g | --gpt force disk with invalid PMBR to be treated as GPT -i | --iface name create a netboot entry for the named interface -l | --loader name (defaults to \EFI\redhat\grub.efi) -L | --label label Boot manager display label (defaults to "Linux") -m | --mirror-below-4G t|f mirror memory below 4GB -M | --mirror-above-4G X percentage memory to mirror above 4GB -n | --bootnext XXXX set BootNext to XXXX (hex) -N | --delete-bootnext delete BootNext -o | --bootorder XXXX,YYYY,ZZZZ,... explicitly set BootOrder (hex) -O | --delete-bootorder delete BootOrder -p | --part part (defaults to 1) containing loader -q | --quiet be quiet -t | --timeout seconds set boot manager timeout waiting for user input. -T | --delete-timeout delete Timeout. -u | --unicode | --UCS-2 pass extra args as UCS-2 (default is ASCII) -v | --verbose print additional information -V | --version return version and exit -w | --write-signature write unique sig to MBR if needed -@ | --append-binary-args file append extra args from file (use "-" for stdin) -h | --help show help/usage 看起来复杂,其实只需要用到其中几个,下面说几个常用的: 不加任何参数表示打印当前所有的启动项和启动顺序 -b 修改 -B 删除 -c 添加 -d 指定硬盘(默认是/dev/sda)[注意这里的根目录是相对于系统的根来说的] -l 指定引导器(默认是\EFI\redhat\grub.efi)[注意这里的根目录是相对于你的esp分区来说的,而且用反斜杠\来表示目录级别] -L 启动项的名字 使用示例下面说两个简单的例子: 注意efibootmgr命令需要使用root权限!! 添加一个名叫Arch的启动项背景描述: 硬盘是/dev/sda esp分区被挂载到/boot/efi目录下 esp分区中包含/EFI/arch/bootx64.efi文件具体添加的命令是:1efibootmgr -c -d /dev/sda -l '\EFI\arch\bootx64.efi' -L Arch 这样就添加好了,命令的返回信息也显示已经添加完成了,还可以直接执行bootmgr命令查看. 删除一个名叫Arch的启动项efibootmgr并不能通过启动项的名字来删除它,只能通过编号来删除,直接执行efibootmgr返回的信息中就包含了每个启动项的编号,比如:12345678~# efibootmgrBootCurrent: 0000Timeout: 0 secondsBootOrder: 0000,0002,0003,0001Boot0000* ArchBoot0001* CD/DVD Drive Boot0002* UEFI: KingstonDataTraveler 2.0PMAPBoot0003* Hard Drive 可以看到启动Boot0000就是名叫Arch的启动项,另外BootOrder显示的是启动项的顺序,具体修改方法就自己执行man efibootmgr命令查看吧;)那么删除Arch这个启动项的命令就是:1efibootmgr -b 0 -B 注意命令中的0是数字0,如果是删除Boot0002的话就把数字0改为2即可 小结从上面两个命令可以看出efibootmgr这个命令的参数是需要结合使用的,比如删除选项-B就需要结合修改选项-b还有其实直接执行efibootmgr -c也可以创建一个启动项,但这个启动项八成是不能用的,具体原因就自己man去吧~~]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>uefi</tag>
        <tag>启动项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试网站是否能被百度蜘蛛抓取]]></title>
    <url>%2F2016%2F07%2F01%2F%E6%B5%8B%E8%AF%95%E7%BD%91%E7%AB%99%E6%98%AF%E5%90%A6%E8%83%BD%E8%A2%AB%E7%99%BE%E5%BA%A6%E8%9C%98%E8%9B%9B%E6%8A%93%E5%8F%96%2F</url>
    <content type="text"><![CDATA[只需要使用curl命令配合一些参数就可以测试了,看返回内容就知道能否抓取了1234# 用PC的UA来抓取curl -A "Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)" http://listenerri.com# 用移动UA来抓取curl -A "Mozilla/5.0 (Linux;u;Android 4.2.2;zh-cn;) AppleWebKit/534.46 (KHTML,like Gecko) Version/5.1 Mobile Safari/10600.6.3 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html）" http://listenerri.com 下面两张图是我测试正常的,第一张是上述命令返回的开始部分,第二张是上述命令返回的结束部分:]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>seo</tag>
        <tag>蜘蛛</tag>
        <tag>百度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决安卓屏幕旋转所带来的问题]]></title>
    <url>%2F2016%2F06%2F30%2F%E8%A7%A3%E5%86%B3%E5%AE%89%E5%8D%93%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%AC%E6%89%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[为什么屏幕旋转会带来问题在屏幕旋转时,系统会销毁当前活动的activity,并在旋转后重新创建一个新的activity,那么旋转前activity中的一些数据就会丢失.所以只要找到一个方法能实现旋转前保存某些数据,并在新创建的activity中可以取出之前保存的数据,也就解决了这个问题. 然而保存数据并不是万能的,有些操作是不能中断的,比如播放音乐,这就要用到另一种方法. 两个不同的例子场景一:答题当用户正在回答一些题目,每回答完一道题就保存用户填写的信息到文件中并切换出下一道题的view,此时如果旋转了屏幕,那么旋转后标志用户正在填写哪一道题的对象就会丢失,而不得不从第一题重来.这种场景适合使用OnSaveInstanceState(Bundle savedInstanceState)方式来解决,使用方法很简单,只需要在activity中重写上述方法即可:1234567891011@Overridepublic void OnSaveInstanceState(Bundle savedInstanceState)&#123; //这一句应该保留,因为这个方法默认是有一些行为的 super.OnSaveInstanceState(savedInstanceState); //下面是我们重写新增的需要保存的数据 //使用Bundle的savedInstanceState对象来存数数据 //比如上述场景需要保存一个标志题号的数据:"index" savedInstanceState.putInt("index",5); //也就是以键值对的形式保存int型数据`5`&#125; 之后在onCreate方法中取出这个保存的数据即可. 需要注意的是我们在Bundle中保存的只能是基本数据类型以及可以实现Serializable接口的对象,也就是说如果需要保存一个类的对象时,需要让这个类实现Serializable接口. 场景二:播放音乐上面那个重写OnSaveInstanceState(Bundle savedInstanceState)的解决方法即使用于activity也适用于fragment,虽然能恢复旋转前的数据,但由于被销毁了,终究是会中断一段时间的,如果当前activity或fragment的作用是播放音乐,即便可以实现旋转后恢复播放进度,但仍就会停顿一下,这太影响用户体验了.所以也就有了这个场景二,这个方法只适用于fragment,这个方法使得这个fragment在屏幕旋转时被保留下来,不会销毁它,那么这个fragment的一些成员变量就都不会丢失了,并且在屏幕旋转期间依旧继续工作.在本例中保留这个fragment就可以使得它的成员变量MediaPlayer的实例一直存在并正常工作.要想保留一个fragment只需要在fragment的onCreate方法中添加一行代码即可:1setRetainInstance(true); 默认情况下上述方法的参数为false,也就是说默认情况下fragment会被销毁并重建.保留的fragment利用了这样一个事实:可以销毁和重建fragment的视图,但无需销毁fragment自身fragment都是由fragmentManager管理的,在设备旋转时fragmentManager总是销毁fragment的视图,因为需要根据设备的属性重新配置视图,但在尝试销毁fragment前会检测上述方法的参数,如果为true则不销毁这个fragment,当托管这个fragment的activity重建后fragmentManager就找到未消毁的fragment并为它生成新的视图;反之销毁,并重建视图和fragment.也就是说这个fragment有一段时间是没有任何activity来托管它的,需要注意的是这段时间非常短暂!,而且如果在这段时间内,系统需要回收内存那么就会销毁掉这个fragment. 两种方法的主要区别 第一种方法: OnSaveInstanceState(Bundle savedInstanceState)第二种方法: setRetainInstance(true) 第一种方法 既可以用于activity,也可以用于fragment 主要用于保存和恢复应用的UI状态 只能存储基本类型数据或以实现Serializable接口的类 第二种方法 只能用于fragment 数据保存较时间第一种方法短,并且有可能被系统回收内存时销毁 由于保存对象时fragment所以无需关心fragment中数据的类型和某个类是否实现了Serializable接口]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>fragment</tag>
        <tag>屏幕旋转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux制作可启动iso]]></title>
    <url>%2F2016%2F05%2F04%2Flinux%E5%88%B6%E4%BD%9C%E5%8F%AF%E5%90%AF%E5%8A%A8iso%2F</url>
    <content type="text"><![CDATA[在arch下mkisofs命令和genisoimage命令是一样的,mkisofs是genisoimage的一个链接 使用isolinux作为引导,需自行下载并放到iso根目录下,需手动编写isolinux.cfg并放到isolinux下,具体参见其他可启动iso 最后使用如下命令:1mkisofs -o myiso.iso -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table myiso 参数: -o 将生成的iso文件 -b 引导程序(这里的路径是指iso的根目录,也就是相对于myiso这个目录) -c 将boot.cat生成到isolinux下(boot.cat是自动生成的) myiso 是要制作iso的目录,也是iso的根目录 其他参数请man mkisofs]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>iso</tag>
        <tag>可启动</tag>
        <tag>u盘启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言打印乘法口诀和三角]]></title>
    <url>%2F2016%2F05%2F04%2Fc%E8%AF%AD%E8%A8%80%E6%89%93%E5%8D%B0%E4%B9%98%E6%B3%95%E5%8F%A3%E8%AF%80%E5%92%8C%E4%B8%89%E8%A7%92%2F</url>
    <content type="text"><![CDATA[打印乘法口诀和三角所用的算法跟java一样,直接上代码 打印乘法口诀:12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(void)&#123; for (int i = 1; i &lt;= 9; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; printf("%d*%d=%d\t", j, i, i*j); &#125; printf("\n"); &#125; return 0;&#125;//执行结果:1*1=1 1*2=2 2*2=41*3=3 2*3=6 3*3=91*4=4 2*4=8 3*4=12 4*4=161*5=5 2*5=10 3*5=15 4*5=20 5*5=251*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=361*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=491*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=641*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 三角,同时输出两个三角,一正一倒:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;int main(void)&#123; /* 正-倒 * 1-9 * 3-7 * 5-5 * 7-3 * 9-1 */ for (int i = 1; i &lt;= 9; ++i) &#123; if ( i % 2 != 0) &#123; for (int j = 1; j &lt;= (9-i)/2; ++j) &#123; printf("%c", ' '); &#125; for (int j = 1; j &lt;= i; ++j) &#123; printf("%c", '*'); &#125; for (int j = 1; j&lt;=(9-i)/2; ++j) &#123; printf("%c", ' '); &#125; printf("\t"); for (int j = 1; j&lt;= (9-(10-i))/2; ++j) &#123; printf("%c", ' '); &#125; for (int j = 1; j&lt;= (10-i); ++j) &#123; printf("%c", '*'); &#125; for (int j = 1; j&lt;= (9-(10-i))/2; ++j) &#123; printf("%c", ' '); &#125; printf("\n"); &#125; &#125; return 0;&#125;//执行结果: * ********* *** ******* ***** ***** ******* ************ *]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>乘法口诀</tag>
        <tag>三角</tag>
        <tag>打印</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言strlen()与sizeof]]></title>
    <url>%2F2016%2F05%2F04%2Fc%E8%AF%AD%E8%A8%80strlen-%E4%B8%8Esizeof%2F</url>
    <content type="text"><![CDATA[c语言没有string类型,字符串的处理使用的是char数组c会默认在字符串的尾部增加一个&#39;\0&#39;,也叫空字符(用来标记字符串的结束),所以字符串真正在内存中占用的字节数会比字符串的字符数多1. strlen()我们使用strlen()方法可以获取字符串的长度,也就是包含多少个字符数然而获取到的这个字符数并不包含尾部被自动追加的&#39;\0&#39;空字符 sizeofsizeof 这并不是一个方法,而是一个关键字,用来获得类型的大小,或某个量的大小,这里只讨论获取具体量的大小sizeof获取的是c或者程序员为这个具体量分配了多大的空间(字节数)以字符串,数组char举例:声明了一个20大小的字符串:12char name[20];name = jack; 那么sizeof name获得的大小就是20,而不是jack的字符数4,也不是真是占用内存的字节数5而strlen(name),方法获得的大小则是4,而不是5或者20 测试源码12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define TEST "i am jack"int main(void)&#123; char name[20]; printf("type your name:\n"); scanf("%s",name); printf("name is :%s\n", name); printf("sizeof name is : %ld\n", sizeof name); printf("strlen name is : %ld\n", strlen(name)); printf("\n"); printf("sizeof TEST is : %ld\n", sizeof TEST); printf("strlen TEST is : %ld\n", strlen(TEST)); return 0;&#125; 输出结果为:12345678type your name:jackname is :jacksizeof name is : 20strlen name is : 4sizeof TEST is : 10strlen TEST is : 9]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>strlen</tag>
        <tag>sizeof</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hybrid-sleep和sleep以及hibernate的区别]]></title>
    <url>%2F2016%2F05%2F04%2Fhybrid-sleep%E5%92%8Csleep%E4%BB%A5%E5%8F%8Ahibernate%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[bybrid-sleep混合休眠模式:是指电脑sleep(睡眠模式)和hibernate(休眠模式)同时进行,即把信息保存到内存的同时也写入到系统主分区的hiberfil.sys文件中 sleep睡眠模式,linux下也叫挂起(suspend):把信息到存到内存中,但不能断电,断电后数据丢失,恢复最快 hibernate休眠模式:把信息写入到文件中,也就是硬盘中,不会有断电丢失数据的问题,但恢复时最慢,和重新开机一样 对比图表:]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>hybrid-slep</tag>
        <tag>sleep</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse中DDMS的LOGcat只有一列level]]></title>
    <url>%2F2016%2F05%2F04%2Feclipse%E4%B8%ADDDMS%E7%9A%84LOGcat%E5%8F%AA%E6%9C%89%E4%B8%80%E5%88%97level%2F</url>
    <content type="text"><![CDATA[参考此贴解决此问题。 退出eclipse,打开下面的文件 ~/workspace/.metadata/.plugins/org.eclipse.core.runtime/.settings/com.android.ide.eclipse.ddms.prefs 粘贴下面的东西到打开的文件12345678910ddms.logcat.auotmonitor.level=error ddms.logcat.automonitor=false ddms.logcat.automonitor.userprompt=true eclipse.preferences.version=1logcat.view.colsize.Application=169logcat.view.colsize.Level=54logcat.view.colsize.PID=54logcat.view.colsize.Tag=198logcat.view.colsize.Text=619logcat.view.colsize.Time=182]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>eclipse</tag>
        <tag>ddms</tag>
        <tag>logcat</tag>
        <tag>不显示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim+ycm+eclim+javacomplete解决冲突]]></title>
    <url>%2F2016%2F05%2F04%2Fvim-ycm-eclim-javacomplete%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[四个主角各自的作用:vim:编辑器一枚ycm:自动补全插件(也就是不用按ctrl+x ctrl+o来调用vim的omni全能补全)eclim:让vim可以有部分eclipse的功能,也可以管理eclipse里的项目javacomplete:一个java的补全插件(这里说的是增强版的) 各自网址:ycm:https://github.com/Valloric/YouCompleteMeeclim:http://eclim.org/javacomplete:https://github.com/artur-shaik/vim-javacomplete2 这篇文章的主要目的不是如何安装和使用这些插件,而是解决eclim和javacomplete之间的冲突 在说冲突之前先说下eclim和javacomplete的生效条件:eclim:编辑的java类型的文件必须是eclipse中的一个项目中的文件javacomplete:只要是java类型的文件都可以补全 什么冲突呢?ycm可以使用vim的omnifunc提供的数据来完成java的自动补全,主要依据在当前打开的java文件的buffer中,执行:set omnifunc返回的结果来确认到底用eclim还是javacomplete提供的补全数据冲突就是如果同时使用这两个插件,那么只要打开java类型的文件,那么就会被自动命令设置成javacomplete的补全,即便是打开eclipse项目中的文件也不会是eclim的补全 解决方法:判断打开的java文件是否是eclipse项目中的文件就行了,判断方法是调用eclim插件的一个方法,当是项目文件时,就不设置javacomplete的补全,如果不是,就设置omnifunc为javacomplete的补全,讲下面的东西粘贴到vimrc中,另外不要在其他地方设置java的omnifunc:12345678910111213141516171819202122232425" vim-javacomplete2" java的omni全能补全(insert模式下ctrl-x-ctrl-o调用),ycm将会自动调用" 与eclim的自动补全冲突,所以先判断当前文件是否是项目文件" 如果不是项目文件才使用vim-javacomplete2进行全能补全function! IsProjectFile() let projectName = eclim#project#util#GetCurrentProjectName() if projectName == '' setlocal omnifunc=javacomplete#Complete endifendfunctionautocmd FileType java call IsProjectFile()" eclim/eclimd" 需要自行安装,不在vim-plug插件管理器管理列表之中" eclimd读取$ECLIPSE_HOME/configuration/config.ini" 还读取~/eclimrc配置文件" 日志级别,日志文件默认在workspace/eclimd.log" 除了默认的info,还有trace,debug,warning,error,offlet g:EclimLogLevel = 'info'" 设置浏览器,firefox,mozilla,opera,iexplorelet g:EclimBrowser = 'firefox'" 让eclim配合ycm实现java等语言的自动补全" 编辑的文件必须是eclipse的一个项目中的文件才会自动补全" 这个变量的作用是(仅举例java文件):set omnifunc=eclim#java#complete#CodeCompletelet g:EclimCompletionMethod = 'omnifunc' javacomplete和eclim都需要自己安装具体如何安装可以去上面提供的网址去查看和下载,不会因为添加了这几行配置就可以实现java的补全了,本文中使用的插件管理器是:vim-plug 另外推荐一份vim的配置,使用简单,配置文件结构清晰,注释明了,很适合不熟悉vim配置的人入手学习: k-vim 再附上自己的一份配置,借鉴了上面的kvim,但后来觉得不舍和自己,就从零开始自己配置了: ri-vim]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>ycm</tag>
        <tag>eclim</tag>
        <tag>javacomplete</tag>
        <tag>youcompleteme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java打印三角和乘法口诀]]></title>
    <url>%2F2016%2F05%2F04%2Fjava%E6%89%93%E5%8D%B0%E4%B8%89%E8%A7%92%E5%92%8C%E4%B9%98%E6%B3%95%E5%8F%A3%E8%AF%80%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425//打印正三角public class helloworld &#123; public static void main(String[] args) &#123; String cell="*"; String space=" "; for (int lines=1; lines&lt;=9; lines++) &#123; // 只有偶数时才打印 if (lines%2==0) &#123; // 打印空格 for (int spaces=1; spaces&lt;=(9-lines)/2; spaces++) &#123; System.out.print(space); &#125; // 打印三角 for (int cells=1; cells&lt;=lines; cells++) &#123; System.out.print(cell); &#125; // 打印空格 for (int spaces=1; spaces&lt;=(9-lines)/2; spaces++) &#123; System.out.print(space); &#125; System.out.println(""); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425// 打印倒三角public class helloworld &#123; public static void main(String[] args) &#123; String cell="*"; String space=" "; for (int lines=9; lines&gt;=1; lines--) &#123; // 只有偶数时才打印 if (lines%2==0) &#123; // 打印空格 for (int spaces=1; spaces&lt;=(9-lines)/2; spaces++) &#123; System.out.print(space); &#125; // 打印三角 for (int cells=1; cells&lt;=lines; cells++) &#123; System.out.print(cell); &#125; // 打印空格 for (int spaces=1; spaces&lt;=(9-lines)/2; spaces++) &#123; System.out.print(space); &#125; System.out.println(""); &#125; &#125; &#125;&#125; 1234567891011// 打印乘法口诀public class helloworld &#123; public static void main(String[] args) &#123; for (int lines=1; lines&lt;=9; lines++) &#123; for (int columns=1; columns&lt;=lines; columns++) &#123; System.out.print(columns+"*"+lines+"="+columns*lines+"\t"); &#125; System.out.println(); &#125; &#125;&#125; 附上图片:]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>乘法口诀</tag>
        <tag>三角</tag>
        <tag>打印</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义bash终端提示符]]></title>
    <url>%2F2016%2F05%2F04%2F%E8%87%AA%E5%AE%9A%E4%B9%89bash%E7%BB%88%E7%AB%AF%E6%8F%90%E7%A4%BA%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[新增第三种，推荐使用 第一种可以提示上一条命令是否出错，如果出错，最左边绿色的笑脸就会变成红色的哭脸，可以显示当前所在路径，当切换到root用户时用户名变为红色，如图所示: 使用方法，将下面的代码，复制粘贴到~/.bashrc中: 12# bash prompt by listenerriPS1="\$(if [[ \$? == 0 ]]; then echo \"\[\e[1;32m\] :)\"; else echo \"\[\e[1;31m\] :(\"; fi) $(if [[ $&#123;EUID&#125; == 0 ]]; then echo "\[\e[1;31m\]\u \[\e[1;32m\]\w \[\e[1;33m\]# &gt; "; else echo "\[\e[1;36m\]\u \[\e[1;32m\]\w \[\e[1;33m\]$ &gt; "; fi)\[\e[0m\]" 第二种与第一种不同的是去掉了最右边的箭头，并且’$’和’#’号会随着用户名的颜色变化(root时为红色) 新增提示git仓库分支名称: 如果当前目录是git仓库的根目录，则以黄色的文字显示当前仓库的分支，否则不显示 如图所示: 使用方法，将下面的代码，复制粘贴到~/.bashrc中: 12# bash prompt by listenerriPS1='$(if [[ $? == 0 ]]; then echo "\[\e[1;32m\]:) "; else echo "\[\e[1;31m\]:( "; fi)$(if [[ $&#123;EUID&#125; == 0 ]]; then echo "\[\e[1;31m\]\u "; else echo "\[\e[1;36m\]\u "; fi)$(echo "\[\e[1;32m\]\w ")$(if [[ -d .git ]]; then echo "\[\e[1;33m\](`git status | head -n 1 | grep -o "\b\S*$"`) "; fi)$(if [[ $&#123;EUID&#125; == 0 ]]; then echo "\[\e[1;31m\]\$ "; else echo "\[\e[1;36m\]\$ "; fi)\[\e[0m\]' arch wiki自定义教程链接：https://wiki.archlinux.org/index.php/Color_Bash_Prompt 第三种时隔两年再次有了新需求，第二种 git 提示获取的方法会导致卡顿，另外还想在提示符上显示时间，但是这样一来就会导致提示符过长，因此有了下面这种换行的： 使用方法，首先在终端中执行以下命令： 1type __git_ps1 如果没有任何输出，或者输出内容不是一个 shell 函数，那么需要下载这个脚本：https://raw.githubusercontent.com/listenerri/dotfiles/master/git-prompt.sh，例如将其放在 HOME 目录下：~/git-prompt.sh，然后在 ~/.bashrc 中添加以下内容执行此脚本： 1source ~/git-prompt.sh __git_ps1 是一个 git 新版提供的函数，旧版本的 git 没有，因此需要下载并加载上面这个脚本，这个脚本是我从系统中提取出来的，未做任何修改。 接着将下面的代码，复制粘贴到 ~/.bashrc 中，并且要在上面那行之后，如果你不需要执行第二部下载那个脚本，则下面的内容放在哪里都行： 123456789101112131415export GIT_PS1_SHOWDIRTYSTATE=1export GIT_PS1_SHOWUNTRACKEDFILES=1PS1=&apos;$(if [[ $? == 0 ]]; then echo -n &quot;\[\e[1;32m\]:)&quot;;else echo -n &quot;\[\e[1;31m\]:(&quot;;fi) \u@\H \D&#123;(%c)&#125;\n\[\e[1;36m\]\w\[\e[1;33m\]$(__git_ps1 &quot; (%s)&quot;) $(if [[ $&#123;EUID&#125; == 0 ]]; then echo -n &quot;\[\e[1;31m\]&quot;;else echo -n &quot;\[\e[1;36m\]&quot;;fi)\$ \[\e[0m\]&apos; 另外需要启用 bash-completion 即 bash 的补全功能，这个一般都会启用的。 推荐下我的 dotfiles 项目：https://github.com/listenerri/dotfiles，里面或许有能让你有其他灵感的内容。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>提示符</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getDuration()获取媒体总长度值为-1]]></title>
    <url>%2F2016%2F05%2F04%2FgetDuration-%E8%8E%B7%E5%8F%96%E5%AA%92%E4%BD%93%E6%80%BB%E9%95%BF%E5%BA%A6%E5%80%BC%E4%B8%BA-1%2F</url>
    <content type="text"><![CDATA[例如VideoView获取视频总长度：在视频播放前获取到的视频总长度都为-1想要在视频播放前获取到总长度的话:1234567891011videoView.setOnPreparedListener(new MyOnPreparedListener());private class MyOnPreparedListener implements OnPreparedListener&#123; @Override public void onPrepared(MediaPlayer mp) &#123; // TODO Auto-generated method stub video.getDuration(); &#125; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>getDuration</tag>
        <tag>视频总长度</tag>
        <tag>videoview</tag>
        <tag>mediaplayer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android获取屏幕像素和密度]]></title>
    <url>%2F2016%2F05%2F04%2Fandroid%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E5%83%8F%E7%B4%A0%E5%92%8C%E5%AF%86%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[用来测试的虚拟机是320*480像素mdpi的总结了以下三种方法 (一)1234Point point =new Point();getWindowManager().getDefaultDisplay().getSize(point);point.x;//(320)point.y;//(480) (二)12345678DisplayMetrics metrics=new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(metrics);metrics.widthPixels;//(320)metrics.heightPixels;//(480)metrics.xdpi;//(160.0)metrics.ydpi;//(160.0)metrics.density;//(1.0)metrics.densityDpi;//(160) (三)1234567DisplayMetrics metrics2=getResources().getDisplayMetrics();metrics2.widthPixels;//(320)metrics2.heightPixels;//(480)metrics2.xdpi;//(160.0)metrics2.ydpi;//(160.0)metrics2.density;//(1.0)metrics2.densityDpi;//(160) 当不是在activity中时，就不能直接用getWindowManager()等方法了，这时可以用Context.getSystemService(Context.WINDOW_SERVICE)方法，其他的类似]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>像素</tag>
        <tag>密度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager相关笔记]]></title>
    <url>%2F2016%2F05%2F04%2FViewPager%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[只有步骤，备用 ViewPager-PagerAdapter布局控件在activity的布局文件中添加控件，控件标记名称为：android.support.v4.view.ViewPager有两个子控件：android.support.v4.view.PagerTitleStrip（会在tab标题的上面，但是不知道怎么随着页面的左右滚动切换，所以暂时不知道如何使用这个控件）android.support.v4.view.PagerTabStrip（每个tab页面的标题，会随着页面的左右滚动切换） 另外还有各个页面的布局文件，和平时的页面写法一样，不说了 获取控件对象并操作在activity中使用findViewById()获取到控件的对象上面说了因为不知道PagerTitleStrip如何自动切换，所以暂时不使用这个控件，并且PagerTabStrip也足够了获取到PagerTabStrip的对象，使用其方法可以设置tab标题指示器的样式获取到ViewPager的对象，主要使用其setAdapter()方法 生成各个页面使用LayoutInflater对象的inflate()方法，加载各个页面的布局文件，获取到各个页面View类型的对象然后把这些获取到的页面对象放到一个ArrayList&lt;View&gt;里面去，等下提供数据给适配器另外，把每个页面的tab标题，放到一个ArrayList&lt;String&gt;里面去，也提供给适配器 适配器写一个类继承PagerAdapter，主要重写PagerAdapter的以下方法：123456789101112131415161718192021222324252627282930313233343536373839//获取页面数量@Overridepublic int getCount() &#123; // TODO Auto-generated method stub return myListViews.size();&#125;//这个不清楚作用，但也必须重写，重写内容如下@Overridepublic boolean isViewFromObject(View arg0, Object arg1) &#123; // TODO Auto-generated method stub return arg0==arg1;&#125;//初始化的作用吧，在这里添加页面到页面容器//父类还有另一个重载的方法(参数不同)，重写任意一个应该都可以//myListViews是上面提到的ArrayList&lt;View&gt;，里面存放View类型的页面的对象@Overridepublic Object instantiateItem(ViewGroup container, int position) &#123; // TODO Auto-generated method stub container.addView(myListViews.get(position)); return myListViews.get(position);&#125;//销毁、去掉页面@Overridepublic void destroyItem(ViewGroup container, int position, Object object) &#123; // TODO Auto-generated method stub container.removeView(myListViews.get(position));&#125;//在这里添加标题数据到标题容器//myListPagerTabs是上面提到的ArrayList&lt;String&gt;，里面存放的是String类型的页面标题@Overridepublic CharSequence getPageTitle(int position) &#123; // TODO Auto-generated method stub return myListPagerTabs.get(position);&#125; 写好适配器类之后就可以使用ViewPager对象的setAdapter()方法绑定上去了 ViewPager-FragmentPagerAdapter基本和ViewPager+PagerAdapter一样，只是需要写几个fragment类和对应的页面的布局文件，每一个页面都是一个fragment，这些学习过fragment相关的知识就会了 不一样的地方：1、上面的ArrayList&lt;Fragment&gt;，里面存放的东西也就是你写的fragment的对象了2、重写父类FragmentPagerAdapter的具体方法1234567891011121314151617//只需要重写下面三个就行了@Overridepublic Fragment getItem(int arg0) &#123; // TODO Auto-generated method stub return myListViews.get(arg0);&#125;@Overridepublic int getCount() &#123; // TODO Auto-generated method stub return myListViews.size();&#125;@Overridepublic CharSequence getPageTitle(int position) &#123; // TODO Auto-generated method stub return myListTabs.get(position);&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>ViewPager</tag>
        <tag>PagerAdapter</tag>
        <tag>FragmentPagerAdapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImageSwitcher和TextSwitcher使用笔记]]></title>
    <url>%2F2016%2F05%2F04%2FImageSwitcher%E5%92%8CTextSwitcher%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[只有步骤，记录，备忘只举ImageSwitcher的例子，TextSwitcher基本一样 1、布局文件中添加ImageSwitcher控件2、activity中findViewById()获取到ImageSwitcher对象3、需要一个工厂来制造需要显示的ImageView，需要实现ViewFactory接口，并重写接口的makeView()方法，这里使用隐式：12345678imageSwitcher.setFactory(new ViewFactory()&#123; public View makeView()&#123; //1、new一个ImageView //2、为ImageView设置一系列属性 //3、return加工好的ImageView对象 &#125; &#125;) 4、使用ImageSwitcher对象的setInAnimation()和setOutAnimation()设置动画效果(可选)5、使用ImageSwitcher对象setImageResource()切换要显示的图片 结束 TextSwitcher的方法和上面一样，都需要实现ViewFactory接口并重写makeView()方法，在其中new出TextView对象并设置属性然后返回，最后切换视图的方法是setText()]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>ImageSwitcher</tag>
        <tag>TextSwitcher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些关于Fragment的笔记]]></title>
    <url>%2F2016%2F05%2F04%2F%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8EFragment%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[注意:android3.0以及之后的版本支持fragment技术，低版本要想使用fragment技术需要android.support.v4.app包获取fragmentManager的方法不同：3.0以下：getSupportFragmentManager()3.0以上：getFragmentManager() fragment以及activity生命周期附上图片一张: 学习fragment时碰到的几个名词：FragmentActivity：一个android.support.v4.app中的一个继承了Activity的类，如果你要在3.0以下使用fragment就需要让页面继承FragmentActivity而不是Activity，FragmentActivity中包含了3.0以下操作fragment的方法，使用方法同3.0以上一样，只是获取Manager的方法不同 FragmentPagerAdapter可以作为ViewPager的适配器 ListFragment列表样式， 自带一个默认的包含ListView控件的布局文件，无需手动重写onCreateView()使用inflat()方法加载自定义布局文件，只需要重写onCreate()方法，在其中用setListAdapter()方法绑定适配器，在绑定适配器的时候给item设置一个布局文件就行了。若想修改ListView，可以在onCreateView(LayoutInflater, ViewGroup, Bundle)中进行修改，需要注意在自定义的ListFragment对应的布局文件中，必须指定一个 android:id 为 “@android:id/list” 的ListView控件!当然，用户也可以在ListFragment对应的布局中包含其它的控件。显示：在主activity中使用new关键字获取对象的引用 DialogFragmentAndroid官方推荐使用DialogFragment创建对话框，可以避免屏幕旋转导致的问题。重写onCreateView()则用定义的xml布局文件展示Dialog或者重写onCreateDialog()则需要利用AlertDialog或者Dialog创建出Dialog，在主activity中使用DialogFragment对象的show()方法，显示对话框。显示：在主activity中使用new关键字获取对象的引用 FragmentTabHost用来代替已废弃的TabHost，个人感觉和前两个ListFragment以及DialogFragment有些不同，你可以把FragmentTabHost看作是一个普通控件正常使用，也就是个TabHost使用方法一样。需要主页面的布局文件中添加控件，然后通过findViewById()来获取控件，需要注意的是布局文件中控件使用的标记名称是&lt;android.support.v4.app.FragmentTabHost&gt;，id：@android:id/tabhost(id可以随便写)需要包含三个子标记(经过测试，只用一个id：tabhost(也就是上面那个控件)和一个id：realtabconten也可以(真正的容器FrameLayout)：1、Tab标签容器TabWidget，id：@android:id/tabs(id必须是这个)2、Tab内容容器FrameLayout，id：@android:id/tabcontent(id必须是这个)，注意：这里属性中宽高皆为0dp3、Tab内容容器FrameLayout，id：@+id/RealTabContent(id可以随便写)，注意：这个才是真正的内容容器 FragmentTabHost可以在布局文件中定义标签容器在内容容器的下面，调动RealTabContent的位置到tabhost的上面就行了，此时RealTabContent的属性最好是：1234android:id=&quot;@+id/RealTabContent&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;0dp&quot;android:layout_weight=&quot;1&quot; 相关链接：《关于FragmentTabHost中TabWidget不能移到屏幕下面的Bug》 然后，在主activity中使用findViewById()获取控件后，必须先使用使用控件对象的setup()方法之后才能用addTab()方法来添加标签，这点和TabHost一样，不过使用的具体方法有区别，FragmentTabHost应该用：12345678910111213//setup():setup(Context context, FragmentManager manager, int containerId)//参数解释：//context：上下文//manager：使用getSupportFragmentManager()//containerId:容器id//×××××××××××××××××××××××××××××××××××××××××//add()addTab(TabSpec arg0, Class&lt;?&gt; arg1, Bundle arg2)//参数解释：//arg0：FragmentTabHost对象的newTabSpec()方法获取，并且需要使用获取到的TabSpec对象的setIndicator()方法设置标题属性//arg1：具体的fragment类(不是new出来的)//arg2：null即可 详细的FragmentHostTab与HostTab之间的区别请看：TabHost 和 FragmentTabHost 笼统的Fragment的使用： 只是单纯的Fragment，不含：ListFragment，DialogFragment，FragmentTabHost等，不过基本一样 fragment继承类和其布局文件一个fragment由一个布局文件和一个继承了fragment的子类组成，由这个子类处理布局文件产生的的各种事件 使用时需要让子类关联到其布局文件，关联方法：1、重写fragment类的onCreateView()生命周期方法，2、然后在onCreateView()中调用方法的传入参数inflater的inflate()方法并返回获得的View对象来加载对应的布局文件 当fragment继承类和其布局文件关联后就可以显示到页面上了，显示方法： 注意：并不是直接把fragment的布局文件或其中的控件显示到页面上而是在主页面的布局文件中使用fragment标记，要注意标记的android:name属性，由这个属性的值关联到fragment继承类，进而通过fragment继承类加载到相应的fragment布局文件 具体显示到页面上有两种方式：静态也就是直接把一个或多个fragment显示到页面上，这样做就相当与把一个fragment看作是一个普通控件(由一个或多个控件组成的控件)来添加到页面上只不过这个“控件“(fragment)产生的事件由对应的继承了fragment的类处理，而不是像平时那样在主页面中为某个控件findViewById然后添加监听器，这一步写在了继承了fragment的类中 具体步骤：1、fragment的布局文件，就像平时的布局文件一样2、继承了fragment的类，重写fragment类的onCreateView()生命周期方法，在onCreateView()中调用方法的传入参数inflater的inflate()方法并返回获得的View对象来加载对应的布局文件3、主页面布局文件中依次写入需要显示的fragment标记，通过标记的name属性关联到继承了fragment的类 动态动态的意思就是可以在不切换activity的前提下，通过某个点击事件，在同一个区域显示不同的fragment要实现这个效果，需要一个FragmentManager管理类和一个FragmentTransaction事务类，还需要一个承载不同fragment的容器，一般是在主页面中使用一个FrameLayout帧布局来充当这个容器，也就是让一个个fragment在FrameLayout中显示，但不需要在FrameLayout内写fragment子标记如何切换不同的fragment的方法由事务类操作实现 具体步骤：前两步与静态一样，写几个fragment的布局文件和类并一一对应的关联起来3、在主页面的布局文件中，需要动态显示fragment的地方，放一个FrameLayout帧布局4、在主页面的activity类中，通过getFragmentManager()方法获取到FragmentManager并通过FragmentManager的beginTransaction()开始并获取到一个事务FragmentTransaction5、通过获取到的FragmentTransaction对象的就可以控制fragment显示显示或隐藏到FrameLayout帧布局 部分控制方法有：add(),hide(),remove(),replace(),show()等，这些方法都需要fragment对象，也就是要显示的fragment通过addToBackStack()方法可以将当前fragment添加到FragmentManager的回退栈，当点击返回键时可以恢复状态当操作完成后还必须使用commit()方法提交，提交之后才会真正生效 总结：个人表示刚接触fragment，不容易懂或者说不容易记的地方是fragment的类和对应的布局文件的关联，以及如何显示到页面 大概记忆顺序(中间的连接符可以理解为关联、对应)：静态：一个主页面布局文件中的&lt;fragment&gt;标记——一个fragment的继承类——一个fragment布局文件动态：一个主页面布局文件中的&lt;FrameLayout&gt;标记——承载多个fragment的继承类——各自对应的多个fragment布局文件 虽然理解时的顺序是这样的，但实际写代码的时候的顺序确实反过来的]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>FragmentPagerAdapter</tag>
        <tag>fragment</tag>
        <tag>FragmentActivity</tag>
        <tag>ListFragment</tag>
        <tag>DialogFragment</tag>
        <tag>FragmentTabHost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView的Iterm无法点击]]></title>
    <url>%2F2016%2F05%2F04%2FListView%E7%9A%84Iterm%E6%97%A0%E6%B3%95%E7%82%B9%E5%87%BB%2F</url>
    <content type="text"><![CDATA[当listview中同时出现Button或者ImageButton时，只有item中的Button或ImageButton能够获取焦点(能点击)，而整个item无法获取焦点(无法点击) 原因：因为ImageButton在初始化时把自己设置成setFocusable(true),这样，listView就获取不到焦点。代码：1234public ImageButton(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); setFocusable(true);&#125; 这里还要强调一下：当xml中注册多个 View的时候，当我们点击按键之后，Android会先判定哪个View setFocusable(true)设置焦点了,如果都设置了，那么Android 会默认响应在xml中第一个注册的view ,而不是两个都会响应。 所以在item中使用Button或ImageButton时需要留意这个1setFocusable(true) 方法、如果item无法响应点击，可以尝试给Button或ImageButton设置1setFocusable(false)]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>listview</tag>
        <tag>iterm</tag>
        <tag>无法点击</tag>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言中的指针]]></title>
    <url>%2F2016%2F05%2F04%2Fc%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[1、直接使用指针的表达式，表示使用指针代表的内存地址. (指针存放的数据为内存地址,如同int型变量存放的数据为整数) 2、在指针表达式前加上符号:*，表示使用指针指向的值，也就是指针所代表的内存地址中存储的值. (*也叫取值运算符或间接运算符,与之对应&amp;为地址运算符,放于正常变量之前可获得变量在内存中的地址,也就是获得一个指向这个变量的指针) 3、指针也有数据类型 4、假设int *opt，那么opt++表示指向下一个整数位置的内存地址，而不是让opt所代表的内存地址在数值上+1； 示例：12345678int foo1=10;int *foo2;foo2=&amp;foo1;printf("*foo2:%d\n",*foo2);printf("foo2:%d\n",foo2);*foo2=11;printf("*foo2:%d\n",*foo2);printf("foo2:%d\n",foo2); 执行结果：1234*foo2:10foo2:559162276*foo2:11foo2:559162276 解释：第一行，声明一个整型的变量foo1，其值为10第二行，声明一个指针foo2，声明指针要使用*符号第三行，获取变量foo1的内存地址，获取变量的地址要使用&amp;符号，并将内存地址赋给指针foo2，也就是让foo2代表(指向)foo1的值在内存中的存储位置第四行，输出*foo2，也就是输出指针foo2所代表的内存地址中存储的值第五行，输出foo2，也就是输出指针foo2所代表的内存地址第六行，让指针foo2所代表的内存地址中存储的值，变为11(注意这里并没有修改指针foo2所代表的内存地址)第七行，输出*foo2，也就是输出指针foo2所代表的内存地址中存储的值第八行，输出foo2，也就是输出指针foo2所代表的内存地址 注意执行结果，foo2所代表的内存地址中的值，通过*foo2=11;被修改后其内存地址并未发生改变，只是改变了该内存地址中存储的值，而指针foo2依然代表原来的内存地址 如有错误请指出]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言修饰符static,extern,#define,const]]></title>
    <url>%2F2016%2F05%2F04%2Fc%E8%AF%AD%E8%A8%80%E4%BF%AE%E9%A5%B0%E7%AC%A6static-extern-define-const%2F</url>
    <content type="text"><![CDATA[写的比较乱，因为是刚开始学C，没有一个系统的概念，都是想到什么，测试到什么就添加什么，仅供参考而且可能会有错误的地方，如果有请指出 static：静态作用域以及声明方法：1、在函数中声明则仅作用于该函数123void fun()&#123; static int i;&#125; 2、在函数外声明则作用于从声明开始到文件末尾123static int i;void fun()&#123;&#125; #extern：引用(其他c文件) ##作用域以及声明方法：1、可以声明变量或函数，并且不必变量初始化或函数定义实现，即可使用，因为引用变量或函数声明时，会同时引用被引用文件内的初始化语句2、被引用的变量或函数不能被static修饰3、相当与引用(复制？)其他文件中的声明和定义/初始化语句到本文件的声明位置4、在本文件使用extern声明变量或函数时，变量或函数名以及函数返回类型和函数参数列表应与要引用的变量或方法一致(经测试，变量不一致时好像类似声明的指针类型变量，方法暂未测试)5、在函数内声明则类似局部变量，作用域仅在本函数，在函数外，作用域从声明处到文件末尾6、如果你是学习C语言的新手，而且暂时只是在使用文本编辑器在写C程序，那么需要注意，在编译有extern语句的C文件时，应该与被引用的文件一起编译(笔者表示在开始时一直在单独编译一个文件所以一直编译报错)比如下面例子的a1.c和b.c，或者a2.c和b.c，编译的时候应该这样：1234gcc a1.c b.c#或者gcc a2.c b.c#这样编译器才能找到被extern的变量或函数 不要将a1.c和a2.c以及b.c这三个一起编译，应该将a1.c和b.c一起编译，或者a2.c和b.c一起编译，这是两个例子1234567891011121314151617181920212223242526272829303132333435363738394041/* a1.c *//* 在文件开始声明(将类似全局变量) */#include &lt;stdio.h&gt;extern int test1;extern void testFun1();extern int testFun2(int temp);int main()&#123; int temp=20; testFun1(); testFun2(temp); return 0;&#125;/*####################*//* a2.c *//* 在函数内部声明(将类似局部变量) */#include &lt;stdio.h&gt;void myFun1();int main()&#123; myFun1(); return 0;&#125;void myFun1()&#123; extern int test1; extern void testFun1(); extern int testFun2(int temp); int temp=30; testFun1(); testFun2(temp);&#125;/*####################*//* b.c */#include &lt;stdio.h&gt;int test1=10;void testFun1()&#123; printf("test1 in testFun1():%d\n",test1);&#125;int testFun2(int temp)&#123; test1=temp; printf("test1 in testFun2():%d\n",test1); return 0;&#125; “#define”：常量作用域以及声明方法：1、在函数内声明则作用域仅在本函数，在函数外，作用域从声明处到文件末尾，不过大多在文件头，include语句下声明2、定义后无法再次对其赋值3、声明时末尾不能使用分号结束，不能声明数据类型(也就是没有数据类型)，不能有等号12345678910111213141516171819#include &lt;stdio.h&gt;#define a 1int main()&#123; printf("a:%d\n",a); return 0;&#125;/* 另一个例子 */#include &lt;stdio.h&gt;void test1();int a;int main()&#123; test1(); printf("a:%d\n",a); return 0;&#125;void test1()&#123; #define a 1 printf("a:%d\n",a);&#125; const：常量作用域以及声明方法：1、在函数内声明则作用域仅在本函数，在函数外，作用域从声明处到文件末尾，不过大多在文件头，include语句下声明2、定义后无法再次对其赋值3、需要指定数据类型，并使用等号为其赋值，否则，则只能有默认值(因为在程序其他位置无法再次对其赋值)123456#include &lt;stdio.h&gt;const int a=10;int main()&#123; printf("a:%d\n",a); return 0;&#125;]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>static</tag>
        <tag>extern</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux创建wifi热点]]></title>
    <url>%2F2016%2F05%2F04%2Flinux%E5%88%9B%E5%BB%BAwifi%E7%83%AD%E7%82%B9%2F</url>
    <content type="text"><![CDATA[本文中使用的系统是archlinux,其他系统应该只有安装方法不同 安装123yaourt -S archlinuxcn/create_ap#或者：yaourt -S aur/create_ap 终端下创建热点首先执行ifconfig命令查看网卡端口下面是我的：12345678910ap0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 ...................enp4s0f2: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu ...................lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 ...................ppp0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt; ...................wlp3s0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 ................... 解释： ap0：是我用create_ap命令创建出来的ap enp4s0f2：有线网卡 lo：暂时不清楚 ppp0：这个用ADSL上网的话就会出现 wlp3s0：无线网卡 当你没有使用create_ap创建ap时，ifconfig命令不会返回ap0，当你没有使用ADSL上网时(路由器LAN口直连)不会有ppp0 路由器LAN口直连所以，如果你没有使用ADSL上网时：12创建一个名字是wifiName，密码是wifiPasswd的热点sudo create_ap wlp3s0 enp4s0f2 wifiName wifiPasswd ADSL如果你用的是ADSL上网的:12创建一个名字是wifiName，密码是wifiPasswd的热点sudo create_ap wlp3s0 ppp0 wifiName wifiPasswd wifi如果你使用wifi上网的:12创建一个名字是wifiName，密码是wifiPasswd的热点sudo create_ap wlp3s0 wlp3s0 wifiName wifiPasswd 创建没有密码的热点12创建一个名字是wifiName，没有密码的热点sudo create_ap wlp3s0 wlp3s0 wifiName 也就是不写密码就行了 上面几种方法根据自己的情况任选一种，创建好之后执行ifconfig命令就会发现多出来了一个ap0的接口信息 使用systemctl创建后台热点(服务)安装create_ap时，会自动生成一个wifi.service文件到/usr/lib/systemd/system目录下里面也是调用了create_ap命令来创建热点，可以打开这个文件，按需编辑，编辑好内容之后，就可执行systemctl来启动创建热点的服务了：1234#启动systemctl start wifi.service#停止systemctl stop wifi.service 也可以开机自动运行：1234#允许开机自动执行systemctl enable wifi.service#禁止开机自动执行systemctl disable wifi.service 可以修改wifi.service文件为你想要的文件名，比如修改成create_ap.service，那么启动服务时的命令就要改成：1234#启动systemctl start create_ap.service#停止systemctl stop create_ap.service 开机自动启动同上]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>wifi</tag>
        <tag>热点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不通过GooglePlay下载其中的app]]></title>
    <url>%2F2016%2F05%2F04%2F%E4%B8%8D%E9%80%9A%E8%BF%87GooglePlay%E4%B8%8B%E8%BD%BD%E5%85%B6%E4%B8%AD%E7%9A%84app%2F</url>
    <content type="text"><![CDATA[非常简单的一个方法：飞机直达进入上面的网址,如果你进不去,那就想想自己为什么进不了google,里面就一个输入框,把Google play里你想下的apk的网页链接填进去点下面的按钮,马上就出来一个绿色按钮,点击即可直接用浏览器下载这个apk 转自：大侠阿木]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>GooglePlay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中获取一个子字符串中出现的次数]]></title>
    <url>%2F2016%2F05%2F04%2Fjava%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[假设要得到字符串B在字符串A中出现的次数：1234567891011//假设字符串A和B已声明并赋值int count=0;int fromIndex=0;while(fromIndex!=-1)&#123; fromIndex=A.indexOf(B,fromIndex); if(fromIndex!=-1)&#123; fromIndex+=B.length();; count++; &#125;&#125;System.out.println(count); 主要用到的就是一个字符串对象的indexOf()方法]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>字符串</tag>
        <tag>次数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从arraylist生成String[]数组]]></title>
    <url>%2F2016%2F05%2F04%2F%E4%BB%8Earraylist%E7%94%9F%E6%88%90String-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[在使用数组的时候要留意,一定要先完整的创建好数组,再对其操作 1234String[] commands=null;commands = new String[arrayListCommand.size()];commands = (String[]) arrayListCommand.toArray(commands);//可以成功cast到String数组 123456String[] commands=null;commands = (String[]) arrayListCommand.toArray();//不能cast到String数组//这是因为第一句只是声明了commands变量,//此时它并没有在内存获得存储数据的位置,//因此无法直接为其赋值]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>toArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过ip地址连接virtualbox虚拟机android-x86]]></title>
    <url>%2F2016%2F05%2F04%2F%E9%80%9A%E8%BF%87ip%E5%9C%B0%E5%9D%80%E8%BF%9E%E6%8E%A5virtualbox%E8%99%9A%E6%8B%9F%E6%9C%BAandroid-x86%2F</url>
    <content type="text"><![CDATA[只要能通过ip地址找到虚拟机中的系统，那么就可以干很多事，比如：adb调试，或者使用nc命令传输一些文件或文件夹，等等。。下面以adb连接virtualbox中的android-x86进行调试为例： 安装android-x86首先你要安装好android-x86，这个就不多说了，网上很多教程不过值得一提的是，在安装好之后，进入系统时，如果没有点技巧会卡在欢迎界面，安装时没有截图，就不上图了解决方法是：在欢迎界面，状态栏下面开始，依次：左上-右上-右下-左下用鼠标点击一遍，就会自动跳过欢迎界面了 查看android-x86的ip地址本例中使用的是virtualbox默认的网络配置进入android-x86系统，打开终端模拟器接着输入“su”命令获取root权限，会弹出提示，自己看着选获取root后，终端提示符会变成”#“输入”netstat“命令，会打印出一些网络配置和ip地址信息，本例中的android-x86的ip地址为：”10.0.2.15” 记住这个ip，后面会用到 配置虚拟机系统的网络的端口转发功能在vbox中在要配置的系统：android-x86上右键，选择设置在出现的设置窗口的左侧菜单组中点击网络项，其他的不用管，直接接着点击端口转发按钮：接着在新窗口中点击右侧”+“按钮，添加一条规则： 其中主机ip最好填本机host，端口随便，不过如果是adb连接的话，最好用5555，因为adb connect默认是5555端口子系统ip，就填第二步中使用netstat得到的ip地址，端口随意 配置好之后点确定，重启虚拟机中的android-x86 adb连接android-x86系统启动你的android-x86后，打开终端模拟器，输入：1234susetprop service.adb.tcp.port 5555stop adbdstart adbd 命令解释：su：获取root权限，要执行下面的命令必须要root身份，否则无效setprop…：设置一个安卓系统的adb配置，即使用网络进行adb调试stop adbd和start adbd：重启adb服务 这样android-x86就配置ok了，在你的主机(非虚拟机)中，打开一个命令行(cmd/terminal)，输入：1adb connect 127.0.0.1 连接成功时会提示：1connected to 127.0.0.1:5555 接着输入adb devices查看已连接设备：12List of devices attached 127.0.0.1:5555 device 注意”127.0.0.1:5555“后面的提示，如果是device，则是链接成功，否则如果是offline就是没有连接上 最终输入：adb shell进入android-x86终端控制，这条命令成功就意味着绝对是成功了下面是这几步的图： 总结：主要使用了virtualbox的端口转发功能，这个功能会把所有访问本机的某个设定好的端口的数据全部重定向到虚拟机系统的设置好的端口这样就实现了对本机5555端口(本例)的访问，其实访问的是android-x86的5555端口]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>virtualbox</tag>
        <tag>adb</tag>
        <tag>android-x86</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用XMLReader接口解析XML]]></title>
    <url>%2F2016%2F05%2F04%2F%E4%BD%BF%E7%94%A8XMLReader%E6%8E%A5%E5%8F%A3%E8%A7%A3%E6%9E%90XML%2F</url>
    <content type="text"><![CDATA[如何获取XMLReader接口从JDK文档来看，有两种方法： 使用SAXParserFactory+SAXParser[以下简称a方法]1XMLReader aaa=SAXParserFactory.newInstance().newSAXParser().getXMLReader(); 使用XMLReaderFactory[以下简称b方法]1XMLReader bbb=XMLReaderFactory.createXMLReader(); 两种方法不同之处在JDK文档a方法中SAXParser类的getXMLReader()方法的注释: 返回由此类的实现封装的 XMLReader。 SAXParser类又是由SAXParserFactory的newSAXParser()方法创建而来，其注释： 使用当前配置的工厂参数创建 SAXParser 的一个新实例。 而在JDK文档中b方法使用XMLReaderFactory类的createXMLReader()方法有这样一段注释： 尝试从系统默认值创建一个 XMLReader。 可以发现，想要获取XMLReader，是需要环境支持的(能力有限，无法分析出具体是哪些环境，相询JDK文档的XMLReaderFactory类)，在a方法中则是从由SAXParserFactory+SAXParser设置好的环境中创建XMLReader，其中主要环境设置工作由SAXParserFactory来做。而在b方法中会直接使用系统默认的环境，但这个环境却不一定可以正常使用，除非你手动设置其创建环境(笔者表示还不会) SAXParserFactory和SAXParser两个抽象类主要作用a方法中的SAXParserFactory在笔者看来，起主要作用应该就是根据当前系统环境，设置一个可以正常创建出XMLReader解析器的环境，并提供创建SAXParser类对象的方法。SAXParser的主要作用应该是根据SAXParserFactory工厂类提供的环境来创建XMLReader解析器，并且它还有一些重要的作用： 获取SAXParser类的实例之后，将可以从各种输入源解析 XML。这些输入源为 InputStream、File、URL 和 SAX InputSource。它包含一系列的parse(,)方法也即是说SAXParser还定义了将各种源解析为XML并传递给继承自DefaultHandler或HandlerBase(不推荐使用)的对象，以提供给XMLReader解析器来解析 那么如何获取这两个类呢上文提到这两个类都是抽象类，虽然这两个类都有构造方法，但却都是受保护的protected修饰的并且抽象类也都是无法直接实例化的，也就是无法通过new关键字来获取类的对象 其突破口就在SAXParserFactory抽象类中的，这个类定义了两个静态方法：12newInstance() newInstance(String factoryClassName, ClassLoader classLoader) 从名字就可以看出来是用来获取SAXParserFactory的实例化对象的，有了SAXParserFactory的实例化对象就可以设置一些环境，或让其自动设置，然后就可以用它来创建SAXParser抽象类的对象，使用newSAXParser()方法即可 newSAXParser()这个方法不是静态方法，所以只能先通过newInstance()静态方法来实例化出SAXParserFactory，然后才能使用SAXParserFactory的非静态方法newSAXParser()来获得SAXParser的对象，因为它们都是抽象类！ 获得了SAXParser的对象后就可以使用其getXMLReader()方法来获取XMLReader解析器了 另外，XMLReader虽然名为解析器，但具体的解析工作却不是由它来做的，它只是一个框架，具体的解析工作由继承自DefaultHandler或HandlerBase(不推荐使用)的对象来做:XMLReader的setContentHandler(DefaultHandler的子类的对象);DefaultHandler类可用作 SAX2 应用程序的有用基类：它提供四个核心 SAX2 处理程序类中的所有回调的默认实现,也就是它实现了以下四个接口：EntityResolverDTDHandlerContentHandlerErrorHandler]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
        <tag>xmlReader</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[U盘+GRUB2引导PE或linux镜像]]></title>
    <url>%2F2016%2F05%2F04%2FU%E7%9B%98-GRUB2%E5%BC%95%E5%AF%BCPE%E6%88%96linux%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[详细看原文：链接 安装grub2到u盘：1sudo grub-install -v --target=i386-pc --boot-directory=/run/media/root/EXT4 /dev/sdb 注意上面的参数:–target,根据需要替换,参数值可以到/usr/lib/grub/下查看,每一个目录都可以作为参数值–boot-directory,此参数的含义自行查看grub-install的help具体看man grub-install使用方法 grub2间接引导WinPEU盘上建立WXPE目录，将WinPE文件放置入内：目前网络上的WinPE到处都是，各种版本其实都差不多，主要需要如下5个文件：LDRXPE NTCOM PE SETUPLDR.BIN WINPE.IS_ 大致过程是：LDRXPE调用NTCOM和SETUPLDR.BIN读取PE找到WINPE.IS_镜像，加载WinPE。 修改grub.cfg，加入winpe引导项：1234567menuentry 'LDRXPE for WinCE (on /usb/fairy)'&#123;insmod part_msdosinsmod fatset root='hd0,msdos1'search --no-floppy --fs-uuid --set=root 696C-0B1Cntldr /WXPE/LDRXPE&#125; 说明：此处的696C-0B1C为U盘分区uuid，其实这一句也可以不要，因为上面已经set root了，主要为了双保险。 这里的关键是：ntldr /WXPE/LDRXPE，而不是chainloader或者linux，我用后者尝试了一周都不得成功，最后才发现了可以直接用ntldr命令，强大啊！！ grub2直接引导WinPE转自：Librehat’s Blog GRUB2不支持GRUB4DOS那样的map操作来引导ISO文件，是长期困扰我的一个问题，在今天之前，我都很傻地用grub2引导grub4dos然后引导Windows PE……直到我膝盖中了一箭，看到这个帖子。下面好好整理了一下，希望本文也能帮助你彻底从GRUB4DOS升级换代到GRUB2！ 关于在U盘上安装GRUB2引导器的教程请自行Google，太多这类文章和Wiki了。下面开始GRUB2引导ISO文件（特别是Windows PE和Windows安装光盘这种）的正题。 首先下载最新版的：Syslinux，解开压缩包，memdisk文件夹下面有一个memdisk文件（没有任何扩展名），把memdisk文件复制到U盘boot文件夹下（随便你放在哪，这里我是放倒boot这个文件夹下）。 编辑你U盘GRUB2的配置文件（一般是U盘/grub2/grub.cfg），在启动项那个区域添加以下几行。12345678menuentry 'Boot Windows 8 PE ISO'&#123; set root='(hd0,msdos1)' echo 'Loading Memdisk...' #insmod memdisk linux16 /boot/memdisk iso raw echo 'Loading ISO...' initrd16 /boot/Win8PE.iso&#125; 好了，其实关键就是memdisk后面的raw参数！感兴趣的自己看Syslinux的Wiki，我这段代码引导的是U盘boot文件夹下的Win8PE.iso，请修改成你自己的具体情况。 借助MEMDISK（几十KB的文件），GRUB2就能加载几乎任意的镜像文件（ISO、IMG等）了，相当于是「虚拟光驱」的作用？不过引导速度比GRUB4DOS稍微慢一点。 不需要insmod memdisk这一句，因为用的是Syslinux的MEMDISK而不是GRUB2的memdisk模块。为了规范，syslinux的MEMDISK全部大写，以便和GRUB2的memdisk模块区分开来。两者重名了，刚查了一下，GRUB2的memdisk是用来读取core.img的。和syslinux的MEMDISK完全不同……详见http://wiki.xtronics.com/index.php/Grub2_howto grub2间接引导Archlinux镜像解压Archlinux最新安装镜像：archlinux-2012.11.01-dual.iso，复制其中的arch目录到U盘。 EFI isolinux loader这三个目录不需要。 精简arch目录：因为我要用的是32位的，而不用64位的所以删掉64位的相关目录和文件，包括： 删除arch/x86_64目录；删除arch/boot目录下的：memtest memtest.COPYING syslinux x86_64修改arch/aitab，注释掉x86_64的两行。 当然你的空间足够大，这些都可以不做。 修改grub.cfg，加入arch引导项：12345678menuentry 'archlinux-2012.11.01-setup (on /usb/fairy)'&#123;insmod part_msdosinsmod fatset root='hd0,msdos1'search --no-floppy --fs-uuid --set=root 696C-0B1Clinux/arch/boot/i686/vmlinuz archisobasedir=arch archisolabel=fairyinitrd/arch/boot/i686/archiso.img&#125; 说明：同上此处的696C-0B1C为U盘分区uuid，其实这一句也可以不要，因为上面已经set root了，主要为了双保险。 这里的关键是：archisobasedir=arch archisolabel=fairy ，这里的fairy是U盘的卷标，少了这句是不得成功的。 grub2直接引导Archlinux镜像x86_64：1234567menuentry "Archlinux-2013.05.01-dual.iso" --class iso &#123; set isofile="/archives/archlinux-2013.05.01-dual.iso" set partition="6" loopback loop (hd0,$partition)/$isofile linux (loop)/arch/boot/x86_64/vmlinuz archisolabel=ARCH_201305 img_dev=/dev/sda$partition img_loop=$isofile earlymodules=loop initrd (loop)/arch/boot/x86_64/archiso.img&#125; i6861234567menuentry "Archlinux-2013.05.01-dual.iso" --class iso &#123; set isofile="/archives/archlinux-2013.05.01-dual.iso" set partition="6" loopback loop (hd0,$partition)/$isofile linux (loop)/arch/boot/i686/vmlinuz archisolabel=ARCH_201305 img_dev=/dev/sda$partition img_loop=$isofile earlymodules=loop initrd (loop)/arch/boot/i686/archiso.img&#125; grub2引导Ubuntu liveCD复制ubuntu-12.04-desktop-i386.iso到U盘根目录，当然为了根目录干净放到iso或者其他目录也可以，以下做对应修改。 修改grub.cfg，加入ubuntu引导项：123456789menuentry 'ubuntu-12.04-desktop-i386.iso' &#123;insmod fatinsmod loopbackinsmod iso9660loopback loop (hd0,1)/ubuntu-12.04-desktop-i386.isoset root=(loop)linux /casper/vmlinuz boot=casper iso-scan/filename=/ubuntu-12.04-desktop-i386.iso noprompt noeject locale=zh_CN.UTF-8 --initrd /casper/initrd.lz&#125; 说明： hd0,1 指得是U盘第一分区，我这里只有一个分区。 iso-scan/filename=/ubuntu-12.04-desktop-i386.iso这里要注意ubuntu前面的“/”，如果找不到文件会出现can’t open /dev/sr0错误。 locale=zh_CN.UTF-8 是设置中文环境，很多人引导成功却是英文环境的，加上这条就可以了。 安装ubuntu时需要卸载ubuntu的iso镜像顺利引导,进入 ubuntu的live cd桌面,桌面上有 install ubuntu的字样,和光盘启动时的样子一模一样，不过与光盘安装有一点不同，也很重要，就是之前我们挂载了iso设备，现在要卸载它，不然会出现分区表问题。在终端里输入：1sudo umount -l /isodevice grub直接启动xiaopanOS假如xiaopanOS.iso 在C盘根目录，那就是sda1，根据自己实际更改把xiaopanOS.iso 里的tce文件夹解压到C盘根目录,也就是C:\tce12345set iso='(hd0,msdos1)/xiaopanOS-0.3.2.iso'loopback loop $isolinux (loop)/boot/vmlinuz quiet waitusb=5 tce=sda1/tceinitrd (loop)/boot/tinycore.gzboot]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>grub</tag>
        <tag>u盘</tag>
        <tag>iso</tag>
        <tag>镜像</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[archlinux+xfce4+lightdm+uefi个人安装记录]]></title>
    <url>%2F2016%2F05%2F04%2Farchlinux-xfce4-lightdm-uefi%E4%B8%AA%E4%BA%BA%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[本文篇幅较长，最好通过文章内容上面的目录进行查看，否则很容易迷失在一个又一个的步骤中 前言：在中文+英文arch-wiki的指导下，大概经过了将近十次的格式化+重装，终于满意了，这个过程中也了解了linux新的系统服务管理机制:systemd(systemclt)，不说废话了，开始安装步骤 折腾日期为:2015-4-28到2015-5-??arch更新迅速，如果要参考本文，自行留意日期，也可以自己去arch-wiki去看官方教程：arch-wiki-Beginners’guide&gt;本文将简略的说一下步骤，主要说我在安装过程中出现的问题！所以如果你是对大概的linux命令都不熟悉的新手，本文也许不适合你，你应该先去看arch-wiki，然后再来这里看 网络配置 安装arch，是不能没有网络的，毕竟官方提供的是最小化安装镜像，只有核心linux和官方修改配置的脚本，其他的都要靠联网下载安装网络配置这一步骤需要进行两次！第一次是刚刚启动安装镜像时，这一次的网络配置生效区域是安装镜像所在的系统，而非你安装到硬盘上的系统，这个配置将会随着安装镜像系统的退出而清除！第二次是使用arch-chroot命令后切换到到真实的，安装在了硬盘上的系统！这第二次的网络配置，将会写到你将来要用的系统所在的硬盘分区上的配置文件中，所以只要你以后不再修改，那么它的生效区域是永久的！自行理解上文所提到的安装镜像所在的系统和真实系统的区别！这个不好说，说不清 arch官方推荐使用他们自己的netctl来作为网络管理工具,但是经过使用后我还是推荐使用networkmanager来作为管理工具,因为networkmanager不论在命令行还是图形界面都有简单的使用方法！ 使用netctl如果你使用netctl那么将会有无线和有线两种大的联网方式，其中又各自细分出了几种不同的联网方式，第一次配置安装镜像所在的系统时你只需要选择其中一种，让电脑能正常联网就行了！第二次为真实系统配置时再自行选择配置几种。具体配置方法看arch-wiki-Beginners’guide这里不多说！按照官方教程会启用dhcpcd守护进程、这会导致系统系统的DNS每次开机都被dhcpcd替换为自动获取的DNS配置文件：/etc/resolv.conf如果按照官方教程配置netctl后，出现了能ping通域名(如：ping t.cn)，但使用pacman -Syy却无法联网时那么你就需要修改/etc/resolv.conf文件中的DNS：shell12nameserver 8.8.4.4nameserver 8.8.8.8 使用networkmanager安装:1234pacman -S networkmanager #主程序pacman -S networkmanager-openconnect #支持VPN（也可选networkmanager-openvpn/networkmanager-pptp/networkmanager-vpnc任意一个）pacman -S rp-pppoe #支持 PPPoE/DSL 连接pacman -S network-manager-applet xfce4-notifyd #图形前端 注意：这些包是在xfce4下工作的，其他桌面环境看arch-wiki-NetWorkManager在第一次配置的时候不需要安装图形前端！等arch-chroot切换到真实系统后，第二次配置网络时才安装所有！ 查看是否有多个网络管理(systemctl简单使用)12#查看所有已启动的servicesystemctl --type service 查看是否有netctl相关的守护进程存在，如果有则关闭并禁止自动启动：12345678910111213systemctl stop 进程名systemctl disable 进程名#比如：systemctl stop netctl.servicesystemctl disable netctl.service#查看所有已安装的service(未必已启动)systemctl list-unit-files#查看进程状态systemctl status 进程名#显示详细进程信息systemctl show 进程名#查看某进程是否允许开机自启systemctl is-enabled 进程名 启动NetworkManager：1234systemctl start NetworkManager.service #立即启动 NetworkManagersystemctl enable NetworkManager.service #开机自动启用 NetworkManager#配置安装镜像系统时只需要执行立即启动的命令#真实系统最好都执行 同步源：1pacman -Syy 启动NetworkManager之后才可以执行命令来连接网络！！ 命令行的使用方法：1234567891011121314151617# wifi操作举例：nmcli dev wifi connect &lt;name&gt; password &lt;password&gt; #连接到 WiFi 网络nmcli dev wifi connect &lt;name&gt; password &lt;password&gt; iface wlan1 [profile name] #通过接口 wlan1 连接到 WiFi 网络:nmcli dev disconnect iface eth0 #断开 WiFi 连接:nmcli con up uuid &lt;uuid&gt; #通过一个已断开连接的接口重新连接:nmcli con show #获得一份 UUID 列表:nmcli dev #查看网络设备及其状态:nmcli r wifi off #关闭 WiFi:# 其他操作如有线网可以使用帮助命令查看：nmcli help#OBJECT和COMMAND可以用全称也可以用简称，最少可以只用一个字母，建议用头三个字母。#OBJECT里面我们平时用的最多的就是connection和device，这里需要简单区分一下connection和device。#device叫网络接口，是物理设备#connection是连接，偏重于逻辑设置 图形界面使用方法：这个就没必要说了，等安装好xfce桌面环境后菜单和面板项目里都有 具体的安装步骤u盘启动12345#linux下#首先确定好u盘的设备名(不是分区)，我的是/dev/sdblsblk #查看所有连接到系统的设备和分区状况dd if=你arch镜像的绝对路径 of=/dev/sdb #将镜像写入u盘#windows下自己百度吧 做好启动盘后以UEFI方式启动u盘即可 对硬盘分区使用parted工具，我的硬盘的/dev/sda123parted /dev/sda print #查看sda磁盘的分区表类型parted /dev/sda #开始分区#具体分区步骤不再赘述 格式化分区为linux可用分区我的硬盘分区情况：sda1：efi(esp)分区sda11：/根分区sda8：/bootsda10：/homesda9：/swap123456mkfs.vfat -F32 /dev/sda1 #格式化efi分区为fat32（如果是linux+windows双系统则不格式化此分区）mkfs.ext4 /dev/sda11 #格式化根分区，下同mkfs.ext4 /dev/sda8mkfs.ext4 /dev/sda10mkswap /dev/sda9 #格式化swap分区swapon /dev/sda9 #启用swap分区 挂载分区 注意: 不要在这里挂载 swap 必须先挂载 / (root) 分区，其它目录都要在 / 分区中创建然后再挂载。在安装环境中用 /mnt 目录挂载根分区：1mount /dev/sda11 /mnt 接着挂载其他分区：1234567mkdir /mnt/homemount /dev/sda10 /mnt/homemkdir /mnt/bootmount /dev/sda8 /mnt/boot#在挂载好的/boot分区中创建efi文件夹并挂载efi分区mkdir /mnt/boot/efimount /dev/sda1 /mnt/boot/efi 选择镜像源1nano /etc/pacman.d/mirrorlist 将我国的镜像源(速度快的放前面,可以有多个)反注释：Server = http://mirrors.163.com/archlinux/$repo/os/$archServer = http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch 安装基本系统12pacstrap -i /mnt base base-devel #“-i”选项是是否选择包的意思，去掉则自动全部安装 生成 fstab12genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab #可以用 -L 代替 -U，及lable和uuidnano /mnt/etc/fstab #查看是否正确 Chroot 并开始配置新系统1arch-chroot /mnt /bin/bash 执行上面的命令后就会从安装镜像所在的系统切换到硬盘中的新系统（真实系统） Locale本地1nano /etc/locale.gen #反注释需要的本地化类型 例如：en_US.UTF-8 UTF-8 #英文zh_CN.UTF-8 UTF-8 #中文 1234#接着执行locale-gen以生成locale讯息locale-gen echo LANG=en_US.UTF-8 &gt; /etc/locale.conf #创建 locale.conf 并提交您的本地化选项 locale.gen文件中反注释的本地化选项为本系统所有的可选选项执行locale-gen命令是提交并初始化而locale.conf文件中的配置才是你真正为系统选中的选项 时区1ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime #中国时区 硬件时间123hwclock --systohc --utc #将硬件时间设置为 UTC hwclock --systohc --localtime #将硬件时间设置为 localtime#命令自动生成 /etc/adjtime Hostname主机名12echo myhostname &gt; /etc/hostnamenano /etc/hosts #修改hosts添加你的主机名 为硬盘中的系统配置网络这次的配置将会永久生效不会因为关机重启而失效具体步骤看文章开始位置：networkmanager的安装和使用 设置 Root 密码1passwd 安装并配置 GRUB1234pacman -S dosfstools efibootmgr grub os-prober #安装需要的包grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=arch_grub --recheck grub-mkconfig -o /boot/grub/grub.cfg#这一步：grub-mkconfig,可能会出错，不过不用管 如果你想手动编辑grub.cfg或了解更多的关于grub安装和配置的方法可以去看：arch-wiki-GRUB 卸载分区并重启系统123exitumont -R /mntreboot 你应该重启到你安装的arch系统中，而不是u盘里的系统！ 进一步配置硬盘中的新系统再次安装GRUB如果你在安装系统时，在执行grub-mkconfig自动生成grub.conf文件时出现了错误或者你的多系统，但第一次安装GRUB时只有arch系统的启动项那么就在这里从新安装一边grub就行了具体方法同上面第一次安装GRUB 新增日常使用的账户添加一个名为：zhangsan的用户，并设置用户密码12useradd -m -g users -G audio,video,floppy,network,rfkill,scanner,storage,optical,power,wheel,uucp -s /bin/bash zhangsanpasswd zhangsan 选项含义：-m：创建用户目录，本例中会创建/home/zhangsan文件夹-g：设置用户的主组为users，也就是将用户添加到users组中，你可以先为自己创建一个组：groupadd zhangsan然后再执行添加用户的命令，users是默认已存在的组，如果你直接把users修改为zhangsan，而不新建zhangsan组，会提示组zhangsan不存在-G：设置用户的附属组，也就是将用户添加到其他组，但这些组是附属组，如果不添加用户到相应的附属组，则用户没有附属组相应的权限-s：设置用户的登录shell 注意：设置登录shell时，官方教程是这样的：-s /usr/bin/bash但是经过测试，设置为/usr/bin/bash是无法登录的！害我搞了很久。。 安装xorg图形框架详细看arch-wiki-Xorg安装基本框架：1pacman -S xorg-server xorg-twm xorg-xclock xterm xorg-xinit xorg-xinit包提供了startx和xinti命令，startx和xinti命令的配置文件为：/etc/X11/xinit/xinitrc可以在此配置文件的末尾加上启动桌面环境或窗口管理器的命令，比如启动xfce4桌面环境：1exec startxfce4 不过本文并没有采用startx的方式直接启动桌面环境，而是通过显示管理器(登录管理器)来启动桌面环境xfce4，具体后文再说。 具体的Xorg图形界面可以通过 /etc/X11/xorg.conf 或 /etc/xorg.conf 和位于 /etc/X11/xorg.conf.d/ 的配置文件进行配置。Arch 在 /etc/X11/xorg.conf.d 提供了默认的配置文件。大部分系统不需要任何配置就能正常使用。用户可以创建自己的配置文件，需要以 XX- 开头(XX 是数字)并以.conf 结尾(例如 10 在 20 之前读取)。 笔记本安装触摸板驱动1pacman -S xf86-input-synaptics 其配置文件为：/etc/X11/xorg.conf.d 目录下 10-synaptics.conf 文件 安装显卡驱动可以使用命令查看你的电脑的显卡信息：1lspci | grep VGA 然后查看官方源中有哪些开源驱动：1pacman -Ss xf86-video 这样是查看官方元中有哪些nvidia驱动：1pacman -Ss nvidia 我的笔记本是双显卡：intel+nvidia 安装intel显卡开源驱动1pacman -S xf86-video-intel libva-intel-driver 这样就行了，intel挺简单，但也意味着不如nvidia强大 开源和闭源驱动只能选择其中一个安装！！！ 安装nvidia显卡开源驱动1pacman -S xf86-video-nouveau 安装nvidia显卡闭源驱动1pacman -S nvidia 双显卡切换 最好等安装完X框架和桌面环境后再来配置这个！ 安装bumblebee,bbswtich等：1pacman -S bumblebee bbswitch mesa xf86-video-intel nvidia ib32-nvidia-utils lib32-mesa-libgl 添加相关用户到 bumblebee 组：12gpasswd -a user bumblebee#其中 user 是要添加的用户登录名 启动bumblebee服务(守护进程)1systemctl enable bumblebeed.service 重启，以使组变更生效 测试 Bumblebee 是否支持你的 Optimus 系统123456optirun glxgears -info#或者：optirun glxspheres64#或者optirun glxspheres32#这三个只要任意一个能成功运行无报错中断即可证明bumblebee已经可以正常运行了 Bumblebee用法：12345optirun [options] application [application-parameters]#例如，用 Optimus 启动Windows程序:optirun wine application.exe#另外，用 Optimus 打开NVIDIA设置面板:optirun -b none nvidia-settings -c :8 Bumblebee和optirun的关系Bumblebee是管理独显的服务并不是命令，所以你不能直接执行“Bumblebee”来启动，并且上一步中它已经以服务方式启动了！Bumblebee包中提供了optirun命令，optirun可以看作是Bumblebee这个服务对用户放出的接口！用户通过optirun 程序来启动程序时可以让Bumblebee使用独显为启动的程序进行3D渲染！其他不是通过optirum启动的程序则不使用独显！ Bumblebee和bbswtich的关系和使用Bumblebee它的作用只是试图模拟 Optimus 技术的行为：当需要的时候，使用独立显卡进行渲染，不使用的时候让独显空闲，但不会禁用独显 这时就需要bbswtich了，bbswitch相当与是一种的电源管理，其目的是为了当bumblebee不再使用NVIDIA显卡时自动关闭NVIDIA显卡如果已安装 bbswitch ，Bumblebee 守护进程启动时会自动检测到，不需要特别设置。也可以这样做来确保系统加载bbswtich在/etc/modules-load.d下新建bbswitch.conf，并修改为如下内容,这样每次启动都会加载bbswitch模块了:1bbswitch 但是仅仅是加载是不够的，因为bbswitch的默认行为是保持显卡的开启状态， bumblebeed 启动时又并不禁用显卡，这就会导致开机后独显是开启状态，所以，在/etc/modprobe.d/下新建bbswitch.conf，并修改为如下内容：12#这是bbswitch加载的参数，我们让其默认关闭独显options bbswitch load_state=0 unload_state=1 另外，有时候有时候即便加载了我们配置如上的bbswitch，但是bbswitch却不能自动关闭显卡，是因为有些模块正在占用着独显，因此要禁掉一些模块再在/etc/modprobe.d/下新建nouveau_blacklist.conf，并修改为如下内容：1blacklist nouveau 还有，bbswitch(系统)会在关机时关闭NVIDIA显卡，这可能可能会在下一次启动时初始化DVIDIA显卡异常或是在双系统的windows下识别不到nvidia显卡有两种方法可以实现NVIDIA显卡总是在关机时被设置为启用状态：个人建议arch最好使用第一种第一种：添加如下systemd 服务:12345678910111213141516#首先在系统服务库中创建nvidia-enable.service服务nano /usr/lib/systemd/system/nvidia-enable.service#内容如下：[Unit]Description=Enable NVIDIA cardDefaultDependencies=no[Service]Type=oneshotExecStart=/bin/sh -c 'echo ON &gt; /proc/acpi/bbswitch'[Install]WantedBy=shutdown.target#然后将服务设置为自动启动systemctl enable nvidia-enable.service 第二种：使用关机脚本在/usr/lib/systemd/system-shutdown/下新建nvidia_card_enable.sh，并修改为以下内容，记得加运行权限：12345678#!/bin/bash case "$1" in reboot) echo "Enabling NVIDIA GPU" echo ON &gt; /proc/acpi/bbswitch ;; *) esac 禁用独显nvidia从上一步中可以了解到bumblebe的作用的控制独显的何时、给哪个应用渲染的功能，它并不控制独显的关闭和激活而负责独显的关闭和激活的是：bbswtich所以，如果你不需要使用独显的3D功能，那么你可以单独只安装一个bbswtich来控制独显即可，不要安装bumblebe等其他包具体如何配置bbswitch，你可以从上一步中提取关于bbswtich的配置步骤，照着做就行了 你也可以看我的另一片文章linux关闭nvidia独显的方法 测试Xorg是否正常启动安装玩xorg框架和显卡驱动后可以使用startx命令来测试图形框架是否可以正常启动只有图形框架正常后才能正常启动桌面环境xfce4和登录管理器lightdm首先重启，然后登录到tty命令行模式执行startx命令如果出现了画面：几个x终端还有x时钟和鼠标，那么就是安装成功了，可以接着安装桌面环境xfce4和登录管理器lightdm 安装xfce4桌面环境详细安装和配置看：arch-wiki-xfce41pacman -S xfce4 xfce4-goodies 安装LightDM登录管理器(显示管理器)详细安装和配置看arch-wiki-lighdm我没有通过startx的方式启动桌面环境，而是使用了登录管理器lightdm安装：1pacman -S lightdm lightdm-gtk-greeter 其配置文件为：/etc/lightdm/lightdm.conf安装好之后测试启动：1systemctl start lightdm.service 如果正常就会看到熟悉的登录界面了，不过不要登录，现在只是测试lightdm是否可以正常启动点击画面上的关机小图标，弹出关机对话，选择注销!注销之后就回到之前的tty命令行模式了，可以看到相关的启动信息一切正常，所以设置lightdm为开机自动启动，这样以后开机就不会出现tty命令行界面了，而是直接进入登录界面：1systemctl enable lightdm.service 之后你可以重启进入xfce4图形界面，然后在图形界面中使用终端来继续以下配置步骤，也可以不重启，直接继续 安装alsa-utils配置声音arch系统默认已经安装了alsa-libs支持库，可以支持xfce4中的混音器来控制系统的音量或者静音但是系统每次关机重启之后，默认的都是静音，你之前调的音量全部消失，解决方法：安装alsa-utils:1pacman -S alsa-utils 编辑下alsa的服务(服务脚本有问题，不能由systemctl管理)1nano /lib/systemd/system/alsa-state.service 查看是否有”[Install]”(包含此字段)12[Install]WantedBy=multi-user.target 有的话就不用继续编辑了，没有的话在末尾加上上述字段，保存然后启动服务，并允许其开机自启动：12systemctl start alsa-state.servicesystemctl enable alsa-state.service 上图是我的设置，Internal Mic最好设置为静音 安装中文字体1pacman -S wqy-microhei ttf-dejavu 让系统使用中文全局性的汉化不推荐全局汉化，这样可能会导致tty中无法汉化而出现乱码口口口但我使用的是这种方式1echo LANG=zh_CN.UTF-8&gt;/etc/locale.conf 单独在图形界面启用中文locale在用户各自的家目录下的~/.bashrc、~/.profile、~/.xinitrc或~/.xprofile中设置自己的用户环境，若文件不存在可以新建 .bashrc: 每次终端时读取并运用里面的设置.profile：每次启动系统的读取并运用里面的配置.xinitrc: 每次startx启动X界面时读取并运用里面的设置.xprofile: 每次使用lightdm等图形登录管理器时读取并运用里面的设置 从上面所说的文件中你认为合适的文件，然后将下面的命令添加到文件末尾即可12export LANG=zh_CN.UTF-8export LANGUAGE=zh_CN:en_US 结合本文，如果你不用全局性的汉化，而用这第二种方式的话，我个人推荐你在~/.xprofile文件中添加 安装fcitx输入法1pacman -S fcitx fcitx-im fcitx-cloudpinyin fcitx-configtool fcitx-googlepinyin fcitx-qt5 安装之后配置变量以确保系统使用fcitx、或者自行禁用其他输入法自动启动、如：ibus 将下面的命令复制到下面说的三种情况中的文件的末尾： 1：如果你使用显示管理器(如lightdm，gdm)进入桌面环境则使用家目录下的.xprofile文件，即：~/.xprofile2：如果你使用startx命令进入桌面环境则使用家目录下的.xinitrc文件，即：~/.xinitrc3：这种方法不推荐：使用/etc/profile文件，添加到此文件即意味着是系统级变量(上面两种情况是用户变量，不会影响到其他用户)，但这种方法可能会失败，导致部分应用无法启动fcitx，如gnome3.18中的gnome-terminal等这三种情况任选其一，也可全部都配置上123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS="@im=fcitx" 重启后就可以使用fcitx+谷歌输入法了，不过你也可以不现在重启接着往下配置 如果启动xfce4桌面环境后显示不正常具体表现为：窗口没有关闭按钮什么的框架窗口无法移动没有桌面背景（一片黑色）在桌面上点击右键鼠标无反映那么，解决方法是：12xfwm4 --daemonxfwm4 --replace 安装视频播放器mplayer+gnomeMplayer前端123pacman -S mplayer #主程序pacman -S gnome-mplayer #gnome图形前端pacman -S gecko-mediaplayer #控制firefox和chromium的影音播放(依赖gnome-mplayer) 全局配置：/etc/mplayer/example.conf 配置模板/etc/mplayer/input.conf 按键配置/etc/mplayer/mplayer.conf 配置文件（没有的话自己新建）12345678910111213141516171819202122232425262728293031323334353637# /etc/mplayer/mplayer.conf全局配置通用范例# 应用于所有文件类型的默认设置[default]# 使用X11输出影像vo=xv# 使用alsa输出音频ao=alsa# ao=oss # 使用OSS# 使用6声道channels = 6# 字幕占据3%屏幕空间subfont-text-scale = 3# 从不使用字体配置nofontconfig = 1# 当图像不适合屏幕长宽比时添加黑边# 宽屏用户vf-add=expand=::::1:16/9:16# 非宽屏用户#vf-add=expand=::::1:4/3:16#profile for up-mixing two channels audio to six channels# use -profile 2chto6ch to activate[2chto6ch]af-add=pan=6:1:0:.4:0:.6:2:0:1:0:.4:.6:2 #profile to down-mixing six channels audio to two channels# use -profile 6chto2ch to activate[6chto2ch]af-add=pan=2:0.7:0:0:0.7:0.5:0:0:0.5:0.6:0.6:0:0# 播放mp4和flv可能出现无图像[extension.mp4] demuxer=mov# 播放时禁用屏保heartbeat-cmd="xscreensaver-command -deactivate &amp;" # stop xscreensaverstop-xscreensaver="yes" # stop gnome-screensaver 用户配置：~/.mplayer/config其实gnome-mplayer前端也有配置 启用回收站和自动挂载arch默认没有回收站机制，u盘也不会自动挂载，windows盘也不会自动挂载，都需要手动mount，解决方法：1pacman -S gvfs 会自动安装所需依赖，安装好之后，注销重启生效 时间同步按照arch官方的wiki安装好系统后时间不对官方不提倡使用软件同步系统时间，但是没办法，只有同步时间最方便，方法：123pacman -S ntpsystemctl start ntpd.servicesystemctl enable ntpd.service 等待几分钟之后系统时间就同步正确了 然后将本机硬件时间设置为同步好的系统时间1hwclock --systohc --localtime 安装pidgin-lwqq1pacman -S pidgin pidgin-lwqq 装好之后直接就能用了，不过里面有很多设置项，有些功能需要自己调整才能正常使用，具体看：github-pidgin-lwqq简单教程上面的链接是使用教程，不用按着上面的安装方法自己下载源码同步什么的，只需要用这个章节的命令从官方源安装就行了 bash命令补全更快的命令补全操作加入下面这句话到readline默认的初始化文件(~/.inputrc或者/etc/inputrc中):1set show-all-if-ambiguous on 在终端正常的补全是按两下tab键才会发生，上面的命令是将其改成按一次tab键就激活补全 高级的自动命令补全(方法一)1pacman -S bash-completion 高级的自动命令补全(方法二)你可以加入以下内容到~/.bashrc文件中以实现补全功能:1234complete -cf your_command#比如:complete -cf sudocomplete -cf man 正常的sudo后的命令不会自动补全我用的是方法一，简单，方便 安装压缩文件管理器也就是归档管理器：可以用file-roller1sudo pacman -S file-roller 或者用xarchiver1sudo pacman -S xarchiver 个人推荐file-roller，不少发行办都内置了这个管理器 ftp:1sudo pacman -S filezilla 安装办公软件libreoffice:1sudo pacman -S libreoffice-still libreoffice-still-zh-CN libreoffice-still-en-GB 安装音乐播放器rhythmbox1sudo pacman -S rhythmbox 安装wine+QQ安装主程序包，q4wine是图形菜单1sudo pacman -S wine winetricks wine-mono wine_gecko q4wine 安装缺少的32位包使用regedit可能报错，则安装这个:1sudo pacman -S lib32-ncurses 安装flash可能报错，则安装这个：1sudo pacman -S lib32-mpg123 lib32-lcms2]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>uefi</tag>
        <tag>安装</tag>
        <tag>archlinux</tag>
        <tag>xfce4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tilda开机启动不透明]]></title>
    <url>%2F2016%2F05%2F01%2Ftilda%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E4%B8%8D%E9%80%8F%E6%98%8E%2F</url>
    <content type="text"><![CDATA[当前系统,archlinux+xfce4 tilda简介tilda有一个非常方便的功能,那就是绑定一个按键,来切换tilda这个终端模拟器的显示和隐藏,注意是显示和隐藏而不是开启和关闭,它在切换的期间不会影响终端中所执行的命令,如果用过deepin linux的话应该就知道dde自带的终端有个特殊的模式叫雷神模式,原理就跟tilda一样 开机启动设置tilda开机启动很简单,就是在’~/.config/autostart/‘下放一个tilda的desktop文件就行了,也可以把系统的链接过去:1ln -s /usr/share/applications/tilda.desktop ~/.config/autostart/ 发现问题可是当你开机后按’F1’(tilda默认绑定的按键)打开tilda后,如果你设置了tilda的背景为透明,你会发现透明没有生效,而是黑色的背景,此时按’CTRL-SHIFT-q’退出tilda,再重新打开,发现透明又生效了,经过再三校验tilda的配置文件的确正确后,只能猜测是xfce4桌面环境在刚启动的时候,透明化这个功能暂时还没有初始化完成,而此时tilda已经启动了,所以就造成上述结果 解决问题既然tilda的透明化需要等待系统初始化完毕,那么让tilda暂停一会儿再启动就行了所以上面开机启动一段在’~/.config/autostart/‘下的tilda.desktop文件就不要了,删掉后自己新建一个 总共需要两个文件,为了方便管理,都放在’~/.config/autostart/‘下第一个文件,tilda.desktop:12345678910[Desktop Entry]Version=1.0Type=ApplicationName=startTildaComment=start tilda terminalExec=sh ~/.config/autostart/tilda.shIcon=Path=Terminal=falseStartupNotify=false 第二个文件,tilda.sh:123#!/bin/bashsleep 10tilda 分别复制上面的两段代码到两个文件中,并把两个文件放到’~/.config/autostart/‘下,为了确保完成,赋予两个文件可执行权限:1chmod a+x ~/.config/autostart/* 第一个desktop文件的作用是:桌面环境启动时会执行这个文件中’Exec=’之后的命令而这里的命令则是调用tilda.sh文件,第二个sh文件,也就是tilda.sh文件中之后两行命令,第一行暂停10秒,第二行就是启动tilda了,可以根据自己需要修改暂停的时间,不过我这里5秒偶尔会出现依然不透明的情况]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tilda</tag>
        <tag>不透明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android关闭手机实体按键开启虚拟按键]]></title>
    <url>%2F2016%2F04%2F23%2Fandroid%E5%85%B3%E9%97%AD%E6%89%8B%E6%9C%BA%E5%AE%9E%E4%BD%93%E6%8C%89%E9%94%AE%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%2F</url>
    <content type="text"><![CDATA[注意实体按键和虚拟按键的区别使用的是android4.2版本，硬件：mt6589 以下操作都需要root权限！ 关闭实体按键功能包括:菜单,返回,home,最近 使用root文件管理器，如RE文件管理器在/system/usr/keylayout/Generic.kl文件中搜索menu，注意搜索结果应该是只有menu这一个单词，而不是包含menu的单词 搜索到后在这一行的开头，添加上一个英文的符号：‘#’也就是把这一行注释掉的意思！ 返回键：back同理、同上 我的手机菜单，home，返回键所对应的键值为(仅供参考)：123139 MENU158 BACK172 HOME 修改之后保存重启手机、被你注释掉的对应的实体功能键就失效了，点击没有任何反应如果不成功可以尝试注释掉其他的行 这只是关掉功能、但背光灯还是会亮的 关闭背光灯还是RE文件管理器在/sys/class/leds/button-backlight/brightness文件中、把其中的数字改为0、背光灯就不亮了 如果没有对应的路径、可以尝试在类似的其他路径中搜索 这种方法在关机重启之后会失效、也就是说在手机重启之后背光灯就又亮了上面关闭功能的方法是永久生效的 如果不想每次重新开机后都来这个路径下修改文件、可以手动写一个shell脚本、将下面的代码复制保存为brightnessOFF.sh1234#!/system/bin/shecho 0&gt;/sys/class/leds/button-backlight/brightnesschown root:root /sys/class/leds/button-backlight/brightnesschmod 777 /sys/class/leds/button-backlight/brightness 用RE文件管理器点击这个brightnessOFF.sh、弹出提示框、点击执行即可、立即生效如果嫌这样还麻烦、那就需要点专业知识了需要把上面的代码追加到安卓系统开机时自动执行的脚本文件中、如：/etc/install-recovery.sh或/etc/inti.goldfish.sh或者自己修改内核以支持init.d、然后把这个脚本文件放在/etc/init.d目录中注意可执行权限、也可以实现开机自动执行 开启虚拟按键RE文件管理器, /system/build.prop文件 先在文件中搜索： qemu.hw.mainkeys 如果已存在，将其修改为：qemu.hw.mainkeys=0如果不存在，则手动添加：qemu.hw.mainkeys=0添加位置随意 注意行首不能有`#‘符号！这个注释掉这一行的意思！]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>实体按键</tag>
        <tag>虚拟按键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中oracle数据库的监听和EM的开启和关闭shell脚本]]></title>
    <url>%2F2016%2F04%2F23%2Flinux%E4%B8%ADoracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%91%E5%90%AC%E5%92%8CEM%E7%9A%84%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%ADshell%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[linux和win下的oracle不同、开机后不能直接使用经过一段时间摸索、终于大体摸清了linux下oracle的数据库启动流程所以自己动手写了几个shell脚本、省的每次都要输一堆命令来启动数据库、启动监听、启动em。。不同的数据库安装和不同的系统可能有较大的差异、不能保证都能用 启动数据库123#!/bin/shecho 打开数据库echo startup|sqlplus "/as sysdba" 关闭数据库123#!/bin/shecho 关闭数据库echo shut|sqlplus "/as sysdba" 启动监听123#!/bin/shecho 打开监听lsnrctl start 关闭监听123#!/bin/shecho 关闭监听lsnrctl stop 打开em也就是通过浏览器访问：https://127.0.0.1:1158/em：123#!/bin/shecho 打开ememctl start dbconsole 关闭em123#!/bin/shecho 关闭ememctl stop dbconsole 以上各功能的shell脚本分别复制保存为6个后缀为’.sh’的文件、并赋予可执行权限在终端中分别执行就行了应该是没有启动顺序的要非得有的话： 数据库启动 监听启动 EM启动 第三步应该是可选的,如果不需要浏览器打开https://127.0.0.1:1158/em就不必执行开启em的脚本,如果数据库连不上或者有其他问题可以执行后开启试试]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>数据库</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uefi-gpt-linux修复grub rescue]]></title>
    <url>%2F2016%2F04%2F23%2Fuefi-gpt-linux%E4%BF%AE%E5%A4%8Dgrub-rescue%2F</url>
    <content type="text"><![CDATA[搜了点网上的资料、发现都是修复MBR分区的、我的电脑是GPT分区+UEFI、虽然不同、但也大同小异、出现grub rescue模式一般是硬盘分区出现变动、导致旧的grub找不到启动文件而出现的、 错误提示今天开机是出现了这样的提示：123error:file'/grub/x86_64-efi/normal.mod'not foundentering rescue mode...grub rescue&gt; 大概意思是那个路径下normal.mod文件找不到、从而进入了grub rescue模式那么在grub rescue 模式下应该怎么修复呢？首先使用set 命令只看当前错误的grub变量、下面是我的电脑的信息123456set#返回信息是：cmdpath=(hd0,gpt1)/EFI/Deepin 2014.2prefix=(hd0,gpt10)/grubroot=hd0,gpt10 数据分析那么我们开分析下这些数据、首先cmdpath指向的是UEFI的启动文件、这个应该不会错、因为硬盘第一分区一般都是EFI分区、并且目录“Deepin 2014.2”也不会出错 所以就应该是prefix和root变量出错了、并且是”gpt10”这个指向的分区出错了、这就好办了、只要找到并修改为正确的分区应该就行了 接着使用ls命令来查看当前硬盘上有哪些分区：1234ls//返回信息是：hd0,gpt1 hd0,gpt2 hd0,gpt3 hd0,gpt4 hd0,gpt* ....... 接下来就该测试到底那个分区才是正确的启动分区、我的linux的boot分区是单独挂出来的我们先往上看那个prefix变量、它指向一个分区下的grub目录、那么我们就用这个目录来测试看那个分区中包含grub目录、只要包含这个目录那么基本上就可以确定那个分区就是正确的启动分区了、也就是boot分区 查找正确分区使用ls (hd0,gpt*)/grub这个命令来逐一查看分区、注意命令中的*号、要用数字来代替因为我可以确定前几个分区是windows分区、所以我就从(hd0,gpt10)附近的分区开始测试1ls (hd0,gpt11)/grub 返回信息是提示错误、找不到、或者提示unknown systemfile也就是未知的文件系统所以这个分区：gpt11并不是我们要找的分区 接着:1ls (hd0,gpt9)/grub 返回了一些找到的文件夹和文件、其中就包含“x86_64-efi”目录、所以这个”gpt9”应该就是正确的启动分区 设置正确变量12set prefix=(hd0,gpt9)/grubset root=hd0,gpt9 注意、这里我把原来错误的gpt10改为了gpt9为什么不设置cmdpath呢？前面已经说了、这个变量一般是不会出错的设置好了之后使用下面的命令来加载模块：1insmod (hd0,gpt9)/grub/x86_64-efi/normal.mod 或者使用：1insmod normal 最好使用第一种方法、因为它使用的是完整的路径、可以保证不出错、前提是你找对了分区、 加载好之后grub rescue&gt;这个提示符应该就会发生变化了 然后使用: normal这个命令、就出启动到正常的grub启动菜单并正常进入linux了 真正解决问题到这里并没有完全搞定、如果你进入linux后重启的话就会发现又出现grub rescue模式了 因为grub rescue模式只是应急、它并没有真正把grub修改为正确的数据 所以要在终端中手动重新修改下grub 进入终端输入：123sudo update-grub#无错误返回、那么接着：sudo grub-install /dev/sda9 这里的sda9是你的boot分区、如果不确定可以再开一个终端使用mount命令来查看你的boot分区挂载到了哪儿 到这里才算是真正修复了]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>grub</tag>
        <tag>uefi</tag>
        <tag>rescue</tag>
        <tag>gpt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步安卓源码:Cannot fetch CyanogenMod/android external svox]]></title>
    <url>%2F2016%2F04%2F23%2F%E5%90%8C%E6%AD%A5%E5%AE%89%E5%8D%93%E6%BA%90%E7%A0%81-Cannot-fetch-CyanogenMod-android-external-svox%2F</url>
    <content type="text"><![CDATA[同步CM10.1到99%出现错误：error: Cannot fetch CyanogenMod/Android external svox 或者是这样的提示：repo sync Repository unavailable due to DMCA takedown 解决办法： repo init后修改 .repo/manifests/default.xml把&lt;project path=&quot;external/svox&quot; name=&quot;CyanogenMod/android_external_svox&quot;/&gt;替换修改为&lt;project path=&quot;external/svox&quot; name=&quot;platform/external/svox&quot; remote=&quot;aosp&quot; revision=&quot;refs/tags/android-4.4.4_r2&quot;/&gt; 注意红色文字部分、那是你同步的版本号 如果不确定应该改为多少、就搜索aosp、会发现每一个搜索结果中的行里都有一个类似的语句、 把这句里的版本号改为你搜索到的那些版本号就行了]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>repo</tag>
        <tag>Cannot</tag>
        <tag>fetch</tag>
        <tag>external</tag>
        <tag>svox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp-android使用http]]></title>
    <url>%2F2016%2F04%2F23%2Fjsp-android%E4%BD%BF%E7%94%A8http%2F</url>
    <content type="text"><![CDATA[先说两种客户端发送http到服务端、然后再说服务端如何处理 客户端首先客户端有两种方式可以发送http请求当然还有其他方式，这里只讨论这两种方式: doget方式客户端中先使用“url?name1=value1&amp;&amp;name2=value2&amp;&amp;….”来new出HttpGet的对象使用HttpClient的对象：deafultHttpClient来发送HttpGet的对象到服务端、同时将会获得服务器返回的HttpResponse对象、接着HttpResponse对象调用getEntity()来获取服务端发送过来的信息 dopost方式客户端先使用URL来new出HttpPost的对象接着使用NameValuePair来保存要传递的Post的参数可以使用集合框架、例如new一个List的对象params、并使用其add(new BasicNameValuePair(&quot;name&quot;,&quot;value&quot;))方法来将数据保存起来、 此时还不能直接发送、要将params放到HttpPost的对象中才行、然而List类型的params并不能直接被放置到HttpPost中 需要转换成另一种类型的数据：HttpEntity、在转换的同时还可以设置一下编码：1HttpEntity httpEntity=new UrlEncodedFormEntity("params","GB2312"); 将数据参数放置到HttpPost中：1httpPost.setEntity(httpEntity); 使用HttpClient的对象：deafultHttpClient来发送HttpPost的对象到服务端、同时将会获得HttpResponse对象、 接着HttpResponse对象调用getEntity()来获取服务端发送过来的信息 服务端服务端接收数据比较简单首先设置下请求编码防止中文乱码然后使用request对象来获取参数就行了1String username=request.getParameter("name")]]></content>
      <categories>
        <category>jsp</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>jsp</tag>
        <tag>http</tag>
        <tag>httpget</tag>
        <tag>httppost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java字符输入输出流在输出结尾多一个乱码字符:'?']]></title>
    <url>%2F2016%2F04%2F23%2Fjava%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%9C%A8%E8%BE%93%E5%87%BA%E7%BB%93%E5%B0%BE%E5%A4%9A%E4%B8%80%E4%B8%AA%E4%B9%B1%E7%A0%81%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[原因以及解决方法： 核心方法如下：12345678910111213141516171819202122232425262728public static void main(String[] args) throws Exception&#123; FileReader fr=new FileReader("test.txt"); FileWriter fw=new FileWriter("test2.txt"); /* int b=0; while(b!=-1)&#123; b=fr.read(); System.out.print("-"+(char)b); fw.write(b); &#125; 用这种方法会比下面的方法在最后的文本后面多出一个乱码'?' 因为当读取到最后一个字符时，b此时还不等于-1，判断后会接着读取 下一个字符，但在上一次读取时已读取到最后一个字符，所以这次 就什么都读取不到(产生乱码)，并返回-1，结束循环 */ int b; while((b=fr.read())!=-1)&#123; System.out.print("-"+(char)b); fw.write(b); //这个方法的优点在于它会在读取的同时判断是否执行方法体 &#125; fr.close(); fw.close();&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>乱码字符</tag>
        <tag>输出流</tag>
        <tag>输入流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux主要目录的作用]]></title>
    <url>%2F2016%2F04%2F22%2Flinux%E4%B8%BB%E8%A6%81%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[手动敲一遍、算是加强记忆吧~ /：文件系统的入口，也是最高一级的目录 /bin：最基本的且着急用户和普通用户都可以使用的命令放在此目录下，如：ls、cp等 /boot：存放Linux的内核及引导系统所需要的文件，包括引导装载程序 /etc：存放系统配置文件，一些服务器的配置文件也放在这里 /dev：存放所有的设备文件，比如声卡、磁盘等 /home：包含普通用户的个人主目录，如/home/lisi /lib：包含二进制文件的共享库 /media：即插即用型存储设备如U盘、光盘等的自动挂载点在此目录下创建 /mnt：用于存放临时性挂在存储设备，如光驱可挂载到/met/cdrom下 /proc：存放进程信息以及内核信息，由内核在内存中产生 /root：Linux超级用户的主目录 /sbin：存放系统管理命令，一般只有超级用户才能执行 /tmp：公用的临时文件目录。/var/tmp目录于此目录类似 /usr：存放应用程序及相关文件，比如命令、帮助文件等 /var：存放系统中经常变化（vary）的文件，如在/var/log目录中存放系统日志]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android中使用intent来实现Activity带数据跳转]]></title>
    <url>%2F2016%2F04%2F22%2Fandroid%E4%B8%AD%E4%BD%BF%E7%94%A8intent%E6%9D%A5%E5%AE%9E%E7%8E%B0Activity%E5%B8%A6%E6%95%B0%E6%8D%AE%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[为什么要使用startActivityForResult大家都知道startActivity()是用来切换跳转Activity的,如果想要在另个Activity中出书数据的话,只需要在源activity中使用intent.putExtra()方法传出数据,在对应activity中使用intent.get**Extra()方法接收数据就行了 那么startActivityForResult()方法呢,它也是用来带数据跳转activity的,可是这两个方法具体有什么区别呢？这就要说说带数据跳转的方向了, 第一个方法只能把数据发送过去,可是如果子activity需要再传送回一些数据呢？你可能会说,在子activity中使用intent.putExtra()方法把数据写入,在父activity中写入get*方法就行了嘛, 可是,这个父activity中的get方法要写在哪儿呢？写在onCreate方法中? 那么问题就来了,如果你在父activity中的onCreate方法中写入了get*方法来读取(获得)数据, 那么就意味着你一启动父activity就会执行get*方法(因为第一个执行的方法就是onCreate),而父activity是主方法,它必定是程序第一个执行的activity, 也就是说,此时还没有执行子activity,也就没有数据通过intent传过来,所以在执行onCreate时,执行到get*方法时就会读不到任何数据, 而且还会在每次启动activity时,不管需不需要从子activity接受数据都多此一举的执行一遍get*方法,来获取数据, 这样虽然可以实现从子activity中得到返回的数据,但却是不理想的,不正确的 startActivityForResult那么到底该怎么让父activity获取到从子activity传回的数据呢？ 这就是第二个方法：startActivityFoResult()方法的作用了 下面具体说说这个方法是怎么实现把子activity传回的数据读取过来的 先看看这个方法的参数：startActivityForResult(Intent intent,int requestCode) 发现第一个参数是Intent类型,这个就不必多说了,看看第二个int型的,看字义是“请求码”,其实作用也就是请求码,这个具体在下面说, 只要你使用了startActivityForResult(),那么就要在这个类中添加一个onActivityResult(int requestCode ,int resultCode ,Intent intent)这个方法,也就是让这个类重写Activity.onActivityResult(int requestCode, int resultCode, Intent data){}方法， 这里要注意，不要和PreferenceManager.OnActivityResultListener这个接口弄混了！实现这个接口也要重写这个接口的onActivityResult()方法，而且这个接口的方法和Activity.onActivityResult()参数是一样的，但返回不同！ 你可以称它为：回调方法(子activity回调父activity的方法), 当然你也可以不添加(或方法体为空),那也就代表你不需要对子activity传回的数据进行操作, 反之如果你要想对子activity传回的数据进行操作,那么把方法体写在这个方法中即可, 这个方法如同onCreate()一样是这个类的成员方法,也就是说这个方法不在onCreate方法中(这样就避免了一启动这个activity就执行get*方法), 这个方法有什么用呢,你可以理解为它是用来监视子activity的方法,只要子activity一结束(调用了finish()方法),它就会被执行,这样就实现了“回调”这一功能 下面看看这个方法的参数： int requestCode：与startActivityForResult(Intent intent,int requestCode)方法中的int requestCode参数对应,可以理解为请求码 int resultCode：见名知意,结果码,这个是在子activity中设置的 Intent intent：这个就不必多说了 重要参数接着我们来看看这几个参数的具体作用, int requestCode,请求码,它与父activity中的startActivityForResult(Intent intent,int requestCode)方法中的int requestCode参数对应, 用它来判断是从父activity中哪个组件请求进入子activity的,因为父activity中可能有多个按钮或其他组件都可以发出进入新的子activity的请求, 而onActivityResult()方法在父activity中只有一个,所以就可以(需要)来标记清楚 int resultCode,结果码,它也是起到标记的作用,它与子activity中使用setResult(int resultCode,Intent intent)方法来设置的resultCode参数对应, 那么它的作用也就和子activity有关,用它可以来判断是哪个子activity在结束后来回调这个回调方法的,因为父activity可能需要跳转到多个不同的子activity 而onActivityResult()方法在父activity中只有一个,所以就可以(需要)来标记清楚 Intent intent,请求执行回调方法的intent 代码实例大体都说完了,下面给出一个java代码来直观的看一下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//父activity核心代码： Button button1=(Button)findViewById(R.id.button1); Button button2=(Button)findViewById(R.id.button2);//onCreate核心代码： onCreate()&#123; //为按钮1设置监听，放入名为data1的数据100，设置请求吗为1 button1.setOnClickListener(new View.OnClickListener()&#123; onClick()&#123; Intent intent1=new Intent(); intent.setClass(this, one.class); intent.putExtra("data1", "100"); startActivityForResult(intent , 1); &#125; &#125; //为按钮2设置监听，放入名为data2的数据200，设置请求吗为2 button2.setOnClickListener(new View.OnClickListener()&#123; onClick()&#123; Intent intent2=new Intent(); intent.setClass(this, two.class); intent.putExtra("data2", "200"); startActivityForResult(intent , 2); &#125; &#125; &#125; //回调方法 onActivityResult(int requestCode, int resultCode, Intent intent)&#123; super.onActivityResult(requestCode, resultCode, intent); switch(requestCode)&#123;//判断父activity中的哪个按钮 case 1://如果是按钮1 &#125; case 2://如果是按钮2 &#125; &#125; switch(resultCode)&#123;//判断是哪个子activity case 1://如果是子activity1 &#125; case 2://如果是子activity2 &#125; &#125;//******************************************************************//子activity1:one.java核心代码Button button1=(Button)findViewById(R.id.button1); onCreate()&#123; //为按钮1设置监听，设置结果吗为1 button1.setOnClickListener(new View.OnClickListener()&#123; onClick()&#123; setResult(1,intent); finish(); &#125; &#125;//*********************************************************************//子activity2:two.java核心代码Button button1=(Button)findViewById(R.id.button1); onCreate()&#123; //为按钮1设置监听，设置结果吗为2 button1.setOnClickListener(new View.OnClickListener()&#123; onClick()&#123; setResult(2,intent); finish(); &#125; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>intent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bat批处理编译执行java]]></title>
    <url>%2F2016%2F04%2F22%2Fbat%E6%89%B9%E5%A4%84%E7%90%86%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8Cjava%2F</url>
    <content type="text"><![CDATA[虽然有eclipse等强大的IDE工具、但有时不可避免的需要用命令行来手动编译和执行java程序、最近我就碰到的这样的问题、突然感觉编译和执行时都要敲一遍java或class文件的名字、这样好麻烦、 碰巧刚刚学习了下dos系统和批处理、所以就想自己写一个批处理.bat、来省事点、虽然不复杂、但初次写批处理还是被某些问题难住了、不过黄天不负有心人、最终还是写出来了： 把下面的两段代码分别复制、打开记事本、粘贴进去、保存为后缀为：”.bat”的文件、 然后把这两个.bat文件随意放在电脑上的任何地方、比如桌面上(建议放在桌面上)、以后需要手动编译和执行 java时、先把选中的java文件拖到MyJavac.bat文件上、 这里假设我将第一段代码保存为了MyJavac.bat文件,下同MyJava.bat、就会自动编译生成class文件到java文件所在目录了、 然后再选中需要执行的class文件将其拖到MyJava.bat文件上、就会批量执行了、 这两个小程序都是最多支持9个java或class文件同时编译和执行、 本来打算将编译和执行和在一起呢、但是想了想、还是这样分开比较好、 下面是代码： 批量编译MyJavac：12345@echo offecho.for %%i in (%1 %2 %3 %4 %5 %6 %7 %8 %9) do (%%~di &amp;&amp; cd %%~dpi &amp;&amp; javac %%i &amp;&amp; if %errorlevel%==0 echo %%~nxi编译完成 )echo.pause 批量执行MyJava:12345@echo offecho.for %%i in (%1 %2 %3 %4 %5 %6 %7 %8 %9) do (%%~di &amp;&amp; cd %%~dpi &amp;&amp; start call java %%~ni )echo.pause]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>批处理</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adt-sdk-tools-eclipse-java版本关系]]></title>
    <url>%2F2016%2F04%2F22%2Fadt-sdk-tools-eclipse-java%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[图片、反正这东西只是查看、不需要复制粘贴]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>sdk</tag>
        <tag>adt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中this和.this]]></title>
    <url>%2F2016%2F04%2F22%2Fjava%E4%B8%ADthis%E5%92%8C-this%2F</url>
    <content type="text"><![CDATA[“this”是指(或者说:所代表的是)当前这段代码所在的类的对象,而”类名.this”是指”类名”的对象(一般在匿名类或内部类中使用来调用外部类的方法或属性) 例： 1234567891011class A &#123; public void method（）&#123; A.this //这里的"A.this"就是表示类"A"的对象,在这种情况下"A.this"和"this"是一样的 &#125; class B &#123; //"class A"中的一个内部类"B"(内部类也可以是使用关键字"new" 所新实例出来的一个匿名类或者接口,比如"new OnClickListener()") void method1() &#123; A.this //这里的"A.this"还是表示类"A"的对象。。但是这里是在内部类里面。。所以这里如果使用的是"this"那就是内部类B的对象了。。但是我们经常会在内部类里面调用外部的东西。。所以就用"A.this"这种方式就行了 &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新博客的第一篇]]></title>
    <url>%2F2016%2F04%2F20%2Fmy-first-blog-on-hexo-github-pages%2F</url>
    <content type="text"><![CDATA[本博客是使用hexo(一个静态网站生成框架)和github pages搭建的一个博客系统主题使用的是: next 过一段时间就会把在csdn的一些文章迁移过来 测试图片:]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
</search>
